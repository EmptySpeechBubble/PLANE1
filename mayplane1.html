<!DOCTYPE html>
<html lang="en">
<!-- VERSION: 3.1-IFE-ENHANCED-2025-11-29 -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Music for Airplanes</title>
    <style>
        :root {
            /* IFE-inspired color palette */
            --ife-blue: #2C3E50;
            --ife-accent: #3498DB;
            --ife-cyan: #5DADE2;
            --map-land: #95A5A6;
            --map-ocean: #34495E;
            --route-red: #E74C3C;
            --panel-dark: #1A1A2E;
            --panel-overlay: rgba(26, 26, 46, 0.92);
            --text-light: #ECF0F1;
            --text-muted: #BDC3C7;
            --success: #27AE60;
            --warning: #F39C12;
            --danger: #E74C3C;

            /* Legacy color variables for JavaScript compatibility */
            --cockpit-dark: #1A1A2E;
            --cockpit-mid: #252544;
            --cockpit-light: #2f2f50;
            --panel-border: #3a3a5a;
            --panel-bg: rgba(26, 26, 46, 0.95);
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
            --text-color: #ecf0f1;
            --gauge-bg: #1a1a2e;
            --switch-off: #555;
            --switch-on: #2ecc71;
            --led-off: #333;
            --led-green: #2ecc71;
            --led-red: #e74c3c;
            --led-yellow: #f39c12;

            --border-radius: 12px;
            --transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Dark mode variables */
        .dark-mode {
            --ife-blue: #1a2332;
            --panel-dark: #0f0f1e;
            --panel-overlay: rgba(15, 15, 30, 0.95);
            --map-ocean: #1a2332;
        }

        /* === CALMING THEME VARIATIONS === */
        /* Theme 1: Classic IFE (default - already set in :root) */
        
        /* Theme 2: Dawn Flight */
        .theme-dawn {
            --ife-blue: #4A3B47;
            --ife-accent: #E8A598;
            --ife-cyan: #F4C2B8;
            --map-land: #D4A59A;
            --map-ocean: #F5E6E8;
            --route-red: #D97B6C;
            --panel-dark: #3A2E34;
            --panel-overlay: rgba(58, 46, 52, 0.92);
            --text-light: #FFF5F0;
            --text-muted: #E8C4BC;
            --success: #9BA882;
            --warning: #E8A598;
            --danger: #D97B6C;
        }

        /* Theme 3: Ocean Crossing */
        .theme-ocean {
            --ife-blue: #1A4D5E;
            --ife-accent: #4A9DB5;
            --ife-cyan: #7BC4DB;
            --map-land: #5A8FA0;
            --map-ocean: #0D2A35;
            --route-red: #D97B6C;
            --panel-dark: #0A1F28;
            --panel-overlay: rgba(10, 31, 40, 0.92);
            --text-light: #E8F4F8;
            --text-muted: #9BC4D4;
            --success: #5AB09D;
            --warning: #E8B45A;
            --danger: #D97B6C;
        }

        /* Theme 4: Northern Lights */
        .theme-northern {
            --ife-blue: #2A1A3E;
            --ife-accent: #8B7AB8;
            --ife-cyan: #A89DC9;
            --map-land: #6B5B8A;
            --map-ocean: #1A0F2E;
            --route-red: #B87A9F;
            --panel-dark: #1A0F2E;
            --panel-overlay: rgba(26, 15, 46, 0.92);
            --text-light: #F0E8FF;
            --text-muted: #C4B8D9;
            --success: #7AB89F;
            --warning: #D9A87A;
            --danger: #B87A9F;
        }

        /* Theme 5: Desert Sky */
        .theme-desert {
            --ife-blue: #3E2A1A;
            --ife-accent: #D9A574;
            --ife-cyan: #E8C4A4;
            --map-land: #B8946A;
            --map-ocean: #4A3528;
            --route-red: #C97A5A;
            --panel-dark: #2A1A0F;
            --panel-overlay: rgba(42, 26, 15, 0.92);
            --text-light: #FFF4E8;
            --text-muted: #D9C4B0;
            --success: #9BA874;
            --warning: #E8B574;
            --danger: #C97A5A;
        }

        /* Smooth theme transitions */
        body, .map-view, .control-panel, .control-section, .tab-nav, .panel-header {
            transition: background-color 0.6s ease, color 0.6s ease;
        }


        /* === ENHANCED PLANE ANIMATIONS === */
        @keyframes planeBobbing {
            0%, 100% { transform: translateY(0px) rotate(var(--plane-rotation, 0deg)); }
            50% { transform: translateY(-4px) rotate(var(--plane-rotation, 0deg)); }
        }

        @keyframes planeBanking {
            0%, 100% { transform: rotate(var(--plane-rotation, 0deg)) rotateY(0deg); }
            50% { transform: rotate(var(--plane-rotation, 0deg)) rotateY(5deg); }
        }

        /* === MAP INTERACTIVITY ENHANCEMENTS === */
        .city-label.active-scale {
            animation: cityGlow 2s ease-in-out infinite;
        }

        @keyframes cityGlow {
            0%, 100% { 
                text-shadow: 0 0 8px rgba(0, 0, 0, 0.9), 0 0 15px rgba(0, 0, 0, 0.7);
                transform: scale(1);
            }
            50% { 
                text-shadow: 0 0 15px currentColor, 0 0 25px currentColor, 0 0 35px currentColor;
                transform: scale(1.1);
            }
        }

        .destination-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--ife-accent);
            border-radius: 50%;
            animation: markerPulse 2s ease-in-out infinite;
            box-shadow: 0 0 10px var(--ife-accent);
        }

        @keyframes markerPulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.3); opacity: 1; }
        }

        /* Flight path drawing */
        .flight-path-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(to right, transparent, var(--ife-cyan), transparent);
            opacity: 0.6;
            animation: pathDraw 1s ease-out;
        }

        @keyframes pathDraw {
            from { width: 0; opacity: 0; }
            to { width: 100%; opacity: 0.6; }
        }

        /* === AUDIO-REACTIVE ENHANCEMENTS === */
        .volume-meter {
            width: 100%;
            height: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .volume-meter-fill {
            height: 100%;
            background: linear-gradient(to right, var(--success), var(--warning), var(--danger));
            transition: width 0.1s ease;
            border-radius: 3px;
        }

        .led-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--led-off);
            transition: all 0.2s ease;
        }

        .led-indicator.active {
            background: var(--led-green);
            box-shadow: 0 0 8px var(--led-green);
            animation: ledPulse 1s ease-in-out infinite;
        }

        @keyframes ledPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* === CONTROL PANEL ENHANCEMENTS === */
        .tab-content {
            animation: tabSlideIn 0.3s ease-out;
        }

        @keyframes tabSlideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .control-section.collapsible .control-section-title {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 30px;
        }

        .control-section.collapsible .control-section-title::after {
            content: '▼';
            position: absolute;
            right: 10px;
            transition: transform 0.3s ease;
        }

        .control-section.collapsible.collapsed .control-section-title::after {
            transform: rotate(-90deg);
        }

        .control-section.collapsible.collapsed > *:not(.control-section-title) {
            display: none;
        }

        /* Button haptic-style feedback */
        .btn:active {
            transform: translateY(0) scale(0.98);
            box-shadow: none;
        }

        /* === ARTFUL DETAILS === */
        /* Aviation map grid lines */
        .map-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 49px, rgba(52, 152, 219, 0.1) 49px, rgba(52, 152, 219, 0.1) 50px),
                repeating-linear-gradient(90deg, transparent, transparent 49px, rgba(52, 152, 219, 0.1) 49px, rgba(52, 152, 219, 0.1) 50px);
            pointer-events: none;
            opacity: 0.3;
            z-index: 0;
        }

        /* Time-of-day lighting tint */
        .map-view.time-dawn { filter: sepia(0.2) brightness(1.1); }
        .map-view.time-day { filter: brightness(1.15); }
        .map-view.time-dusk { filter: sepia(0.3) brightness(0.9) hue-rotate(-10deg); }
        .map-view.time-night { filter: brightness(0.7) contrast(1.2); }

        /* Vignette effect when controls collapsed */
        .map-view::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 5;
        }

        .control-panel.collapsed ~ .map-view::after {
            opacity: 1;
        }

        /* Floating particles/clouds */
        .ambient-particle {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1), transparent);
            border-radius: 50%;
            pointer-events: none;
            animation: particleFloat 20s linear infinite;
        }

        @keyframes particleFloat {
            from { transform: translate(0, 0) scale(1); opacity: 0; }
            10% { opacity: 0.3; }
            90% { opacity: 0.3; }
            to { transform: translate(100vw, -50vh) scale(1.5); opacity: 0; }
        }


        /* === MOBILE OPTIMIZATIONS === */
        @media (max-width: 768px) {
            /* Prevent zoom on double-tap */
            * {
                touch-action: manipulation;
            }

            /* Larger touch targets */
            .btn {
                min-height: 48px;
                min-width: 48px;
                padding: 14px 22px;
                font-size: 1rem;
            }

            .tab-button {
                min-height: 48px;
                font-size: 0.9rem;
            }

            .slider {
                height: 40px;
                -webkit-appearance: none;
                appearance: none;
            }

            .slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
                -webkit-appearance: none;
                appearance: none;
            }

            .slider::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }

            /* Better scrolling in panels */
            .tab-content {
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
            }

            /* Swipe gesture indicator */
            .panel-header::before {
                content: '';
                position: absolute;
                top: 8px;
                left: 50%;
                transform: translateX(-50%);
                width: 40px;
                height: 4px;
                background: var(--text-muted);
                border-radius: 2px;
                opacity: 0.5;
            }

            /* Optimize city labels for mobile */
            .city-label {
                font-size: 0.75rem;
                text-shadow: 0 0 4px rgba(0, 0, 0, 1), 0 0 8px rgba(0, 0, 0, 0.8);
            }
        }

        @media (max-width: 480px) {
            .control-grid {
                grid-template-columns: 1fr;
            }

            .header-stat-label {
                font-size: 0.55rem;
            }

            .header-stat-value {
                font-size: 0.8rem;
            }

            .tab-button {
                min-width: 80px;
                padding: 10px 12px;
                font-size: 0.75rem;
                gap: 4px;
            }
        }


        /* === RESET & BASE === */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: var(--map-ocean);
            color: var(--text-light);
            font-size: 14px;
            line-height: 1.5;
            -webkit-tap-highlight-color: transparent;
            touch-action: pan-x pan-y;
        }

        /* === MAIN CONTAINER === */
        .container {
            width: 100%;
            height: 100vh;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* === FULL-SCREEN MAP VIEW === */
        .map-view {
            flex: 1;
            position: relative;
            width: 100%;
            height: 100%;
            background-color: var(--map-ocean);
            overflow: hidden;
        }

        /* Flight display takes full screen */
        .flight-display {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            touch-action: none;
        }

        /* All canvases fill entire screen */
        #flightCanvas,
        #noteVisualization,
        #landscapeCanvas,
        #starsCanvas,
        #trailCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            z-index: 1;
        }

        /* Sky gradient elements */
        #skyGradientTop,
        #skyGradientBottom {
            position: absolute;
            left: 0;
            width: 100%;
            z-index: -1;
            transition: background-color 5s ease;
        }

        #skyGradientTop {
            top: 0;
            height: 50%;
            background: rgb(50, 90, 170);
        }

        #skyGradientBottom {
            bottom: 0;
            height: 50%;
            background: rgb(110, 160, 200);
        }

        /* Realistic Commercial Airliner Design (Top-Down View) */
        .plane {
            position: absolute;
            width: 80px;
            height: 100px;
            z-index: 10;
            transform-origin: center;
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.5));
        }

        /* Fuselage (Main Body) */
        .plane-body {
            position: absolute;
            width: 16px;
            height: 70px;
            background: linear-gradient(to right,
                rgba(200, 200, 210, 0.3),
                rgba(255, 255, 255, 0.95) 30%,
                rgba(255, 255, 255, 0.95) 70%,
                rgba(200, 200, 210, 0.3)
            );
            left: 50%;
            top: 10px;
            transform: translateX(-50%);
            border-radius: 8px 8px 4px 4px;
            z-index: 5;
            box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.4);
        }

        /* Cockpit/Nose */
        .plane-body::before {
            content: '';
            position: absolute;
            width: 12px;
            height: 14px;
            background: linear-gradient(135deg,
                rgba(100, 180, 255, 0.4),
                rgba(180, 220, 255, 0.6)
            );
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 50% 50% 0 0;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        /* Main Wings */
        .plane-wings {
            position: absolute;
            width: 80px;
            height: 20px;
            background: linear-gradient(to bottom,
                rgba(255, 255, 255, 0.5),
                rgba(255, 255, 255, 0.85) 40%,
                rgba(255, 255, 255, 0.85) 60%,
                rgba(255, 255, 255, 0.4)
            );
            left: 0;
            top: 38px;
            z-index: 3;
            border-radius: 40% 40% 50% 50%;
            box-shadow:
                0 2px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        /* Wing Details - Ailerons */
        .plane-wings::before {
            content: '';
            position: absolute;
            width: 90%;
            height: 2px;
            background: rgba(200, 200, 220, 0.6);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 2px;
        }

        /* Tail Section Container */
        .plane-tail {
            position: absolute;
            width: 100%;
            height: 30px;
            left: 0;
            bottom: 5px;
            z-index: 4;
        }

        /* Horizontal Stabilizer */
        .plane-tail::before {
            content: '';
            position: absolute;
            width: 40px;
            height: 8px;
            background: linear-gradient(to bottom,
                rgba(255, 255, 255, 0.4),
                rgba(255, 255, 255, 0.75),
                rgba(255, 255, 255, 0.4)
            );
            left: 50%;
            bottom: 8px;
            transform: translateX(-50%);
            border-radius: 50%;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }

        /* Vertical Stabilizer */
        .plane-tail::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 18px;
            background: linear-gradient(to right,
                rgba(255, 255, 255, 0.5),
                rgba(255, 255, 255, 0.85),
                rgba(255, 255, 255, 0.5)
            );
            left: 50%;
            bottom: 0;
            transform: translateX(-50%);
            border-radius: 4px 4px 0 0;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }

        /* Cabin Windows */
        .plane-windows {
            position: absolute;
            width: 8px;
            height: 50px;
            left: 50%;
            top: 18px;
            transform: translateX(-50%);
            z-index: 6;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            gap: 3px;
        }

        .plane-windows::before,
        .plane-windows::after {
            content: '';
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 3px,
                rgba(100, 180, 255, 0.4) 3px,
                rgba(100, 180, 255, 0.4) 5px
            );
        }

        /* Engines on Wings */
        .plane-engine {
            position: absolute;
            width: 10px;
            height: 16px;
            background: linear-gradient(to bottom,
                rgba(220, 220, 230, 0.7),
                rgba(255, 255, 255, 0.9),
                rgba(240, 240, 250, 0.8)
            );
            top: 35px;
            border-radius: 40%;
            z-index: 4;
            box-shadow:
                0 2px 6px rgba(0, 0, 0, 0.4),
                inset 0 1px 1px rgba(255, 255, 255, 0.5);
            display: block;
        }

        .plane-engine.left {
            left: 8px;
        }

        .plane-engine.right {
            right: 8px;
        }

        /* Engine Glow (when active) */
        .plane-engine::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 8px;
            background: radial-gradient(circle,
                rgba(255, 200, 100, 0.8),
                rgba(255, 150, 50, 0.4),
                transparent
            );
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 50%;
            opacity: 0;
            animation: engineGlow 2s ease-in-out infinite;
        }

        /* Navigation Lights */
        .plane-body::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 3px;
            background: #fff;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.9);
            animation: blinkWhite 1.5s ease-in-out infinite;
        }

        /* Wing Lights */
        .plane-wings::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff4444;
            left: 2px;
            top: 50%;
            transform: translateY(-50%);
            border-radius: 50%;
            box-shadow:
                0 0 8px rgba(255, 68, 68, 0.9),
                76px 0 0 0 #44ff44,
                76px 0 0 0 rgba(68, 255, 68, 0) inset,
                76px 0 8px 0 rgba(68, 255, 68, 0.9);
            animation: blinkNav 2s ease-in-out infinite;
        }

        /* Contrails */
        .plane-contrail {
            display: block;
            position: absolute;
            width: 4px;
            height: 0;
            background: linear-gradient(to top,
                rgba(255, 255, 255, 0.6),
                rgba(255, 255, 255, 0.3),
                transparent
            );
            left: 50%;
            bottom: 0;
            transform: translateX(-50%);
            z-index: 2;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .plane.flying .plane-contrail {
            opacity: 1;
            animation: contrailFlow 3s linear infinite;
        }

        /* Animations */
        @keyframes planePulse {
            0%, 100% {
                filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.5));
            }
            50% {
                filter: drop-shadow(0 4px 16px rgba(255, 255, 255, 0.3));
            }
        }

        @keyframes engineGlow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        @keyframes blinkWhite {
            0%, 40%, 100% { opacity: 1; }
            20%, 60% { opacity: 0.3; }
        }

        @keyframes blinkNav {
            0%, 40%, 100% { opacity: 1; }
            20%, 60% { opacity: 0.2; }
        }

        @keyframes contrailFlow {
            0% { height: 0; opacity: 0; }
            20% { opacity: 0.6; }
            100% { height: 100px; opacity: 0; }
        }

        .plane.flying {
            animation: planePulse 3s ease-in-out infinite;
        }

        .plane.flying .plane-engine::after {
            opacity: 1;
        }

        /* Banking animation */
        .plane.banking-left {
            transform: perspective(200px) rotateY(-15deg);
        }

        .plane.banking-right {
            transform: perspective(200px) rotateY(15deg);
        }

        .plane-exhaust,
        .plane-trail {
            display: none;
        }

        /* Filter indicator */
        .filter-active-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 90%;
            border: 10px solid transparent;
            border-radius: 15px;
            pointer-events: none;
            z-index: 7;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .filter-active-indicator.active {
            opacity: 0.6;
            border-color: rgba(231, 76, 60, 0.2);
            box-shadow: inset 0 0 50px rgba(231, 76, 60, 0.3);
            animation: filterPulse 2s infinite ease-in-out;
        }

        @keyframes filterPulse {
            0% { box-shadow: inset 0 0 30px rgba(231, 76, 60, 0.2); }
            50% { box-shadow: inset 0 0 50px rgba(231, 76, 60, 0.3); }
            100% { box-shadow: inset 0 0 30px rgba(231, 76, 60, 0.2); }
        }

        /* City labels */
        .city-label {
            position: absolute;
            color: var(--text-color);
            font-size: 0.9em;
            z-index: 6;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.9), 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none;
            opacity: 0.9;
            transition: opacity 0.3s, transform 0.3s;
            font-weight: bold;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .city-label::before {
            content: '•';
            margin-right: 4px;
            font-size: 1.2em;
        }

        .city-label.region-na::before { color: #2ecc71; }
        .city-label.region-sa::before { color: #e74c3c; }
        .city-label.region-eu::before { color: #3498db; }
        .city-label.region-as::before { color: #f39c12; }
        .city-label.region-af::before { color: #9b59b6; }
        .city-label.region-oc::before { color: #16a085; }

        .city-label.region-na { color: #ceffe2; }
        .city-label.region-sa { color: #ffcecf; }
        .city-label.region-eu { color: #d3e9ff; }
        .city-label.region-as { color: #ffecd3; }
        .city-label.region-af { color: #ecd3ff; }
        .city-label.region-oc { color: #d3ffee; }

        /* City light twinkling effects */
        .city-label::after {
            content: '✦';
            position: absolute;
            left: -15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            opacity: 0.6;
            animation: cityTwinkle 3s ease-in-out infinite;
            color: inherit;
        }

        @keyframes cityTwinkle {
            0%, 100% { opacity: 0.3; transform: translateY(-50%) scale(0.8); }
            50% { opacity: 1; transform: translateY(-50%) scale(1.2); }
        }

        /* Reactive city glow when notes play nearby */
        .city-label.note-reactive {
            animation: cityNoteGlow 0.5s ease-out;
        }

        @keyframes cityNoteGlow {
            0% {
                text-shadow: 0 0 8px currentColor, 0 0 15px currentColor;
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 20px currentColor, 0 0 35px currentColor, 0 0 50px currentColor;
                transform: scale(1.15);
            }
            100% {
                text-shadow: 0 0 8px rgba(0, 0, 0, 0.9), 0 0 15px rgba(0, 0, 0, 0.7);
                transform: scale(1);
            }
        }

        .city-flash {
            animation: cityPulse 1s ease-out;
        }

        @keyframes cityPulse {
            0% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 255, 255, 0.8); }
            50% { transform: scale(1.5); text-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 30px rgba(255, 255, 255, 0.5); }
            100% { transform: scale(1); text-shadow: 0 0 8px rgba(0, 0, 0, 0.9), 0 0 15px rgba(0, 0, 0, 0.7); }
        }

        /* === BOTTOM SLIDE-UP CONTROL PANEL === */
        .control-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--panel-overlay);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 2px solid var(--ife-accent);
            z-index: 100;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
        }

        .control-panel.collapsed {
            transform: translateY(calc(100% - 50px));
        }

        .control-panel.expanded {
            transform: translateY(0);
            max-height: 75vh;
        }

        /* Collapsed state bar */
        .panel-header {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            cursor: pointer;
            user-select: none;
            border-bottom: 1px solid rgba(52, 152, 219, 0.3);
            background: linear-gradient(to bottom, rgba(26, 26, 46, 0.95), rgba(26, 26, 46, 0.92));
        }

        .panel-header:hover {
            background: linear-gradient(to bottom, rgba(36, 36, 56, 0.95), rgba(36, 36, 56, 0.92));
        }

        .panel-header-left {
            display: flex;
            gap: 20px;
            align-items: center;
            flex: 1;
        }

        .panel-header-center {
            display: flex;
            gap: 30px;
            align-items: center;
            flex: 1;
            justify-content: center;
        }

        .panel-header-right {
            display: flex;
            gap: 15px;
            align-items: center;
            flex: 1;
            justify-content: flex-end;
        }

        .header-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .header-stat-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .header-stat-value {
            font-size: 0.9rem;
            color: var(--ife-cyan);
            font-weight: 600;
        }

        .expand-indicator {
            color: var(--ife-accent);
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .control-panel.expanded .expand-indicator {
            transform: rotate(180deg);
        }

        /* Tab navigation */
        .tab-nav {
            display: flex;
            background: rgba(20, 20, 36, 0.6);
            border-bottom: 1px solid rgba(52, 152, 219, 0.3);
            overflow-x: auto;
            scrollbar-width: none;
        }

        .tab-nav::-webkit-scrollbar {
            display: none;
        }

        .tab-button {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--text-muted);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-weight: 500;
        }

        .tab-button:hover {
            background: rgba(52, 152, 219, 0.1);
            color: var(--text-light);
        }

        .tab-button.active {
            color: var(--ife-cyan);
            border-bottom-color: var(--ife-accent);
            background: rgba(52, 152, 219, 0.15);
        }

        /* Tab content */
        .tab-content {
            display: none;
            padding: 20px;
            overflow-y: auto;
            max-height: calc(75vh - 130px);
        }

        .tab-content.active {
            display: block;
        }

        .tab-content::-webkit-scrollbar {
            width: 8px;
        }

        .tab-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .tab-content::-webkit-scrollbar-thumb {
            background: var(--ife-accent);
            border-radius: 4px;
        }

        /* Control groups within tabs */
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .control-section {
            background: rgba(20, 20, 36, 0.6);
            border-radius: var(--border-radius);
            padding: 15px;
            border: 1px solid rgba(52, 152, 219, 0.2);
        }

        .control-section-title {
            color: var(--ife-accent);
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(52, 152, 219, 0.2);
        }

        /* Buttons */
        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            border: none;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 44px;
        }

        .btn-primary {
            background: var(--ife-accent);
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }

        .btn-secondary {
            background: rgba(52, 152, 219, 0.2);
            color: var(--text-light);
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(52, 152, 219, 0.3);
            border-color: var(--ife-accent);
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }

        /* Sliders */
        .slider-group {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85rem;
            color: var(--text-light);
        }

        .slider-value-display {
            color: var(--ife-cyan);
            font-weight: 600;
            font-size: 0.9rem;
        }

        .slider {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            outline: none;
            appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--ife-accent);
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.6);
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--ife-accent);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Toggle switches */
        .switch-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .switch-label {
            font-size: 0.85rem;
            color: var(--text-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-switch {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.4);
            transition: .3s;
            border-radius: 26px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .slider-switch:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        input:checked + .slider-switch {
            background-color: var(--success);
            border-color: var(--success);
        }

        input:checked + .slider-switch:before {
            transform: translateX(24px);
        }

        .led-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            display: inline-block;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: all 0.3s;
        }

        .led-indicator.active {
            background-color: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        /* Destination grid */
        .destination-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .destination-btn {
            padding: 15px 10px;
            background: rgba(20, 20, 36, 0.6);
            border: 2px solid rgba(52, 152, 219, 0.2);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-weight: 500;
        }

        .destination-btn:hover {
            background: rgba(52, 152, 219, 0.2);
            border-color: var(--ife-accent);
            transform: translateY(-2px);
        }

        .destination-btn.selected {
            background: var(--ife-accent);
            border-color: var(--ife-accent);
            color: white;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        /* Select dropdowns */
        .custom-select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 0.9rem;
            cursor: pointer;
            outline: none;
        }

        .custom-select:hover {
            border-color: var(--ife-accent);
            background: rgba(0, 0, 0, 0.4);
        }

        .custom-select option {
            background: var(--panel-dark);
            color: var(--text-light);
        }

        /* Top status bar (minimal) */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            background: linear-gradient(to bottom, rgba(26, 26, 46, 0.8), transparent);
            z-index: 50;
            pointer-events: none;
        }

        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-title {
            font-size: 1rem;
            font-weight: 300;
            color: var(--text-light);
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.9;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
        }

        .top-button {
            width: 36px;
            height: 36px;
            background: rgba(26, 26, 46, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 50%;
            color: var(--text-light);
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            pointer-events: all;
        }

        .top-button:hover {
            background: rgba(52, 152, 219, 0.3);
            border-color: var(--ife-accent);
            color: var(--ife-cyan);
            transform: scale(1.1);
        }

        /* Flight Announcements */
        #announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--panel-bg);
            padding: 20px 30px;
            border-radius: var(--border-radius);
            font-size: 1rem;
            max-width: 80%;
            z-index: 200;
            border-left: 5px solid var(--warning);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            display: none;
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: opacity 0.7s ease;
        }

        #announcement strong {
            color: var(--warning);
            display: block;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        /* Overlays */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay-content {
            background-color: var(--panel-bg);
            padding: 30px;
            border-radius: var(--border-radius);
            max-width: 750px;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid var(--ife-accent);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .overlay-content::-webkit-scrollbar {
            width: 10px;
        }

        .overlay-content::-webkit-scrollbar-track {
            background: var(--cockpit-dark);
            border-radius: 5px;
        }

        .overlay-content::-webkit-scrollbar-thumb {
            background: var(--ife-accent);
            border-radius: 5px;
        }

        .overlay-content h2 {
            color: var(--ife-cyan);
            margin-top: 0;
            text-align: center;
            font-size: 1.8rem;
            margin-bottom: 20px;
        }

        .overlay-content h3 {
            color: var(--ife-accent);
            font-size: 1.2rem;
            margin-top: 20px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(52, 152, 219, 0.3);
        }

        .overlay-content p {
            line-height: 1.7;
            margin: 15px 0;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .close-btn:hover {
            background: #c0392b;
            transform: rotate(90deg);
        }

        /* Keyboard shortcuts */
        .keyboard-shortcuts {
            background-color: rgba(20, 20, 36, 0.6);
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
        }

        .keyboard-shortcuts h3 {
            color: var(--success);
            margin-top: 0;
            font-size: 1rem;
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .shortcut kbd {
            background-color: rgba(52, 152, 219, 0.3);
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid var(--ife-accent);
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--ife-cyan);
        }

        /* Landing destination overlay */
        .landing-overlay .overlay-content {
            max-width: 900px;
        }

        .destinations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .destination-card {
            background-color: rgba(20, 20, 36, 0.6);
            padding: 20px;
            border-radius: var(--border-radius);
            border: 2px solid rgba(52, 152, 219, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .destination-card:hover {
            border-color: var(--ife-accent);
            background-color: rgba(52, 152, 219, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .destination-card.selected {
            border-color: var(--success);
            background-color: rgba(39, 174, 96, 0.2);
            box-shadow: 0 0 20px rgba(39, 174, 96, 0.4);
        }

        .destination-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .destination-card h3 {
            color: var(--ife-accent);
            margin: 10px 0;
            font-size: 1.1rem;
        }

        .destination-card p {
            color: var(--text-muted);
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .atmosphere-controls {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        .atmosphere-controls h3 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .atmosphere-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .atmosphere-select {
            width: 100%;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .atmosphere-select:hover {
            border-color: var(--ife-accent);
        }

        /* Flight log overlay */
        .flight-log-overlay .overlay-content {
            background: linear-gradient(to bottom, #1a2f38 0%, #2c3e50 100%);
            max-width: 900px;
            font-family: 'Courier New', monospace;
        }

        .flight-log-header {
            border-bottom: 2px solid var(--ife-accent);
            padding-bottom: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .flight-log-number {
            color: var(--ife-accent);
            font-size: 1.2rem;
            margin-top: 5px;
        }

        .log-section {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid var(--ife-accent);
            border-radius: 4px;
        }

        .log-entry {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 15px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(52, 152, 219, 0.2);
            font-size: 0.9rem;
        }

        .log-label {
            color: var(--ife-accent);
            font-weight: bold;
        }

        .log-value {
            color: var(--text-light);
        }

        .timeline-event {
            padding: 10px;
            margin: 8px 0;
            background-color: rgba(39, 174, 96, 0.1);
            border-left: 3px solid var(--success);
            font-size: 0.85rem;
        }

        .event-time {
            color: var(--ife-accent);
            font-weight: bold;
            margin-right: 10px;
        }

        /* Settings panel */
        #settingsPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--panel-bg);
            padding: 20px;
            border-radius: var(--border-radius);
            z-index: 1000;
            width: 90%;
            max-width: 400px;
            display: none;
            border: 2px solid var(--ife-accent);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        #settingsPanel h3 {
            text-align: center;
            margin-top: 0;
            color: var(--ife-cyan);
            margin-bottom: 20px;
        }

        /* Audio meter */
        .audio-meter-container {
            width: 100%;
            height: 8px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
            position: relative;
        }

        .audio-meter {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #2ecc71, #f39c12, #e74c3c);
            transition: width 0.1s ease;
        }

        .audio-level-label {
            position: absolute;
            right: 5px;
            top: -1px;
            font-size: 0.6rem;
            color: white;
            mix-blend-mode: difference;
        }

        /* Mobile responsive */
        @media screen and (max-width: 768px) {
            .control-panel.expanded {
                max-height: 80vh;
            }

            .panel-header {
                padding: 0 15px;
            }

            .panel-header-center {
                gap: 15px;
            }

            .header-stat {
                display: none;
            }

            .header-stat:first-child,
            .header-stat:last-child {
                display: flex;
            }

            .tab-content {
                padding: 15px;
                max-height: calc(80vh - 130px);
            }

            .control-grid {
                grid-template-columns: 1fr;
            }

            .button-grid {
                grid-template-columns: 1fr 1fr;
            }

            .destination-grid {
                grid-template-columns: 1fr 1fr;
            }

            .top-bar {
                padding: 0 10px;
            }

            .app-title {
                font-size: 0.85rem;
            }
        }

        @media screen and (max-width: 480px) {
            .control-panel.expanded {
                max-height: 85vh;
            }

            .panel-header-center {
                display: none;
            }

            .tab-button {
                min-width: 80px;
                padding: 10px 15px;
                font-size: 0.75rem;
            }

            .button-grid {
                grid-template-columns: 1fr;
            }

            .destination-grid {
                grid-template-columns: 1fr;
            }

            .overlay-content {
                padding: 20px;
                max-width: 95vw;
            }
        }

        /* Additional legacy styles for compatibility */
        .control-group {
            margin-bottom: 12px;
        }

        .control-label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: var(--text-light);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-value {
            min-width: 60px;
            font-size: 0.85rem;
            text-align: right;
            color: var(--ife-cyan);
            font-weight: 600;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }

        .control-button {
            padding: 12px 16px;
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 44px;
        }

        .control-button:hover {
            background: rgba(52, 152, 219, 0.3);
            border-color: var(--ife-accent);
            transform: translateY(-2px);
        }

        .control-button.primary {
            background: var(--ife-accent);
            border-color: var(--ife-accent);
            color: white;
        }

        .control-button.danger {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }

        .control-button.full {
            grid-column: span 2;
        }

        /* Gauges (hidden in new design but kept for compatibility) */
        .flight-gauges {
            display: none;
        }

        .gauge {
            display: none;
        }

        /* Status panel */
        .flight-status {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: var(--success);
            line-height: 1.3;
            max-height: 80px;
            overflow-y: auto;
        }

        .artist-info {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.85rem;
            border: 1px solid rgba(52, 152, 219, 0.2);
            margin-bottom: 12px;
        }

        .artist-style {
            color: var(--warning);
            font-style: italic;
            margin-top: 5px;
        }

        .destination-button {
            padding: 12px 10px;
            background: rgba(20, 20, 36, 0.6);
            border: 2px solid rgba(52, 152, 219, 0.2);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .destination-button:hover {
            background: rgba(52, 152, 219, 0.2);
            border-color: var(--ife-accent);
        }

        .destination-button.selected {
            background: var(--ife-accent);
            border-color: var(--ife-accent);
            color: white;
        }

        .artist-selector {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            margin-bottom: 12px;
        }

        /* Filter sliders - special styling */
        .slider.filter-slider::-webkit-slider-thumb {
            background: var(--danger);
        }

        .slider.compressor-slider::-webkit-slider-thumb {
            background: var(--warning);
        }

        .effect-label {
            font-size: 0.75rem;
            margin-top: 4px;
            text-align: center;
        }

        .effect-switches {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .effect-switch {
            flex: 1;
            min-width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
        }

        /* Cockpit compatibility */
        .cockpit-container {
            display: none;
        }

        .cockpit-panel {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Welcome Overlay -->
    <div class="overlay" id="welcomeOverlay">
        <div class="overlay-content">
            <h2>✈️ Music for Airplanes</h2>
            <p style="font-size: 1.1rem; line-height: 1.7; margin: 20px 0; text-align: center;">
                An immersive generative ambient music experience inspired by Brian Eno's "Music for Airports".
            </p>

            <p style="font-size: 0.95rem; line-height: 1.6; margin: 15px 0; opacity: 0.9;">
                Your flight deck controls shape evolving soundscapes. Altitude affects cabin pressure (sound thinness),
                speed creates wind noise, engine hums beneath you. Each note nudges your plane, making music and flight one journey.
            </p>

            <div class="keyboard-shortcuts">
                <h3>Quick Start</h3>
                <div class="shortcut">
                    <span>Take Off / Land</span>
                    <kbd>SPACE</kbd>
                </div>
                <div class="shortcut">
                    <span>Show Full Help</span>
                    <kbd>H</kbd>
                </div>
                <div class="shortcut">
                    <span>Toggle Controls</span>
                    <kbd>C</kbd>
                </div>
                <div class="shortcut">
                    <span>Emergency Eject</span>
                    <kbd>ESC</kbd>
                </div>
            </div>

            <p style="margin-top: 20px; font-size: 0.95rem; text-align: center; opacity: 0.8;">
                Press <strong>H</strong> anytime for complete documentation and controls.
            </p>

            <button class="btn btn-primary" id="welcomeStartBtn" onclick="if(typeof window.hideWelcomeOverlay === 'function') window.hideWelcomeOverlay(); return false;" style="width: 100%; margin-top: 20px; padding: 15px; font-size: 1.1rem;">
                Begin Flight
            </button>
        </div>
    </div>

    <!-- Help Overlay -->
    <div class="overlay hidden" id="helpOverlay">
        <div class="overlay-content">
            <button class="close-btn" id="helpCloseBtn">×</button>
            <h2>📖 Flight Manual</h2>

            <h3>🎵 How The Music Works</h3>
            <p><strong>Dual Sequencers:</strong> Two independent generative sequencers create interlocking melodic patterns.</p>
            <p><strong>Scale Systems:</strong> Choose from 8 flight routes with authentic musical scales - Japanese pentatonic, Arabic maqam, Indian raga, and more.</p>
            <p><strong>Artist Influences:</strong> 12 compositional styles from ambient pioneers subtly shape tempo, note patterns, and spatial character.</p>
            <p><strong>Plane as Instrument:</strong> Each note played nudges the plane, creating a feedback loop between music and flight.</p>

            <h3>🎛️ Audio Effects Explained</h3>
            <p><strong>Reverb:</strong> Convolver-based reverb simulates acoustic space.</p>
            <p><strong>Filter (Lowpass):</strong> Sculpts brightness by removing high frequencies.</p>
            <p><strong>Engine Hum:</strong> Low sawtooth drone that pitch-shifts with velocity.</p>
            <p><strong>Wind Noise:</strong> Bandpass-filtered white noise that intensifies with speed.</p>
            <p><strong>Cabin Pressure:</strong> Altitude-based lowpass filter simulating thinning air.</p>
            <p><strong>Rain/Thunder:</strong> Atmospheric effects for immersive weather.</p>
            <p><strong>Musical Particles:</strong> Seasonal particles that play notes from your scale.</p>

            <div class="keyboard-shortcuts">
                <h3>⌨️ Keyboard Shortcuts</h3>
                <div class="shortcut"><span>Take Off / Land</span><kbd>SPACE</kbd></div>
                <div class="shortcut"><span>Toggle Controls</span><kbd>C</kbd></div>
                <div class="shortcut"><span>Toggle UI</span><kbd>U</kbd></div>
                <div class="shortcut"><span>Full Screen</span><kbd>F</kbd></div>
                <div class="shortcut"><span>Randomize All</span><kbd>R</kbd></div>
                <div class="shortcut"><span>Clear Trail</span><kbd>T</kbd></div>
                <div class="shortcut"><span>View Flight Log</span><kbd>L</kbd></div>
                <div class="shortcut"><span>Emergency Eject</span><kbd>ESC</kbd></div>
            </div>
        </div>
    </div>

    <!-- Landing Destination Selector -->
    <div class="overlay landing-overlay hidden" id="landingOverlay">
        <div class="overlay-content">
            <h2>Choose Your Destination</h2>
            <p style="opacity: 0.8; text-align: center; margin-bottom: 30px;">Where would you like to land?</p>

            <div class="destinations-grid">
                <div class="destination-card" data-space="museum">
                    <div class="destination-icon">🏛️</div>
                    <h3>Museum Gallery</h3>
                    <p>Minimalist white space with filtered light</p>
                </div>
                <div class="destination-card" data-space="machiya">
                    <div class="destination-icon">🏯</div>
                    <h3>Traditional Machiya</h3>
                    <p>Japanese townhouse with paper screens</p>
                </div>
                <div class="destination-card" data-space="lobby">
                    <div class="destination-icon">🏢</div>
                    <h3>Corporate Lobby</h3>
                    <p>Modern glass and steel architecture</p>
                </div>
                <div class="destination-card" data-space="station">
                    <div class="destination-icon">🚉</div>
                    <h3>Train Station</h3>
                    <p>Quiet platform with distant sounds</p>
                </div>
                <div class="destination-card" data-space="university">
                    <div class="destination-icon">🎓</div>
                    <h3>University Building</h3>
                    <p>Modernist concrete and wood</p>
                </div>
                <div class="destination-card" data-space="pavilion">
                    <div class="destination-icon">🌊</div>
                    <h3>Waterside Pavilion</h3>
                    <p>Natural wood beside tranquil water</p>
                </div>
            </div>

            <div class="atmosphere-controls">
                <h3>Atmosphere</h3>
                <div class="atmosphere-grid">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Time</label>
                        <select id="timeSelect" class="atmosphere-select">
                            <option value="dawn">Dawn</option>
                            <option value="morning">Morning</option>
                            <option value="afternoon" selected>Afternoon</option>
                            <option value="evening">Evening</option>
                            <option value="night">Night</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Weather</label>
                        <select id="weatherSelect" class="atmosphere-select">
                            <option value="clear" selected>Clear</option>
                            <option value="rain">Rain</option>
                            <option value="mist">Mist</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Season</label>
                        <select id="seasonSelect" class="atmosphere-select">
                            <option value="spring" selected>Spring</option>
                            <option value="summer">Summer</option>
                            <option value="autumn">Autumn</option>
                            <option value="winter">Winter</option>
                        </select>
                    </div>
                </div>
            </div>

            <button class="btn btn-danger" id="cancelLandingBtn" style="width: 100%; margin-top: 20px; padding: 15px;">
                Cancel Landing
            </button>
        </div>
    </div>

    <!-- Flight Log Overlay -->
    <div class="overlay flight-log-overlay hidden" id="flightLogOverlay">
        <div class="overlay-content" id="flightLogPanel">
            <!-- Content will be dynamically generated -->
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settingsPanel">
        <h3>Application Settings</h3>

        <div class="control-group">
            <div class="switch-group">
                <label class="switch-label">Dark Mode</label>
                <label class="switch">
                    <input type="checkbox" id="darkModeToggle">
                    <span class="slider-switch"></span>
                </label>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Safe Low Frequency Cutoff (Hz)</label>
            <div class="slider-container">
                <input type="range" id="safeLowFreq" class="slider" min="20" max="80" step="1" value="20">
                <span id="safeLowFreqValue" class="slider-value">20 Hz</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Output Limiter Threshold</label>
            <div class="slider-container">
                <input type="range" id="limiterThreshold" class="slider" min="-20" max="-0.1" step="0.1" value="-3.0">
                <span id="limiterThresholdValue" class="slider-value">-3.0 dB</span>
            </div>
        </div>

        <div class="control-buttons">
            <button id="saveSettings" class="control-button primary">Save Settings</button>
            <button id="closeSettings" class="control-button">Cancel</button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="top-bar-left">
                <h1 class="app-title">Music for Airplanes</h1>
            </div>
            <div class="top-bar-right">
                <button class="top-button" id="helpButton" title="Show Help (H)">?</button>
                <button class="top-button" id="settingsButton" title="Settings">⚙️</button>
                <button class="top-button" id="emergencyEject" title="Emergency Eject (ESC)">!</button>
            </div>
        </div>

        <!-- Full-Screen Map View -->
        <div class="map-view">
            <div class="flight-display" id="flightContainer">
                <!-- Sky Gradient -->
                <div id="skyGradientTop"></div>
                <div id="skyGradientBottom"></div>
                <!-- Map Grid Overlay -->
                <div class="map-grid"></div>

                <!-- Ambient Particles Container -->
                <div id="ambientParticles"></div>


                <!-- Filter Indicator -->
                <div class="filter-active-indicator" id="filterIndicator"></div>

                <!-- Canvas Layers -->
                <canvas id="starsCanvas"></canvas>
                <canvas id="landscapeCanvas"></canvas>
                <canvas id="trailCanvas"></canvas>
                <canvas id="flightCanvas"></canvas>
                <canvas id="noteVisualization"></canvas>

                <!-- Airplane -->
                <div class="plane" id="plane">
                    <div class="plane-body"></div>
                    <div class="plane-wings"></div>
                    <div class="plane-tail"></div>
                    <div class="plane-windows"></div>
                    <div class="plane-engine left"></div>
                    <div class="plane-contrail"></div>
                    <div class="plane-engine right"></div>
                    <div class="plane-exhaust"></div>
                    <div class="plane-trail"></div>
                </div>

                <!-- City Labels Container -->
                <div id="cityLabels"></div>

                <!-- Announcement Panel -->
                <div id="announcement">
                    <strong>Cabin Announcement</strong>
                    <span id="announcementText"></span>
                </div>
            </div>
        </div>

        <!-- Bottom Slide-Up Control Panel -->
        <div class="control-panel collapsed" id="controlPanel">
            <!-- Collapsed State Header -->
            <div class="panel-header" id="panelHeader">
                <div class="panel-header-left">
                    <div class="header-stat">
                        <div class="header-stat-label">Flight Time</div>
                        <div class="header-stat-value" id="headerFlightTime">00:00:00</div>
                    </div>
                </div>
                <div class="panel-header-center">
                    <div class="header-stat">
                        <div class="header-stat-label">Altitude</div>
                        <div class="header-stat-value" id="headerAltitude">25,000 ft</div>
                    </div>
                    <div class="header-stat">
                        <div class="header-stat-label">Destination</div>
                        <div class="header-stat-value" id="headerDestination">World Tour</div>
                    </div>
                    <div class="header-stat">
                        <div class="header-stat-label">Tempo</div>
                        <div class="header-stat-value" id="headerTempo">90 BPM</div>
                    </div>
                </div>
                <div class="panel-header-right">
                    <div class="header-stat">
                        <div class="header-stat-label">Status</div>
                        <div class="header-stat-value" id="headerStatus">Ready</div>
                    </div>
                    <div class="expand-indicator">▲</div>
                </div>
            </div>

            <!-- Tab Navigation -->
            <div class="tab-nav">
                <button class="tab-button active" data-tab="flight">✈️ FLIGHT</button>
                <button class="tab-button" data-tab="audio">🎵 AUDIO</button>
                <button class="tab-button" data-tab="routes">🗺️ ROUTES</button>
                <button class="tab-button" data-tab="settings-tab">⚙️ SETTINGS</button>
            </div>

            <!-- TAB 1: FLIGHT -->
            <div class="tab-content active" id="flight-tab">
                <div class="control-grid">
                    <!-- Main Flight Controls -->
                    <div class="control-section">
                        <div class="control-section-title">Flight Deck</div>
                        <div class="button-grid">
                            <button id="takeoff" class="btn btn-success">Take Off</button>
                            <button id="land" class="btn btn-danger">Land</button>
                            <button id="testAudioBtn" class="btn btn-secondary">Test Audio</button>
                            <button id="fullscreenBtn" class="btn btn-secondary">Full Screen</button>
                            <button id="randomizeAll" class="btn btn-primary" style="grid-column: span 2;">Randomize All</button>
                        </div>
                    </div>

                    <!-- Flight Status -->
                    <div class="control-section">
                        <div class="control-section-title">Flight Information</div>
                        <div class="flight-status" id="statusPanel">
                            <div id="statusMessage">Welcome to Music for Airplanes. Click "Take Off" to begin.</div>
                        </div>
                        <div style="margin-top: 10px; font-size: 0.85rem;">
                            <div style="margin-bottom: 5px;">Destination: <span id="currentDestination" style="color: var(--ife-cyan); font-weight: 600;">World Tour</span></div>
                            <div>Artist: <span id="currentArtist" style="color: var(--ife-cyan); font-weight: 600;">Various Artists</span></div>
                        </div>
                    </div>

                    <!-- Visual Controls -->
                    <div class="control-section">
                        <div class="control-section-title">Display</div>
                        <div class="button-grid">
                            <button id="toggleUI" class="btn btn-secondary">Hide UI</button>
                            <button id="clearTrail" class="btn btn-danger">Clear Trail</button>
                            <button id="flightLogBtn" class="btn btn-secondary" style="grid-column: span 2;">View Flight Log</button>
                        </div>
                        <div class="slider-group" style="margin-top: 15px;">
                            <div class="slider-label">
                                <span>Trail Intensity</span>
                                <span class="slider-value-display" id="trailIntensityValue">1.0</span>
                            </div>
                            <input type="range" id="trailIntensity" class="slider" min="0.1" max="5" step="0.1" value="1">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Persistence</span>
                                <span class="slider-value-display" id="persistenceValue">50%</span>
                            </div>
                            <input type="range" id="persistence" class="slider" min="0" max="1" step="0.01" value="0.5">
                        </div>
                    </div>
                </div>
            </div>

            <!-- TAB 2: AUDIO -->
            <div class="tab-content" id="audio-tab">
                <div class="control-grid">
                    <!-- Master Audio Controls -->
                    <div class="control-section">
                        <div class="control-section-title">Master Audio</div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Cabin Volume</span>
                                <span class="slider-value-display" id="volumeValue">0.15</span>
                            </div>
                            <input type="range" id="volume" class="slider" min="0" max="0.3" step="0.01" value="0.15">
                            <div class="audio-meter-container">
                                <div class="audio-meter" id="audioMeter"></div>
                                <div class="audio-level-label" id="audioLevelLabel">-∞ dB</div>
                            </div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Cabin Atmosphere (Reverb)</span>
                                <span class="slider-value-display" id="reverbValue">30%</span>
                            </div>
                            <input type="range" id="reverb" class="slider" min="0" max="1" step="0.05" value="0.3">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Note Decay</span>
                                <span class="slider-value-display" id="decayValue">5s</span>
                            </div>
                            <input type="range" id="decay" class="slider" min="0.1" max="10" step="0.1" value="5">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Bass Level</span>
                                <span class="slider-value-display" id="bassLevelValue">70%</span>
                            </div>
                            <input type="range" id="bassLevel" class="slider" min="0" max="1" step="0.05" value="0.7">
                        </div>
                    </div>

                    <!-- Flight Parameters -->
                    <div class="control-section">
                        <div class="control-section-title">Flight Parameters</div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Flight Speed (BPM)</span>
                                <span class="slider-value-display" id="tempoValue">90</span>
                            </div>
                            <input type="range" id="tempo" class="slider" min="40" max="200" step="1" value="90">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Flight Altitude</span>
                                <span class="slider-value-display" id="altitudeValue">Cruising</span>
                            </div>
                            <input type="range" id="altitude" class="slider" min="0.5" max="2" step="0.05" value="1">
                        </div>
                    </div>

                    <!-- Audio Effects Grid -->
                    <div class="control-section" style="grid-column: 1 / -1;">
                        <div class="control-section-title">Audio Effects</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                            <div class="switch-group">
                                <span class="switch-label">Air Filter <span class="led-indicator" id="filterLed"></span></span>
                                <label class="switch">
                                    <input type="checkbox" id="filterToggle">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                            <div class="switch-group">
                                <span class="switch-label">Turbulence (LFO) <span class="led-indicator" id="lfoLed"></span></span>
                                <label class="switch">
                                    <input type="checkbox" id="lfoToggle">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                            <div class="switch-group">
                                <span class="switch-label">Compressor <span class="led-indicator" id="compressorLed"></span></span>
                                <label class="switch">
                                    <input type="checkbox" id="compressorToggle">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                            <div class="switch-group">
                                <span class="switch-label">Engine Hum <span class="led-indicator active" id="engineLed"></span></span>
                                <label class="switch">
                                    <input type="checkbox" id="engineToggle" checked>
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                            <div class="switch-group">
                                <span class="switch-label">Wind Noise <span class="led-indicator active" id="windLed"></span></span>
                                <label class="switch">
                                    <input type="checkbox" id="windToggle" checked>
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                            <div class="switch-group">
                                <span class="switch-label">Altitude Filter <span class="led-indicator active" id="altitudeFilterLed"></span></span>
                                <label class="switch">
                                    <input type="checkbox" id="altitudeFilterToggle" checked>
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                            <div class="switch-group">
                                <span class="switch-label">Rain Ambience <span class="led-indicator" id="rainLed"></span></span>
                                <label class="switch">
                                    <input type="checkbox" id="rainToggle">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                            <div class="switch-group">
                                <span class="switch-label">Distant Thunder <span class="led-indicator" id="thunderLed"></span></span>
                                <label class="switch">
                                    <input type="checkbox" id="thunderToggle">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                            <div class="switch-group">
                                <span class="switch-label">Musical Particles <span class="led-indicator" id="musicalParticlesLed"></span></span>
                                <label class="switch">
                                    <input type="checkbox" id="musicalParticlesToggle">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Filter Controls -->
                    <div class="control-section" id="filterControlsPanel">
                        <div class="control-section-title">Filter Controls</div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Filter Cutoff</span>
                                <span class="slider-value-display" id="filterCutoffValue">20000 Hz</span>
                            </div>
                            <input type="range" id="filterCutoff" class="slider filter-slider" min="20" max="20000" step="1" value="20000">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>LFO Rate</span>
                                <span class="slider-value-display" id="lfoRateValue">1/4 Note</span>
                            </div>
                            <input type="range" id="lfoRate" class="slider filter-slider" min="0" max="7" step="1" value="2">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>LFO Amount</span>
                                <span class="slider-value-display" id="lfoAmountValue">50%</span>
                            </div>
                            <input type="range" id="lfoAmount" class="slider filter-slider" min="0" max="100" step="1" value="50">
                        </div>
                    </div>

                    <!-- Compressor Controls -->
                    <div class="control-section" id="compressorControlsPanel">
                        <div class="control-section-title">Compressor Controls</div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Threshold</span>
                                <span class="slider-value-display" id="compThresholdValue">-24 dB</span>
                            </div>
                            <input type="range" id="compThreshold" class="slider compressor-slider" min="-60" max="0" step="1" value="-24">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Ratio</span>
                                <span class="slider-value-display" id="compRatioValue">4:1</span>
                            </div>
                            <input type="range" id="compRatio" class="slider compressor-slider" min="1" max="20" step="0.5" value="4">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Attack</span>
                                <span class="slider-value-display" id="compAttackValue">0.1s</span>
                            </div>
                            <input type="range" id="compAttack" class="slider compressor-slider" min="0" max="1" step="0.01" value="0.1">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Release</span>
                                <span class="slider-value-display" id="compReleaseValue">0.25s</span>
                            </div>
                            <input type="range" id="compRelease" class="slider compressor-slider" min="0" max="1" step="0.01" value="0.25">
                        </div>
                    </div>

                    <!-- Musical Particles Controls -->
                    <div class="control-section" id="musicalParticlesControlsPanel" style="display: none;">
                        <div class="control-section-title">Musical Particles Controls</div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Particle Attack</span>
                                <span class="slider-value-display" id="particleAttackValue">0.1s</span>
                            </div>
                            <input type="range" id="particleAttackControl" class="slider" min="0.01" max="1" step="0.01" value="0.1">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Particle Release</span>
                                <span class="slider-value-display" id="particleReleaseValue">2.0s</span>
                            </div>
                            <input type="range" id="particleReleaseControl" class="slider" min="0.1" max="5" step="0.1" value="2.0">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Particle Gravity</span>
                                <span class="slider-value-display" id="particleGravityValue">1.5</span>
                            </div>
                            <input type="range" id="particleGravityControl" class="slider" min="0.5" max="3" step="0.1" value="1.5">
                        </div>
                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Musical Density</span>
                                <span class="slider-value-display" id="particleDensityValue">30%</span>
                            </div>
                            <input type="range" id="particleDensityControl" class="slider" min="0" max="1" step="0.05" value="0.3">
                        </div>
                    </div>
                </div>
            </div>

            <!-- TAB 3: ROUTES -->
            <div class="tab-content" id="routes-tab">
                <div class="control-grid">
                    <!-- Flight Routes -->
                    <div class="control-section" style="grid-column: 1 / -1;">
                        <div class="control-section-title">Flight Routes</div>
                        <div class="destination-grid">
                            <button id="destWorldTour" class="destination-btn selected">World Tour</button>
                            <button id="destAsia" class="destination-btn">Asia</button>
                            <button id="destEurope" class="destination-btn">Europe</button>
                            <button id="destAfrica" class="destination-btn">Africa</button>
                            <button id="destOceania" class="destination-btn">Oceania</button>
                            <button id="destAmericas" class="destination-btn">Americas</button>
                            <button id="destImpressionist" class="destination-btn">Impressionist</button>
                            <button id="destMinimalist" class="destination-btn">Minimalist</button>
                        </div>
                    </div>

                    <!-- Artist Selection -->
                    <div class="control-section">
                        <div class="control-section-title">Cabin Music</div>
                        <select id="artistSelector" class="custom-select">
                            <option value="various">Various Artists</option>
                            <option value="brianeno">Brian Eno</option>
                            <option value="eriksatie">Erik Satie</option>
                            <option value="haroldbudd">Harold Budd</option>
                            <option value="starsofthelid">Stars of the Lid</option>
                            <option value="boardsofcanada">Boards of Canada</option>
                            <option value="williambasinski">William Basinski</option>
                            <option value="stevereich">Steve Reich</option>
                            <option value="timhecker">Tim Hecker</option>
                            <option value="ryuichisakamoto">Ryuichi Sakamoto</option>
                            <option value="aphextwin">Aphex Twin</option>
                            <option value="jonhopkins">Jon Hopkins</option>
                        </select>
                        <div class="artist-info" id="artistInfo">
                            <div>Various Artists</div>
                            <div class="artist-style">Mixed Inspiration</div>
                        </div>
                    </div>

                    <!-- Route Info -->
                    <div class="control-section">
                        <div class="control-section-title">Destination Info</div>
                        <div style="font-size: 0.85rem; line-height: 1.6; color: var(--text-muted);">
                            <p id="destinationDescription">Explore the world through sound with our diverse collection of musical scales and ambient textures.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- TAB 4: SETTINGS -->
            <div class="tab-content" id="settings-tab-content">
                <div class="control-grid">
                    <!-- Presets -->
                    <div class="control-section">
                        <div class="control-section-title">Filter Presets</div>
                        <select id="filterPresets" class="custom-select">
                            <option value="">Select Filter Preset</option>
                            <option value="clearSky">Clear Sky</option>
                            <option value="highAltitude">High Altitude</option>
                            <option value="cloudCover">Cloud Cover</option>
                            <option value="nightFlight">Night Flight</option>
                        </select>
                    </div>

                    <div class="control-section">
                        <div class="control-section-title">Compressor Presets</div>
                        <select id="compressorPresets" class="custom-select">
                            <option value="">Select Compressor Preset</option>
                            <option value="safetyMode">Safety Mode</option>
                            <option value="smoothLanding">Smooth Landing</option>
                            <option value="turbulenceControl">Turbulence Control</option>
                            <option value="nightMode">Night Mode</option>
                        </select>
                    </div>

                    <!-- Theme Selection -->
                    <div class="control-section">
                        <div class="control-section-title">Cabin Ambiance Theme</div>
                        <select id="themeSelector" class="custom-select">
                            <option value="classic">Classic IFE (Blue/Gray)</option>
                            <option value="dawn">Dawn Flight (Warm Pastels)</option>
                            <option value="ocean">Ocean Crossing (Deep Blues)</option>
                            <option value="northern">Northern Lights (Purples/Greens)</option>
                            <option value="desert">Desert Sky (Warm Amber)</option>
                        </select>
                    </div>

                    <!-- Advanced Settings -->
                    <div class="control-section" style="grid-column: 1 / -1;">
                        <div class="control-section-title">Advanced Settings</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                            <div class="switch-group">
                                <span class="switch-label">Dark Mode</span>
                                <label class="switch">
                                    <input type="checkbox" id="darkModeToggle2">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Help Button -->
                    <div class="control-section" style="grid-column: 1 / -1;">
                        <button class="btn btn-primary" onclick="document.getElementById('helpButton').click()" style="width: 100%;">
                            Open Flight Manual
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden legacy elements for compatibility -->
    <div style="display: none;">
        <div id="timeNeedle"></div>
        <div id="altitudeNeedle"></div>
        <div id="tempoNeedle"></div>
        <div id="flightTime">00:00:00</div>
        <div id="flightAltitude">25,000 ft</div>
        <div id="tempoBPM">90 BPM</div>
        <div class="cockpit-container" id="cockpitContainer"></div>
        <button class="cockpit-toggle" id="cockpitToggle"></button>
    </div>

<script>
    // =============================================================================
    // DEBUG LOGGING SYSTEM
    // =============================================================================

    const LOG_LEVELS = {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        NONE: 4
    };

    let currentLogLevel = LOG_LEVELS.DEBUG;
    let loggingEnabled = true;

    function logDebug(category, message, data = null) {
        if (!loggingEnabled || currentLogLevel > LOG_LEVELS.DEBUG) return;
        const timestamp = new Date().toISOString();
        const prefix = `[${timestamp}] [DEBUG] [${category}]`;
        if (data !== null) {
            console.log(`${prefix} ${message}`, data);
        } else {
            console.log(`${prefix} ${message}`);
        }
    }

    function logInfo(category, message, data = null) {
        if (!loggingEnabled || currentLogLevel > LOG_LEVELS.INFO) return;
        const timestamp = new Date().toISOString();
        const prefix = `[${timestamp}] [INFO] [${category}]`;
        if (data !== null) {
            console.info(`${prefix} ${message}`, data);
        } else {
            console.info(`${prefix} ${message}`);
        }
    }

    function logWarn(category, message, data = null) {
        if (!loggingEnabled || currentLogLevel > LOG_LEVELS.WARN) return;
        const timestamp = new Date().toISOString();
        const prefix = `[${timestamp}] [WARN] [${category}]`;
        if (data !== null) {
            console.warn(`${prefix} ${message}`, data);
        } else {
            console.warn(`${prefix} ${message}`);
        }
    }

    function logError(category, message, error = null) {
        if (!loggingEnabled || currentLogLevel > LOG_LEVELS.ERROR) return;
        const timestamp = new Date().toISOString();
        const prefix = `[${timestamp}] [ERROR] [${category}]`;
        if (error !== null) {
            console.error(`${prefix} ${message}`, error);
            if (error instanceof Error && error.stack) {
                console.error('Stack trace:', error.stack);
            }
        } else {
            console.error(`${prefix} ${message}`);
        }
    }

    function logStateChange(category, stateName, oldValue, newValue) {
        logInfo(category, `State change: ${stateName}`, {
            from: oldValue,
            to: newValue
        });
    }

    // Performance timing
    const performanceTimers = new Map();

    function startTimer(timerName) {
        performanceTimers.set(timerName, performance.now());
        logDebug('PERFORMANCE', `Timer started: ${timerName}`);
    }

    function endTimer(timerName) {
        if (!performanceTimers.has(timerName)) {
            logWarn('PERFORMANCE', `Timer ${timerName} was never started`);
            return null;
        }
        const startTime = performanceTimers.get(timerName);
        const duration = (performance.now() - startTime).toFixed(2);
        logInfo('PERFORMANCE', `${timerName}: ${duration}ms`);
        performanceTimers.delete(timerName);
        return duration;
    }

    logInfo('SYSTEM', '═══════════════════════════════════════════════');
    logInfo('SYSTEM', 'Music for Airplanes - Initializing');
    logInfo('SYSTEM', 'VERSION: 2.0-2025-11-24-FIXED');
    logInfo('SYSTEM', '═══════════════════════════════════════════════');
    logInfo('SYSTEM', 'User Agent:', { userAgent: navigator.userAgent });
    logInfo('SYSTEM', 'Screen:', { width: window.screen.width, height: window.screen.height });
    logInfo('SYSTEM', 'Window:', { width: window.innerWidth, height: window.innerHeight });

    // =============================================================================
    // AUDIO CONTEXT AND NODES
    // =============================================================================

    // Audio context and nodes
    let audioContext = null;
    let masterGainNode = null;
    let highPassFilter = null; // Added high-pass filter for safety
    let limiterNode = null;    // Added limiter for safety
    let reverbNode = null;
    let convolverBuffer = null;
    let dryGainNode = null;
    let wetGainNode = null;
    let bassEQNode = null;     // Added bass EQ node
    let planePosition = { x: 50, y: 50 }; // Start in the middle of screen (percentages)
    let planeDirection = { x: 0.02, y: 0.01 }; // Slower initial direction values
    let isFlying = false;
    let activeOscillators = [];
    let lastNoteData = { frequency: 0, time: 0 };
    let currentNoteData = { frequency: 0, time: 0 };
    let announcementTimer = null;
    let flightStartTime = null;
    let uiVisible = true;
    let debugMode = false;
    let isFirstVisit = true;
    let trailPermaMode = true;
    let trailIntensity = 1.0;
    let audioMeter = null;
    let audioAnalyser = null;
    let audioUpdateInterval = null;
    let safeLowFreq = 20; // Low frequency cutoff
    let limiterThreshold = -3.0; // Limiter threshold
    
    // Filter and LFO nodes
    let filterNode = null;
    let lfoOscillator = null;
    let lfoGain = null;
    let isFilterEnabled = false;
    let isLfoEnabled = false;
    let currentLfoRate = 2;
    let currentLfoAmount = 50;
    
    // Compressor node
    let compressorNode = null;
    let isCompressorEnabled = false;

    // Immersive audio features
    let engineOscillator = null;
    let engineGain = null;
    let windNoiseNode = null;
    let windNoiseGain = null;
    let windNoiseFilter = null;
    let cabinPressureFilter = null;
    let turbulenceTimeout = null;
    let lastVelocity = { x: 0, y: 0 };
    let rainNoiseNode = null;
    let rainFilter = null;
    let rainGain = null;
    let rainReverb = null;
    let rainReverbGain = null;
    let thunderNoiseNode = null;
    let thunderFilter = null;
    let thunderGain = null;
    let thunderReverb = null;
    let thunderReverbGain = null;
    let thunderLFO = null;
    let thunderInterval = null;
    let isEngineEnabled = true;
    let isWindEnabled = true;
    let isCabinPressureEnabled = true;
    let isRainEnabled = false;
    let isThunderEnabled = false;
    let isMusicalParticlesEnabled = false;
    let particleAttack = 0.1;
    let particleRelease = 2.0;
    let particleGravity = 1.5;
    let particleDensity = 0.3; // 0-1, controls how many particles are musical
    let groundY = 0; // Will be set based on canvas height

    // Frequency visualization variables
    let frequencyData = null;
    let frequencyAnalyser = null;
    let frequencyBinCount = 128;

    // Gradient color system
    let currentGradientColors = {
        top: '#FFE5B4',
        middle: '#FFB6C1',
        bottom: '#E6E6FA'
    };
    let targetGradientColors = {...currentGradientColors};
    let gradientTransitionSpeed = 0.02; // Slow color lerp

    // LFO rate divisions (relative to BPM)
    const lfoDivisions = [
        { name: "1/16 Note", value: 4 },
        { name: "1/8 Note", value: 2 },
        { name: "1/4 Note", value: 1 },
        { name: "1/2 Note", value: 0.5 },
        { name: "1 Bar", value: 0.25 },
        { name: "2 Bars", value: 0.125 },
        { name: "4 Bars", value: 0.0625 },
        { name: "8 Bars", value: 0.03125 }
    ];
    
    // Initialize sequencer variables
    let sequencer1 = null;
    let sequencer2 = null;

    // Current artist selection
    let currentArtist = 'various';

    // Landing destination system
    let currentLandingSpace = null;
    let currentTime = 'afternoon';
    let currentWeather = 'clear';
    let currentSeason = 'spring';
    let isLanded = false;
    let landingParticles = [];

    // Flight log tracking system
    let flightLog = {
        flightNumber: null,
        departureTime: null,
        arrivalTime: null,
        totalFlightTime: 0,
        events: [],
        destinations: [],
        artists: [],
        effectsUsed: [],
        notesPlayed: 0,
        citiesVisited: new Set(),
        altitudeRange: { min: 1.0, max: 1.0 },
        currentSegmentStart: null,
        currentDestination: null,
        currentArtistName: null
    };
    let flightSessionActive = false;
    let logCounter = 1;

    // Destination spaces data
    const destinationSpaces = {
        museum: {
            name: "Museum Gallery",
            description: "A minimalist white gallery space with high ceilings and filtered natural light",
            reverb: 0.7,
            tempoModifier: 0.9,
            colors: {
                walls: "#f5f5f5",
                floor: "#e5e5e5",
                ceiling: "#ffffff",
                accent: "#d0d0d0"
            },
            ambience: ["quiet_footsteps", "distant_voices", "soft_echoes"]
        },
        machiya: {
            name: "Traditional Machiya",
            description: "A traditional Japanese townhouse with wooden structure and paper screens",
            reverb: 0.3,
            tempoModifier: 0.8,
            colors: {
                walls: "#8c7a6b",
                floor: "#73614e",
                ceiling: "#5e4e3f",
                accent: "#c7beb5"
            },
            ambience: ["wooden_creaks", "wind_chimes", "paper_rustle"]
        },
        lobby: {
            name: "Corporate Lobby",
            description: "A modern corporate space with glass, steel and geometric forms",
            reverb: 0.5,
            tempoModifier: 1.1,
            colors: {
                walls: "#d9d9d9",
                floor: "#f0f0f0",
                ceiling: "#ffffff",
                accent: "#a0a0a0"
            },
            ambience: ["air_flow", "distant_elevator", "marble_steps"]
        },
        station: {
            name: "Train Station",
            description: "A quiet Japanese train station with distant sounds and clean architecture",
            reverb: 0.8,
            tempoModifier: 1.0,
            colors: {
                walls: "#e0e0e0",
                floor: "#c0c0c0",
                ceiling: "#f2f2f2",
                accent: "#a9a9a9"
            },
            ambience: ["distant_announcement", "train_approach", "quiet_platform"]
        },
        university: {
            name: "University Building",
            description: "A modernist university space with concrete and wood elements",
            reverb: 0.6,
            tempoModifier: 1.0,
            colors: {
                walls: "#d6d6d6",
                floor: "#a8a8a8",
                ceiling: "#f5f5f5",
                accent: "#b3b3b3"
            },
            ambience: ["distant_voices", "page_turning", "chair_movement"]
        },
        pavilion: {
            name: "Waterside Pavilion",
            description: "A minimalist pavilion beside water with natural wood and openness",
            reverb: 0.4,
            tempoModifier: 0.7,
            colors: {
                walls: "#c9b18f",
                floor: "#8c7a6b",
                ceiling: "#d8c9b6",
                accent: "#e6dfd3"
            },
            ambience: ["water_lapping", "distant_birds", "gentle_breeze"]
        }
    };

    const timeSettings = {
        dawn: { name: "Dawn", lightColor: "#e8c9a9", lightIntensity: 0.4, tempoModifier: 0.8 },
        morning: { name: "Morning", lightColor: "#f2e6d8", lightIntensity: 0.7, tempoModifier: 1.0 },
        afternoon: { name: "Afternoon", lightColor: "#ffffff", lightIntensity: 1.0, tempoModifier: 1.1 },
        evening: { name: "Evening", lightColor: "#ffc38a", lightIntensity: 0.5, tempoModifier: 0.9 },
        night: { name: "Night", lightColor: "#a8c0ff", lightIntensity: 0.2, tempoModifier: 0.7 }
    };

    const weatherSettings = {
        clear: { name: "Clear", particleCount: 0, soundModifier: 1.0 },
        rain: { name: "Rain", particleCount: 200, soundModifier: 0.9 },
        mist: { name: "Mist", particleCount: 50, soundModifier: 0.8 }
    };

    const seasonSettings = {
        spring: { name: "Spring", particleType: "blossom", soundModifier: 1.1 },
        summer: { name: "Summer", particleType: "dust", soundModifier: 1.0 },
        autumn: { name: "Autumn", particleType: "leaf", soundModifier: 0.9 },
        winter: { name: "Winter", particleType: "snow", soundModifier: 0.8 }
    };
    let currentArtistName = 'Various Artists';
    
    // Current destination variables
    let currentDestination = 'worldTour';
    let currentDestinationName = 'World Tour';
    
    // Day/Night cycle variables
    let timeOfDay = 0; // 0 = dawn, 0.5 = noon, 1 = dusk, 1.5 = night
    
    // Filter presets
    const filterPresets = {
        clearSky: {
            cutoff: 20000,
            lfoRate: 0,
            lfoAmount: 0,
            enableLfo: false,
            name: "Clear Sky"
        },
        highAltitude: {
            cutoff: 15000,
            lfoRate: 5,
            lfoAmount: 20,
            enableLfo: true,
            name: "High Altitude"
        },
        cloudCover: {
            cutoff: 8000,
            lfoRate: 2,
            lfoAmount: 40,
            enableLfo: true,
            name: "Cloud Cover"
        },
        nightFlight: {
            cutoff: 3000,
            lfoRate: 6,
            lfoAmount: 60,
            enableLfo: true,
            name: "Night Flight"
        }
    };
    
    // Compressor presets for safety
    const compressorPresets = {
        safetyMode: {
            threshold: -20,
            ratio: 4,
            attack: 0.005,
            release: 0.1,
            name: "Safety Mode"
        },
        smoothLanding: {
            threshold: -30,
            ratio: 8,
            attack: 0.02,
            release: 0.3,
            name: "Smooth Landing"
        },
        turbulenceControl: {
            threshold: -15,
            ratio: 12,
            attack: 0.001,
            release: 0.05,
            name: "Turbulence Control"
        },
        nightMode: {
            threshold: -40,
            ratio: 6,
            attack: 0.05, 
            release: 0.5,
            name: "Night Mode"
        }
    };
    
    // Canvas elements
    const flightCanvas = document.getElementById('flightCanvas');
    const flightCtx = flightCanvas.getContext('2d');
    const noteCanvas = document.getElementById('noteVisualization');
    const noteCtx = noteCanvas.getContext('2d');
    const landscapeCanvas = document.getElementById('landscapeCanvas');
    const landscapeCtx = landscapeCanvas.getContext('2d');
    const starsCanvas = document.getElementById('starsCanvas');
    const starsCtx = starsCanvas.getContext('2d');
    const trailCanvas = document.getElementById('trailCanvas');
    const trailCtx = trailCanvas.getContext('2d', { alpha: true });
    const plane = document.getElementById('plane');
    const flightContainer = document.getElementById('flightContainer');
    const statusPanel = document.getElementById('statusPanel');
    const filterIndicator = document.getElementById('filterIndicator');
    
    // Cockpit UI Elements
    const cockpitContainer = document.getElementById('cockpitContainer');
    const cockpitToggle = document.getElementById('cockpitToggle');
    
    // Gauges
    const timeNeedle = document.getElementById('timeNeedle');
    const altitudeNeedle = document.getElementById('altitudeNeedle');
    const tempoNeedle = document.getElementById('tempoNeedle');
    
    // LED indicators
    const filterLed = document.getElementById('filterLed');
    const lfoLed = document.getElementById('lfoLed');
    const compressorLed = document.getElementById('compressorLed');
    
    // Main buttons
    const takeoffButton = document.getElementById('takeoff');
    const landButton = document.getElementById('land');
    const testAudioButton = document.getElementById('testAudioBtn');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const randomizeAllButton = document.getElementById('randomizeAll');
    const toggleUIButton = document.getElementById('toggleUI');
    const clearTrailButton = document.getElementById('clearTrail');
    const flightLogBtn = document.getElementById('flightLogBtn');
    
    // Flight controls
    const altitudeControl = document.getElementById('altitude');
    const tempoControl = document.getElementById('tempo');
    const persistenceControl = document.getElementById('persistence');
    const trailIntensityControl = document.getElementById('trailIntensity');
    
    // Audio controls
    const volumeControl = document.getElementById('volume');
    const reverbControl = document.getElementById('reverb');
    const decayControl = document.getElementById('decay');
    const bassLevelControl = document.getElementById('bassLevel');
    
    // Effect toggles
    const filterToggle = document.getElementById('filterToggle');
    const lfoToggle = document.getElementById('lfoToggle');
    const compressorToggle = document.getElementById('compressorToggle');
    const engineToggle = document.getElementById('engineToggle');
    const windToggle = document.getElementById('windToggle');
    const altitudeFilterToggle = document.getElementById('altitudeFilterToggle');
    const rainToggle = document.getElementById('rainToggle');
    const thunderToggle = document.getElementById('thunderToggle');
    const musicalParticlesToggle = document.getElementById('musicalParticlesToggle');
    const particleAttackControl = document.getElementById('particleAttackControl');
    const particleReleaseControl = document.getElementById('particleReleaseControl');
    const particleGravityControl = document.getElementById('particleGravityControl');
    const particleDensityControl = document.getElementById('particleDensityControl');
    
    // Filter controls
    const filterCutoffControl = document.getElementById('filterCutoff');
    const lfoRateControl = document.getElementById('lfoRate');
    const lfoAmountControl = document.getElementById('lfoAmount');
    
    // Compressor controls
    const compThresholdControl = document.getElementById('compThreshold');
    const compRatioControl = document.getElementById('compRatio');
    const compAttackControl = document.getElementById('compAttack');
    const compReleaseControl = document.getElementById('compRelease');
    
    // Presets
    const filterPresetsSelect = document.getElementById('filterPresets');
    const compressorPresetsSelect = document.getElementById('compressorPresets');
    
    // Artist selector
    const artistSelector = document.getElementById('artistSelector');
    const artistInfo = document.getElementById('artistInfo');
    
    // Destination buttons
    const destinationButtons = document.querySelectorAll('.destination-button');
    
    // Settings panel
    const settingsButton = document.getElementById('settingsButton');
    const settingsPanel = document.getElementById('settingsPanel');
    const saveSettingsBtn = document.getElementById('saveSettings');
    const closeSettingsBtn = document.getElementById('closeSettings');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const safeLowFreqControl = document.getElementById('safeLowFreq');
    const limiterThresholdControl = document.getElementById('limiterThreshold');

    // Help overlay
    const helpButton = document.getElementById('helpButton');
    const helpOverlay = document.getElementById('helpOverlay');
    const helpCloseBtn = document.getElementById('helpCloseBtn');

    // Emergency eject button
    const emergencyEjectBtn = document.getElementById('emergencyEject');
    
    // Audio meter
    const audioMeterElement = document.getElementById('audioMeter');
    const audioLevelLabel = document.getElementById('audioLevelLabel');
    
    // Landscape elements
    let mountains = [];
    let clouds = [];
    let flightPaths = [];
    let noteCircles = [];
    let stars = [];
    let cities = [];
    let planeTrail = [];
    let smoothedTrail = [];
    let MAX_TRAIL_POINTS = 200;
    let MAX_SMOOTHED_POINTS = 1000;

    // New visual effects
    let shootingStars = [];
    let cloudParticles = [];
    let contrailParticles = [];
    let atmosphericGlow = { opacity: 0, radius: 0 };
    let elementPersistence = 0.5;
    let lastAnnouncementTime = 0;
    let cityLabelsVisible = true;
    let lastCityFlashTime = 0;
    let noteCounter = 0;
    let cityDisplayInterval = 8;
    let activeCities = [];
    let cityMovementSpeed = 0.3;
    let planeMovementSpeed = 0.002;
    
    // Predefined flight paths
    let movieFlightPaths = [
        { start: { x: 10, y: 50 }, end: { x: 90, y: 50 }, duration: 30000 }, // Straight path (visible)
        { start: { x: 10, y: 30 }, end: { x: 90, y: 70 }, duration: 35000 }, // Diagonal path
        { start: { x: 10, y: 70 }, end: { x: 90, y: 30 }, duration: 35000 }, // Reverse diagonal
        { start: { x: 10, y: 60 }, end: { x: 50, y: 40 }, next: { x: 90, y: 60 }, duration: 40000 } // Path with turn
    ];
    
    // Movie-style flight path animation variables
    let currentPath = 0;
    let pathProgress = 0;
    let pathStartTime = null;
    let cameraX = 0;
    let cameraY = 0;

    // Color palette for visualization
    const colors = {
        mountains: [
            '#34495e', '#2c3e50', '#283747', '#212f3d', '#1b2631',
            '#2e4053', '#273746', '#212f3c', '#1a2530', '#1c2833',
            '#2a3132', '#1d2731', '#243640', '#2b303a', '#1e2a39',
            '#2d3b4f', '#233342', '#26394d', '#1f2c3d', '#1e3446'
        ],
        notes: [
            '#2ecc71', '#3498db', '#9b59b6', '#f1c40f', '#e67e22',
            '#1abc9c', '#16a085', '#27ae60', '#2980b9', '#8e44ad',
            '#e74c3c', '#d35400', '#f39c12', '#1f618d', '#7d3c98',
            '#2874a6', '#148f77', '#117a65', '#138d75', '#76448a'
        ],
        clouds: [
            'rgba(236, 240, 241, 0.15)', 'rgba(245, 245, 245, 0.12)', 
            'rgba(250, 250, 250, 0.08)', 'rgba(240, 240, 240, 0.10)', 
            'rgba(235, 235, 235, 0.14)', 'rgba(248, 248, 248, 0.09)',
            'rgba(230, 235, 240, 0.11)', 'rgba(242, 245, 248, 0.13)'
        ],
        flightPaths: 'rgba(236, 240, 241, 0.08)',
        plane: '#2ecc71',
        stars: ['#f5f5f5', '#e3e3e3', '#d4d4d4', '#f0f0f0', '#e8e8e8', '#f8f8f8', '#ededed', '#f2f2f2']
    };
    
    // Musical scales for different destinations
    const musicalScales = {
        worldTour: {
            harmonicNotes: [
                [261.63, 329.63, 392.44, 523.25],   // C Major
                [220.00, 277.18, 329.63, 440.00],   // A Minor
                [146.83, 220.00, 261.63, 329.63],   // D Minor
                [195.99, 246.94, 293.66, 391.99],   // G Minor
                [293.66, 349.23, 392.00, 493.88],   // D Major
                [174.61, 220.00, 261.63, 349.23],   // F Major
                [164.81, 196.00, 246.94, 329.63],   // E Minor
                [207.65, 246.94, 311.13, 392.00]    // G# Minor
            ],
            planeNotes: [
                [0, 4, 7, 12],              // Major triad with octave
                [4, 7, 11, 16],             // Major 7th chord
                [-3, 0, 4, 7],              // Minor triad with -3
                [-3, 0, 5, 9],              // Minor 6th chord
                [-5, 0, 4, 7, 11],          // Major 9th chord
                [0, 3, 7, 10, 14],          // Minor 9th chord
                [-2, 0, 3, 7, 10],          // Minor 7th with -2
                [2, 5, 9, 12, 16]           // Sus4 with extensions
            ]
        },
        asia: {
            // Pentatonic and Eastern-inspired scales
            harmonicNotes: [
                [261.63, 293.66, 349.23, 392.00, 440.00],     // C Major Pentatonic
                [261.63, 293.66, 311.13, 392.00, 440.00],     // C Japanese Hirajoshi
                [261.63, 277.18, 349.23, 392.00, 440.00],     // C Chinese scale
                [261.63, 293.66, 329.63, 349.23, 415.30],     // C Pelog (approx, gamelan-inspired)
                [261.63, 293.66, 311.13, 392.00, 415.30],     // C modified Japanese
                [261.63, 277.18, 329.63, 392.00, 457.69],     // C Ryukyu scale
                [261.63, 293.66, 311.13, 369.99, 392.00],     // C Indian raga inspired
                [261.63, 293.66, 327.03, 392.00, 436.04]      // C Persian inspired
            ],
            planeNotes: [
                [0, 2, 7, 9],               // Pentatonic fragments
                [0, 1, 5, 7, 8],            // Japanese mode intervals
                [0, 2, 4, 7, 9],            // Major pentatonic
                [0, 3, 5, 7, 10],           // Minor pentatonic
                [0, 1, 4, 8, 9],            // Eastern intervals
                [0, 1, 5, 7, 10],           // Balinese gamelan fragment
                [0, 2, 5, 7, 9, 12],        // Chinese scale intervals
                [0, 1, 3, 7, 8]             // South Asian inspired intervals
            ]
        },
        europe: {
            // Classical and European folk-inspired scales
            harmonicNotes: [
                [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88],   // C Major (complete)
                [220.00, 246.94, 261.63, 293.66, 329.63, 349.23, 392.00],   // A minor (complete)
                [246.94, 277.18, 293.66, 329.63, 369.99, 415.30, 440.00],   // B Dorian
                [164.81, 196.00, 220.00, 246.94, 261.63, 293.66, 329.63],   // E Phrygian
                [174.61, 196.00, 220.00, 246.94, 261.63, 293.66, 329.63],   // F Lydian
                [196.00, 220.00, 246.94, 261.63, 293.66, 329.63, 349.23],   // G Mixolydian
                [246.94, 261.63, 293.66, 329.63, 349.23, 392.00, 415.30],   // B Locrian
                [220.00, 246.94, 277.18, 293.66, 329.63, 369.99, 415.30]    // A Harmonic minor
            ],
            planeNotes: [
                [0, 2, 4, 5, 7, 9, 11],     // Major scale
                [0, 2, 3, 5, 7, 8, 10],     // Natural minor
                [0, 2, 3, 5, 7, 9, 10],     // Harmonic minor
                [0, 2, 3, 5, 7, 9, 11],     // Melodic minor
                [0, 2, 4, 6, 7, 9, 11],     // Lydian
                [0, 2, 4, 5, 7, 9, 10],     // Mixolydian
                [0, 2, 3, 5, 7, 8, 11],     // Dorian
                [0, 1, 3, 5, 7, 8, 10]      // Phrygian
            ]
        },
        africa: {
            // African and jazz-influenced scales
            harmonicNotes: [
                [261.63, 311.13, 349.23, 392.00, 466.16],     // C Mixolydian pentatonic (blues)
                [220.00, 261.63, 293.66, 349.23, 392.00],     // African pentatonic approximation
                [246.94, 293.66, 349.23, 392.00, 466.16],     // African rhythm-based scale
                [220.00, 233.08, 293.66, 349.23, 392.00],     // Blues with neutral 3rd (approx)
                [261.63, 293.66, 329.63, 349.23, 392.00, 440.00], // African 6-note scale
                [261.63, 293.66, 349.23, 415.30, 440.00],     // West African pentatonic
                [261.63, 277.18, 329.63, 392.00, 440.00],     // East African inspired
                [246.94, 293.66, 329.63, 392.00, 466.16]      // North African maqam inspired
            ],
            planeNotes: [
                [0, 3, 5, 6, 7, 10],        // Blues scale
                [0, 2, 5, 7, 10],           // African pentatonic
                [0, 2, 3, 7, 9],            // African-inspired
                [0, 3, 5, 7, 10],           // Minor pentatonic (blues based)
                [0, 2, 5, 7, 9, 12],        // African 6-note pattern
                [0, 2, 4, 7, 9],            // Safari-inspired pentatonic
                [0, 2, 3, 6, 7, 10],        // Saharan desert scale
                [0, 2, 3, 6, 9, 10]         // North African maqam-inspired
            ]
        },
        oceania: {
            // Oceanic and pacific-inspired scales
            harmonicNotes: [
                [261.63, 293.66, 329.63, 392.00, 440.00],     // C Major anhemitonic pentatonic
                [220.00, 246.94, 293.66, 349.23, 392.00],     // Aboriginal-inspired pentatonic
                [261.63, 277.18, 329.63, 392.00, 415.30],     // Polynesian-inspired scale
                [233.08, 261.63, 329.63, 392.00, 440.00],     // Oceanic modal scale
                [246.94, 277.18, 329.63, 369.99, 415.30],     // Island-inspired scale
                [261.63, 293.66, 349.23, 392.00, 440.00, 523.25], // Balinese pelog-inspired
                [277.18, 311.13, 349.23, 392.00, 440.00],     // Micronesian-inspired
                [293.66, 311.13, 349.23, 392.00, 466.16]      // Maori-inspired scale
            ],
            planeNotes: [
                [0, 2, 4, 7, 9],            // Major pentatonic
                [0, 2, 5, 7, 9],            // Pacific pentatonic
                [0, 1, 4, 7, 8],            // Oceanic mode
                [0, 3, 5, 7, 10],           // Indigenous-inspired scale
                [0, 3, 5, 10, 12],          // Polynesian-inspired intervals
                [0, 2, 4, 7, 11],           // Islander mode
                [0, 1, 5, 8, 10],           // Coral reef inspired
                [0, 2, 3, 7, 10]            // Tribal drums inspired
            ]
        },
        americas: {
            // North & South American indigenous and folk scales
            harmonicNotes: [
                [261.63, 293.66, 329.63, 349.23, 392.00],     // C Native American pentatonic approx
                [220.00, 246.94, 261.63, 329.63, 392.00],     // A Minor pentatonic (widespread in American folk)
                [261.63, 293.66, 311.13, 392.00, 440.00],     // Andean-inspired scale
                [246.94, 277.18, 311.13, 349.23, 392.00],     // Amazonian-inspired scale
                [233.08, 261.63, 311.13, 349.23, 415.30],     // Latin American modal scale
                [261.63, 293.66, 329.63, 392.00, 440.00, 493.88], // Bluegrass/Appalachian scale
                [220.00, 246.94, 277.18, 329.63, 369.99],     // Inuit-inspired scale
                [246.94, 277.18, 311.13, 349.23, 415.30]      // Mayan/Aztec inspired scale
            ],
            planeNotes: [
                [0, 3, 5, 7, 10],           // Minor pentatonic (blues/folk)
                [0, 2, 4, 7, 9],            // Major pentatonic
                [0, 2, 3, 7, 9],            // Native American-inspired
                [0, 1, 5, 7, 12],           // Andean-inspired
                [0, 3, 7, 10, 12],          // Latin folk-inspired
                [0, 4, 5, 7, 11],           // Prairie winds scale
                [0, 2, 5, 7, 10, 12],       // Canyon echoes scale
                [0, 1, 3, 5, 8, 10]         // Rainforest scale
            ]
        },
        // Impressionist scales (Satie, Debussy, Ravel inspired)
        impressionist: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 392.00, 440.00, 523.25],  // C Major with no 4th or 7th
                [220.00, 261.63, 329.63, 349.23, 392.00, 440.00],  // A minor 9th voiced openly
                [261.63, 311.13, 349.23, 392.00, 466.16],          // C Lydian pentatonic
                [233.08, 293.66, 349.23, 392.00, 466.16],          // Whole tone scale fragment
                [246.94, 293.66, 329.63, 392.00, 440.00],          // Impressionist fragment
                [261.63, 293.66, 349.23, 415.30, 440.00],          // Modal with augmented 4th
                [261.63, 293.66, 329.63, 392.00, 493.88],          // Extended tertian harmony
                [277.18, 311.13, 369.99, 415.30, 466.16]           // Whole tone scale fragment 2
            ],
            planeNotes: [
                [0, 2, 4, 7, 9, 12],        // Pentatonic with octave
                [0, 2, 5, 7, 11],           // Satie-like voicing
                [0, 4, 6, 10],              // Augmented triad with extension
                [0, 2, 4, 6, 8, 10],        // Whole tone scale
                [0, 2, 3, 7, 9],            // Impressionist mode
                [0, 3, 7, 10, 14],          // Minor 9th (Gymnopédie)
                [0, 2, 5, 9],               // Quartal harmony
                [0, 5, 7, 11]               // Suspended open harmony
            ]
        },
        // Minimalist scales (Reich, Glass, Riley inspired)
        minimalist: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 349.23, 392.00],       // C Phrygian dominant fragment
                [261.63, 293.66, 329.63, 392.00, 440.00],       // Simple diatonic fragment
                [220.00, 261.63, 293.66, 329.63, 349.23],       // Repeating cell
                [261.63, 311.13, 329.63, 349.23, 392.00],       // Additive process
                [293.66, 329.63, 349.23, 392.00, 440.00],       // Shifting cell 1
                [261.63, 293.66, 311.13, 349.23, 392.00],       // Shifting cell 2
                [233.08, 261.63, 293.66, 311.13, 349.23],       // Phase shifting pattern
                [261.63, 293.66, 349.23, 392.00, 440.00]        // Interlocking pattern
            ],
            planeNotes: [
                [0, 2, 4, 5, 7],            // Reich's Piano Phase fragment
                [0, 4, 7, 12],              // Simple repeated chord
                [0, 2, 3, 7],               // Phasing pattern 1
                [0, 2, 7, 9],               // Phasing pattern 2
                [0, 2, 4, 7, 9],            // Glass's "Music in 12 Parts" fragment
                [0, 3, 7, 10],              // Riley's "In C" fragment
                [0, 5, 7, 12],              // Process music element
                [0, 2, 7, 12]               // Additive pattern
            ]
        }
    };

    // Gradient color palettes for each destination (Rothko-inspired)
    const gradientPalettes = {
        worldTour: [
            { top: '#FFE5B4', middle: '#FFB6C1', bottom: '#E6E6FA' }, // Dawn pastels
            { top: '#FF6B9D', middle: '#C44569', bottom: '#5F4B8B' }  // Sunset rich
        ],
        asia: [
            { top: '#FFE5B4', middle: '#FFB6C1', bottom: '#E6E6FA' }, // Cherry blossom dawn
            { top: '#FF6B9D', middle: '#C44569', bottom: '#5F4B8B' }, // Evening crimson
            { top: '#FFB347', middle: '#FFCC99', bottom: '#E6F2FF' }  // Temple gold
        ],
        europe: [
            { top: '#1E3A8A', middle: '#3B82F6', bottom: '#93C5FD' }, // Classic blues
            { top: '#4C1D95', middle: '#7C3AED', bottom: '#A78BFA' }, // Royal twilight
            { top: '#374151', middle: '#6B7280', bottom: '#D1D5DB' }  // Stone cathedral
        ],
        africa: [
            { top: '#C2410C', middle: '#EA580C', bottom: '#FBBF24' }, // Savanna fire
            { top: '#78350F', middle: '#CA8A04', bottom: '#FDE68A' }, // Desert gold
            { top: '#DC2626', middle: '#F59E0B', bottom: '#FCD34D' }  // Sunset heat
        ],
        oceania: [
            { top: '#0E7490', middle: '#06B6D4', bottom: '#A5F3FC' }, // Ocean depths
            { top: '#DB2777', middle: '#EC4899', bottom: '#F9A8D4' }, // Coral reef
            { top: '#065F46', middle: '#10B981', bottom: '#6EE7B7' }  // Tropical lagoon
        ],
        americas: [
            { top: '#1E40AF', middle: '#3B82F6', bottom: '#DBEAFE' }, // Sky blue
            { top: '#7C2D12', middle: '#B45309', bottom: '#FDE68A' }, // Canyon earth
            { top: '#064E3B', middle: '#059669', bottom: '#A7F3D0' }  // Forest green
        ],
        impressionist: [
            { top: '#DDD6FE', middle: '#C4B5FD', bottom: '#A78BFA' }, // Monet water lilies
            { top: '#FECACA', middle: '#FCA5A5', bottom: '#F87171' }, // Renoir soft pink
            { top: '#BAE6FD', middle: '#7DD3FC', bottom: '#38BDF8' }  // Impressionist sky
        ],
        minimalist: [
            { top: '#F3F4F6', middle: '#E5E7EB', bottom: '#D1D5DB' }, // Minimal gray
            { top: '#FEF3C7', middle: '#FDE68A', bottom: '#FCD34D' }, // Warm minimal
            { top: '#DBEAFE', middle: '#BFDBFE', bottom: '#93C5FD' }  // Cool minimal
        ]
    };

    // Artist-inspired scales and settings
    const artistStyles = {
        // Brian Eno - ambient pioneer
        brianeno: {
            harmonicNotes: [
                [261.63, 329.63, 392.00, 493.88],        // Spacious chord voicing
                [246.94, 293.66, 392.00, 493.88],        // Another spacious chord
                [233.08, 293.66, 349.23, 466.16],        // "Thursday Afternoon" inspired
                [261.63, 311.13, 392.00, 466.16],        // "Ambient 1" inspired
                [246.94, 277.18, 349.23, 415.30],        // "Discreet Music" inspired
                [220.00, 277.18, 329.63, 392.00],        // Sustained texture
                [196.00, 261.63, 329.63, 392.00],        // Low register ambient
                [261.63, 293.66, 349.23, 415.30]         // "Neroli" inspired
            ],
            planeNotes: [
                [0, 4, 7, 11, 14],          // Extended ambient voicing
                [0, 2, 7, 9, 14],           // Open ambient voicing
                [0, 4, 7, 12],              // Simple triad with octave
                [0, 5, 7, 12],              // Suspended with octave
                [0, 2, 7, 12],              // Open fifth with octave
                [-7, 0, 4, 7],              // Low root extension
                [0, 4, 11, 16],             // "Music for Airports" voicing
                [0, 2, 7, 16]               // Very open voicing with double octave
            ],
            tempo: 60,                       // Slow BPM
            decay: 8,                        // Long decay
            reverb: 0.6,                     // High reverb
            noteInterval: 4000,              // Long time between notes
            noteColor: "#3498db",            // Light blue
            description: "Ambient Pioneer"
        },
        
        // Erik Satie - French impressionist
        eriksatie: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 392.00, 440.00],      // Gymnopédie No.1 fragment
                [246.94, 293.66, 329.63, 392.00, 415.30],      // Gymnopédie No.2 fragment
                [233.08, 277.18, 329.63, 349.23, 415.30],      // Gymnopédie No.3 fragment
                [261.63, 293.66, 349.23, 392.00, 493.88],      // Gnossiennes fragment
                [220.00, 277.18, 329.63, 392.00, 440.00],      // Je te veux fragment
                [233.08, 293.66, 349.23, 392.00, 466.16],      // Sparse voicing
                [261.63, 329.63, 392.00, 440.00, 523.25],      // Simple diatonic
                [220.00, 261.63, 329.63, 392.00, 440.00]       // Open minor voicing
            ],
            planeNotes: [
                [0, 2, 5, 9, 12],           // Gymnopédie voicing
                [0, 3, 7, 10, 14],          // Minor 9th chord (Satie favorite)
                [0, 4, 7, 9, 14],           // Major 6/9 chord
                [0, 4, 10, 14, 17],         // Dominant 9th with sharp 11th
                [0, 3, 7, 14],              // Minor chord with added 9th
                [0, 2, 7, 10],              // Quartal harmony
                [0, 4, 8, 9],               // Major with augmented 5th and 6th
                [0, 5, 9, 12]               // Suspended 4th with 6th
            ],
            tempo: 55,                      // Very slow BPM
            decay: 7,                       // Long decay
            reverb: 0.4,                    // Medium reverb
            noteInterval: 3500,             // Long time between notes
            noteColor: "#9b59b6",           // Purple
            description: "Impressionist"
        },
        
        // Harold Budd - ambient pianist
        haroldbudd: {
            harmonicNotes: [
                [261.63, 329.63, 349.23, 392.00, 493.88],      // The Pearl fragment
                [246.94, 293.66, 349.23, 392.00, 493.88],      // Reverb-soaked piano
                [220.00, 277.18, 329.63, 392.00, 440.00],      // Simple progression
                [196.00, 261.63, 329.63, 392.00, 466.16],      // Pavilion of Dreams fragment
                [233.08, 293.66, 349.23, 392.00, 466.16],      // Ambient Piano melody
                [220.00, 261.63, 329.63, 349.23, 440.00],      // The White Arcades fragment
                [196.00, 246.94, 293.66, 392.00, 493.88],      // The Room fragment
                [220.00, 277.18, 329.63, 415.30, 493.88]       // By The Dawn's Early Light fragment
            ],
            planeNotes: [
                [0, 4, 5, 7, 12],           // Major with added 4th
                [0, 3, 7, 10, 14],          // Minor 9th chord
                [0, 5, 9, 12, 17],          // Suspended 4th with major 7th
                [0, 2, 6, 9, 16],           // Nondiatonic cluster
                [0, 4, 7, 11, 16],          // Major 7th with octave
                [0, 3, 7, 8, 15],           // Minor 6th with octave
                [0, 4, 6, 9, 12],           // Major with augmented 4th
                [0, 1, 5, 8, 12]            // Cluster with perfect 5th
            ],
            tempo: 50,                      // Very slow BPM
            decay: 8,                       // Very long decay
            reverb: 0.8,                    // High reverb
            noteInterval: 3000,             // Long time between notes
            noteColor: "#3498db",           // Blue
            description: "Reverb-soaked Piano"
        },
        
        // Stars of the Lid - drone
        starsofthelid: {
            harmonicNotes: [
                [130.81, 196.00, 261.63, 329.63],       // Low drone chord
                [146.83, 220.00, 261.63, 329.63],       // Another drone chord
                [164.81, 196.00, 261.63, 329.63],       // Shifting slow chord
                [174.61, 220.00, 261.63, 349.23],       // Droning F major
                [130.81,174.61, 220.00, 261.63, 349.23],       // Droning F major
                [130.81, 174.61, 261.63, 349.23],       // Open voicing
                [146.83, 196.00, 246.94, 349.23],       // Tired Sounds fragment
                [138.59, 185.00, 246.94, 329.63],       // And Their Refinement fragment
                [155.56, 196.00, 246.94, 293.66]        // Refinement of the Decline fragment
            ],
            planeNotes: [
                [-12, -5, 0, 7],            // Very low extension
                [-12, -8, 0, 4],            // Minor low voicing
                [-12, -7, 0, 7],            // Perfect 5th with low octave
                [-12, -5, 0, 5],            // Perfect 4th with low octave
                [-12, -9, -5, 0],           // Stacked 4ths down
                [-12, -7, -3, 0],           // Minor chord inverted
                [-12, -8, -5, 0],           // Cluster in low register
                [-7, -3, 0, 4]              // Drone-like cluster
            ],
            tempo: 40,                      // Extremely slow BPM
            decay: 10,                      // Maximum decay
            reverb: 0.9,                    // Maximum reverb
            noteInterval: 5000,             // Very long time between notes
            noteColor: "#2c3e50",           // Dark blue
            description: "Orchestral Drones"
        },
        
        // Boards of Canada - nostalgic synths
        boardsofcanada: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 392.00, 440.00],      // Music Has The Right fragment
                [246.94, 277.18, 329.63, 392.00, 440.00],      // Geogaddi fragment
                [233.08, 261.63, 329.63, 349.23, 392.00],      // Campfire Headphase fragment
                [220.00, 246.94, 293.66, 349.23, 415.30],      // Tomorrow's Harvest fragment
                [196.00, 233.08, 277.18, 349.23, 392.00],      // Slightly detuned melody
                [185.00, 220.00, 261.63, 329.63, 369.99],      // Nostalgic synth tones
                [207.65, 233.08, 277.18, 329.63, 415.30],      // Warped tape sound
                [220.00, 246.94, 277.18, 329.63, 392.00]       // Degraded sample
            ],
            planeNotes: [
                [0, 2, 4, 7, 9],            // Major pentatonic
                [0, 3, 5, 7, 10],           // Minor pentatonic
                [0, 4, 7, 10, 14],          // Major 7th with 6th
                [0, 3, 7, 10, 14],          // Minor 9th
                [0, 1, 4, 7, 10],           // Detuned minor 7th
                [0, 2, 7, 9, 15],           // Ambient loop fragment
                [0, 3, 6, 10, 15],          // Half-diminished with octave
                [0, 4, 7, 11, 18]           // Extended maj7 voicing
            ],
            tempo: 70,                      // Medium-slow BPM
            decay: 6,                       // Medium-long decay
            reverb: 0.5,                    // Medium reverb
            noteInterval: 2000,             // Medium time between notes
            noteColor: "#f39c12",           // Orange/amber
            description: "Nostalgic Synths"
        },
        
       // William Basinski - decaying loops
       williambasinski: {
            harmonicNotes: [
                [220.00, 261.63, 293.66, 349.23],      // Disintegration Loop 1.1 fragment
                [196.00, 233.08, 277.18, 329.63],      // Disintegration Loop 2.1 fragment
                [174.61, 220.00, 261.63, 311.13],      // Melancholia fragment 
                [164.81, 196.00, 246.94, 293.66],      // The River fragment
                [146.83, 185.00, 220.00, 277.18],      // Watermusic fragment
                [130.81, 174.61, 207.65, 261.63],      // Variations for Piano fragment
                [123.47, 164.81, 196.00, 246.94],      // A Shadow in Time fragment
                [138.59, 174.61, 220.00, 261.63]       // 92982 fragment
            ],
            planeNotes: [
                [0, 3, 7, 12],              // Simple minor with octave
                [-12, -5, 0, 7],            // Low extension with fifth
                [-7, 0, 4, 7],              // Low extension with major
                [-12, -8, -3, 0],           // Descending minor
                [-7, -3, 0, 4],             // Close position minor
                [-5, 0, 4, 7],              // Close position major
                [-12, -7, -3, 0],           // Low register minor
                [-12, -9, -5, 0]            // Descending fourths
            ],
            tempo: 45,                      // Very slow BPM
            decay: 9,                       // Very long decay 
            reverb: 0.85,                   // High reverb
            noteInterval: 5500,             // Very long time between notes
            noteColor: "#7f8c8d",           // Grey/muted
            description: "Decaying Loops"
        },
        
        // Steve Reich - minimalist phasing
        stevereich: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 349.23, 392.00],      // Piano Phase fragment
                [293.66, 329.63, 349.23, 392.00, 440.00],      // Different Trains fragment
                [220.00, 261.63, 293.66, 329.63, 349.23],      // Music for 18 Musicians fragment
                [246.94, 293.66, 329.63, 349.23, 392.00],      // Six Pianos fragment
                [233.08, 261.63, 293.66, 329.63, 392.00],      // Drumming fragment
                [261.63, 293.66, 311.13, 349.23, 392.00],      // Clapping Music fragment
                [277.18, 329.63, 349.23, 392.00, 440.00],      // Electric Counterpoint fragment
                [246.94, 261.63, 293.66, 329.63, 369.99]       // Music for Mallet Instruments fragment
            ],
            planeNotes: [
                [0, 2, 4, 5, 7],            // Reich's Piano Phase fragment
                [0, 4, 7, 11, 12],          // Electric Counterpoint fragment
                [0, 2, 3, 7, 9],            // Phasing pattern 1
                [0, 2, 4, 7, 9],            // Phasing pattern 2
                [0, 1, 4, 5, 7],            // Six Marimbas fragment
                [0, 3, 5, 9, 11],           // Tehillim fragment
                [0, 2, 5, 7, 9],            // Different Trains fragment
                [0, 3, 5, 7, 10]            // Desert Music fragment
            ],
            tempo: 105,                     // Medium-fast BPM
            decay: 3,                       // Short decay
            reverb: 0.25,                   // Low reverb
            noteInterval: 800,              // Short time between notes
            noteColor: "#e74c3c",           // Red
            description: "Phasing Patterns"
        },
        
        // Tim Hecker - digital textures
        timhecker: {
            harmonicNotes: [
                [130.81, 196.00, 261.63, 311.13, 369.99],      // Ravedeath fragment
                [146.83, 174.61, 233.08, 293.66, 349.23],      // Virgins fragment
                [123.47, 164.81, 207.65, 277.18, 329.63],      // Harmony in Ultraviolet fragment
                [138.59, 185.00, 246.94, 293.66, 369.99],      // Radio Amor fragment
                [110.00, 146.83, 196.00, 246.94, 311.13],      // Haunt Me fragment
                [130.81, 174.61, 220.00, 261.63, 329.63],      // Konoyo fragment
                [116.54, 155.56, 196.00, 233.08, 293.66],      // Anoyo fragment
                [146.83, 185.00, 220.00, 277.18, 349.23]       // Love Streams fragment
            ],
            planeNotes: [
                [-12, -5, 0, 4, 8],         // Extended cluster in low register
                [-12, -8, -5, 0, 4],        // Dense voicing 
                [-12, -7, -3, 0, 5],        // Dissonant voicing
                [-12, -9, -2, 0, 4],        // Complex cluster
                [-24, -12, -5, 0, 7],       // Very low extension
                [-12, -8, -1, 0, 3],        // Noise-like cluster
                [-12, -7, -2, 0, 7],        // Distorted harmony
                [-7, -3, 0, 4, 7]           // Compressed harmony
            ],
            tempo: 65,                      // Medium-slow BPM
            decay: 7,                       // Long decay
            reverb: 0.7,                    // High reverb
            noteInterval: 2500,             // Medium-long time between notes
            noteColor: "#8e44ad",           // Purple
            description: "Digital Textures"
        },
        
        // Ryuichi Sakamoto - minimal piano
        ryuichisakamoto: {
            harmonicNotes: [
                [261.63, 293.66, 349.23, 392.00, 440.00],      // Async fragment 
                [246.94, 293.66, 349.23, 392.00, 493.88],      // BTTB fragment
                [220.00, 277.18, 329.63, 392.00, 440.00],      // 1996 fragment
                [196.00, 246.94, 293.66, 349.23, 392.00],      // Neo Geo fragment
                [233.08, 261.63, 329.63, 392.00, 493.88],      // Merry Christmas Mr. Lawrence fragment
                [220.00, 261.63, 311.13, 392.00, 466.16],      // The Revenant fragment
                [246.94, 293.66, 329.63, 392.00, 440.00],      // Playing the Piano fragment
                [233.08, 277.18, 349.23, 392.00, 466.16]       // Solitude fragment
            ],
            planeNotes: [
                [0, 2, 5, 7, 9],            // Sakamoto pentatonic
                [0, 4, 7, 11, 14],          // Major 9th
                [0, 3, 7, 10, 14],          // Minor 9th
                [0, 4, 7, 12, 16],          // Major with double octave
                [0, 5, 7, 12, 17],          // Suspended with major 7th
                [0, 4, 7, 9, 11],           // Major 6th with added 7th
                [0, 2, 5, 9, 12],           // Japanese-influenced scale
                [0, 3, 7, 12, 15]           // Minor with octave and 10th
            ],
            tempo: 60,                      // Slow BPM
            decay: 6,                       // Medium-long decay
            reverb: 0.5,                    // Medium reverb
            noteInterval: 2200,             // Medium time between notes
            noteColor: "#16a085",           // Teal
            description: "Minimal Piano"
        },
        
        // Aphex Twin - selected ambient works
        aphextwin: {
            harmonicNotes: [
                [246.94, 277.18, 349.23, 392.00, 440.00],      // SAW 85-92 fragment
                [220.00, 261.63, 329.63, 392.00, 493.88],      // SAW Vol 2 fragment
                [196.00, 233.08, 293.66, 349.23, 466.16],      // Drukqs ambient fragment
                [174.61, 220.00, 277.18, 329.63, 415.30],      // Syro ambient fragment
                [261.63, 311.13, 349.23, 392.00, 466.16],      // Analogue Bubblebath fragment
                [233.08, 261.63, 311.13, 349.23, 440.00],      // Melodies From Mars fragment
                [246.94, 293.66, 349.23, 415.30, 493.88],      // Cheetah EP fragment
                [220.00, 261.63, 293.66, 349.23, 415.30]       // Collapse EP fragment
            ],
            planeNotes: [
                [0, 2, 7, 9, 12],           // Pentatonic with octave
                [0, 4, 7, 11, 16],          // Major 7th with 9th 
                [0, 3, 7, 10, 14],          // Minor 9th
                [0, 1, 5, 8, 12],           // Cluster with octave
                [0, 5, 7, 12, 17],          // Perfect 5th and suspensions
                [0, 4, 6, 10, 13],          // Lydian-influenced scale
                [0, 3, 7, 8, 15],           // Minor 6th with octave
                [0, 2, 4, 7, 11]            // Major 7th with 9th
            ],
            tempo: 85,                      // Medium BPM
            decay: 5,                       // Medium decay
            reverb: 0.4,                    // Medium reverb
            noteInterval: 1800,             // Medium time between notes
            noteColor: "#e74c3c",           // Red
            description: "Selected Ambient"
        },
        
        // Jon Hopkins - electronic ambient
        jonhopkins: {
            harmonicNotes: [
                [261.63, 329.63, 392.00, 440.00, 523.25],      // Immunity fragment
                [246.94, 293.66, 369.99, 440.00, 493.88],      // Singularity fragment
                [233.08, 277.18, 349.23, 415.30, 466.16],      // Opalescent fragment
                [220.00, 277.18, 329.63, 392.00, 466.16],      // Insides fragment
                [196.00, 261.63, 329.63, 392.00, 440.00],      // Asleep Versions fragment
                [220.00, 261.63, 329.63, 392.00, 493.88],      // Light Through The Veins fragment
                [246.94, 293.66, 349.23, 415.30, 523.25],      // Music For Psychedelic Therapy fragment
                [261.63, 293.66, 349.23, 440.00, 523.25]       // Piano Versions fragment
            ],
            planeNotes: [
                [0, 5, 9, 12, 17],          // Suspended with major 7th
                [0, 4, 7, 11, 16],          // Major 9th
                [0, 3, 7, 10, 14],          // Minor 9th
                [0, 2, 7, 11, 14],          // Quintal harmony with extensions
                [0, 4, 7, 9, 14],           // 6/9 chord
                [0, 5, 7, 12, 16],          // Suspended 4th with major 9th
                [0, 3, 7, 12, 15],          // Minor with octave and 10th
                [0, 2, 5, 9, 14]            // Cluster with wide intervals
            ],
            tempo: 90,                      // Medium-fast BPM
            decay: 5,                       // Medium decay
            reverb: 0.6,                    // Medium-high reverb
            noteInterval: 1500,             // Short-medium time between notes
            noteColor: "#3498db",           // Blue
            description: "Electronic Ambient"
        },
        
        // Various Artists - mixed inspiration (default)
        various: {
            harmonicNotes: [
                // Mix of scales from all artists
                [261.63, 329.63, 392.00, 493.88],              // Eno-inspired
                [246.94, 293.66, 329.63, 392.00, 415.30],      // Satie-inspired
                [220.00, 277.18, 329.63, 392.00, 440.00],      // Budd-inspired
                [130.81, 196.00, 261.63, 329.63],              // Stars of the Lid-inspired
                [261.63, 293.66, 329.63, 392.00, 440.00],      // Boards of Canada-inspired
                [196.00, 246.94, 293.66, 349.23, 392.00],      // Sakamoto-inspired
                [261.63, 293.66, 329.63, 349.23, 392.00],      // Reich-inspired
                [246.94, 293.66, 369.99, 440.00, 493.88]       // Hopkins-inspired
            ],
            planeNotes: [
                // Mix of intervals from all artists
                [0, 4, 7, 12],              // Major triad with octave
                [0, 3, 7, 10, 14],          // Minor 9th (Satie favorite)
                [0, 5, 9, 12, 17],          // Suspended with major 7th (Budd)
                [-12, -5, 0, 7],            // Very low extension (Stars of the Lid)
                [0, 2, 4, 7, 9],            // Major pentatonic (Boards of Canada)
                [0, 2, 5, 7, 9],            // Sakamoto pentatonic
                [0, 2, 4, 5, 7],            // Reich's Piano Phase fragment
                [0, 4, 7, 11, 16]           // Major 9th (Hopkins)
            ],
            tempo: 70,                      // Medium BPM
            decay: 5,                       // Medium decay
            reverb: 0.5,                    // Medium reverb
            noteInterval: 2500,             // Medium time between notes
            noteColor: "#2ecc71",           // Green
            description: "Mixed Inspiration"
        }
    };
    
    // Current active scales
    let harmonicNotes = musicalScales.worldTour.harmonicNotes;
    let planeNotes = musicalScales.worldTour.planeNotes;

    // Enhanced terrain types
    const terrainTypes = [
        // Natural landscapes
        "mountain ranges", "coastal regions", "desert landscapes", "forest canopies", "glacial fields",
        "river valleys", "tropical rainforests", "vast savannas", "arctic tundra", "volcanic regions",
        "dense jungles", "rolling hills", "majestic canyons", "expansive plateaus", "serene lakeshores",
        "scenic fjords", "rugged badlands", "misty marshlands", "lush wetlands", "ancient redwood forests",
        
        // Water bodies
        "coral reefs", "deep ocean waters", "island archipelagos", "misty lakes", "winding rivers",
        "azure lagoons", "pristine coastlines", "tidal estuaries", "tranquil bays", "secluded inlets",
        "turquoise shoals", "meandering deltas", "crystalline streams", "boundless oceans", "shimmering seas",
        
        // Weather phenomena
        "thunderstorm systems", "foggy valleys", "clear skies", "aurora displays", "sunset gradients",
        "monsoon clouds", "morning mists", "evening hazes", "passing showers", "gathering storm fronts",
        "sun-dappled clearings", "rainbow arches", "cumulus formations", "starlit horizons", "moonlit panoramas",
        
        // Regional specific
        "alpine meadows", "bamboo forests", "terraced fields", "ancient valleys", "pristine beaches",
        "rugged highlands", "remote plateaus", "flowering meadows", "pine forests", "autumn woodlands",
        "cherry blossom groves", "olive orchards", "lavender fields", "rice paddies", "desert oases",
        "mangrove swamps", "eucalyptus woods", "palm-lined shores", "snow-capped summits", "mossy glens"
    ];
    
    // View descriptions
    const viewTypes = [
        "golden sunset", "cloud formations", "mountain ranges", "ocean vistas", "city lights",
        "morning mist", "starlit horizon", "aurora borealis", "desert mirage", "rolling hills",
        "snow-capped peaks", "tropical islands", "canyon depths", "forest canopy", "coastal shores",
        "twilight shadows", "crystalline lakes", "lush valleys", "autumn foliage", "spring blossoms",
        "emerald fjords", "coral gardens", "volcanic craters", "windswept prairies", "arctic icescapes",
        "ancient ruins", "cascading waterfalls", "winding riverbeds", "jagged cliffs", "sapphire seas",
        "crimson sunrises", "monsoon clouds", "terraced landscapes", "midnight blues", "gilded horizons",
        "towering redwoods", "meandering coastlines", "bamboo thickets", "shimmering mirages", "moonlit peaks"
    ];
    
    // Weather descriptions
    const weatherTypes = [
        "calm", "clear", "slightly turbulent", "calm", "clear", "slightly turbulent", "overcast", "partly cloudy",
        "misty", "breezy", "tranquil", "serene", "mild",
        "stable", "gentle", "favorable", "pleasant", "harmonious",
        "smooth", "bright", "glowing", "subtle", "refreshing",
        "crisp", "balmy", "temperate", "placid", "radiant",
        "moderate", "fair", "steady", "consistent", "agreeable",
        "peaceful", "luminous", "mild", "soothing", "benign",
        "pristine", "idyllic", "delightful", "invigorating", "splendid"
    ];
    
    // Atmosphere descriptions
    const atmosphereTypes = [
        "smooth", "turbulent", "cool", "warm", "high pressure",
        "gentle", "refreshing", "dense", "thin", "clear",
        "serene", "placid", "crisp", "enveloping", "textured",
        "harmonious", "flowing", "balanced", "resonant", "tranquil",
        "buoyant", "dynamic", "crystalline", "rarefied", "stratified",
        "ethereal", "layered", "vibrant", "translucent", "pristine",
        "meditative", "contemplative", "shimmering", "breathable", "revitalizing",
        "luminous", "ambient", "undulating", "suspended", "delicate"
    ];
    
    // Obstacle types
    const obstacleTypes = [
        "storm clouds", "air traffic", "weather systems", "high altitude turbulence",
        "thermal layers", "pressure gradients", "wind currents", "atmospheric disturbances",
        "dense cloud banks", "shifting weather fronts", "temperature inversions",
        "migration patterns", "dynamic air masses", "moisture pockets", "thermal updrafts",
        "jetstream flows", "convection cells", "condensation zones", "cyclonic patterns",
        "stratospheric waves", "cumulus buildups", "convergence zones", "shear boundaries",
        "electrical storms", "radiation belts", "solar wind effects", "mesospheric ripples",
        "aurora curtains", "cosmic radiation", "meteorological anomalies", "dust clouds",
        "navigation beacons", "communication signals", "satellite trajectories", "ionospheric fluctuations"
    ];
    
    // Flight announcements templates with Oblique Strategies influences
    const announcements = [
        "Ladies and gentlemen, we're currently flying at {altitude} feet above sea level. Outside temperature is {temp}°C.",
        "This is your flight attendant speaking. We're experiencing some {turbulence} turbulence as we fly over {terrain}.",
        "Cabin crew, prepare for {phase}. We expect to reach our cruising altitude shortly.",
        "Passengers, please note the beautiful {view} you can see below us as we pass over {terrain}.",
        "We're currently experiencing a slight {change} in our flight path to navigate around {obstacle}.",
        "This is your captain speaking. We're expecting {weather} conditions for the remainder of our journey.",
        "Ladies and gentlemen, we're beginning our {phase} phase. Please remain seated with your seatbelts fastened.",
        "We're pleased to inform you that we're making excellent {progress} and expect to arrive on schedule.",
        "Cabin crew, prepare the cabin for {phase}. We'll be reaching our destination in approximately {time} minutes.",
        "This is your co-pilot speaking. We're currently flying through a {atmosphere} air current at {altitude} feet.",
        // Oblique Strategies inspired announcements
        "Ladies and gentlemen, we invite you to honor your errors as hidden intentions as we fly over {terrain} at {altitude} feet.",
        "This is your captain speaking. We've discovered a new perspective at {altitude} feet, where we can observe {terrain} from an entirely different angle.",
        "Cabin announcement: We're taking a moment to appreciate the edges of this {atmosphere} atmosphere as we cross into {terrain}.",
        "Passengers, as we travel at {altitude} feet, remember that repetition is a form of change. We'll be flying over {terrain} for the next {time} minutes.",
        "This is your flight crew inviting you to look at the {view} from a different perspective as we consider the quiet needs of our journey over {terrain}.",
        "Ladies and gentlemen, as we traverse these {terrain}, consider how different this landscape would be if approached from another direction.",
        "Cabin announcement: We're embracing the quality of simplicity as we navigate through this {atmosphere} atmosphere at {altitude} feet.",
        "This is your captain speaking. Rather than solving the problem of altitude adjustments, we're changing the problem as we approach these {obstacle}.",
        "Passengers, as we observe the {view} below, remember that not all places need to be filled with something - the beauty sometimes lies in the spaces between.",
        "This is your captain inviting you to consider the remarkable {terrain} below as a landscape of pure possibility and transformation.",
        "Ladies and gentlemen, consider this flight as a metaphor—we are moving through {atmosphere} conditions while being perfectly still within our vessel.",
        "Cabin crew has noted that the {weather} conditions outside create a perfect balance of opposites as we pass over {terrain}.",
        "This is your co-pilot speaking. We invite you to trust in the increasing simplicity of this journey as we follow invisible currents over {terrain}.",
        "Passengers, we're currently experiencing what we might call 'the most easily forgotten thing' as we witness this {view} from {altitude} feet.",
        "Your flight attendants suggest taking a moment to look away from the {view} and then look back, to see it with fresh eyes as we continue our journey.",
        "Ladies and gentlemen, we are deliberately flying through this {atmosphere} atmosphere to remind ourselves of the value of the overlooked."
    ];
    
    // Artist-specific announcements
    const artistAnnouncements = {
        // Brian Eno announcements
        brianeno: [
            "Ladies and gentlemen, we're creating an ambient environment at {altitude} feet as we fly over {terrain}.",
            "This is your captain speaking. We're entering a space where process takes precedence over product.",
            "Cabin announcement: As we fly over {terrain}, remember that ambient music must be as ignorable as it is interesting.",
            "Passengers, we're now following one of the Oblique Strategies: '{view} over {terrain}'.",
            "We invite you to appreciate how the landscape below provides us with discreet music at {altitude} feet.",
            "This is your co-pilot speaking. We're currently in a space between melody and texture, flying through {atmosphere} air currents."
        ],
        
        // Erik Satie announcements
        eriksatie: [
            "Ladies and gentlemen, we've entered what Satie would call 'furniture music' as we drift over {terrain}.",
            "This is your captain speaking. We're approaching Gymnopédie airspace at {altitude} feet.",
            "Cabin announcement: Please note the beautiful {view} below, inspiring our slow, atmospheric descent.",
            "Passengers, prepare for a gentle entrance of the Gnossiennes as we navigate around {obstacle}.",
            "We're experiencing what Satie called a 'necessary pause' as we fly through {atmosphere} conditions above {terrain}.",
            "This is your co-pilot speaking. We're maintaining a gentle tempo of {time} beats per minute above the {terrain}."
        ],
        
        // Harold Budd announcements
        haroldbudd: [
            "Ladies and gentlemen, we're floating through reverb-soaked atmosphere at {altitude} feet above {terrain}.",
            "This is your captain speaking. We're encountering sustained piano tones as we pass over {terrain}.",
            "Cabin announcement: The {view} below is reflected in our soft pedal navigation through {atmosphere} air.",
            "Passengers, note how the reverb extends our flight path as we navigate around {obstacle}.",
            "We're experiencing the spacious echoes of our journey over {terrain}, continuing for the next {time} minutes.",
            "This is your co-pilot speaking. We're in a state of suspended motion over {terrain}, drifting like sustained piano notes."
        ]
    };
    
    // Helper function to adjust opacity of a color
    function adjustOpacity(color, opacity) {
        if (color.startsWith('rgba')) {
            const parts = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/);
            if (parts) {
                return `rgba(${parts[1]}, ${parts[2]}, ${parts[3]}, ${opacity})`;
            }
        } else if (color.startsWith('#')) {
            // Convert hex to rgba
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }
        return color;
    }
    
    // Welcome overlay functions
    // Make hideWelcomeOverlay globally accessible for debugging
    window.hideWelcomeOverlay = function hideWelcomeOverlay() {
        logInfo('UI', '═══════════════════════════════════');
        logInfo('UI', 'WELCOME OVERLAY - Hide requested');
        logInfo('UI', '═══════════════════════════════════');

        const welcomeOverlay = document.getElementById('welcomeOverlay');
        if (!welcomeOverlay) {
            logError('UI', 'Welcome overlay element not found in DOM');
            return;
        }

        logDebug('UI', 'Welcome overlay element found, adding hidden class');
        welcomeOverlay.classList.add('hidden');

        setTimeout(() => {
            welcomeOverlay.style.display = 'none';
            logDebug('UI', 'Welcome overlay display set to none');
        }, 500);

        // Initialize audio when welcome is dismissed
        if (!audioContext || audioContext.state === 'closed') {
            logInfo('AUDIO', 'Audio context not initialized, initializing now');
            initializeAudio();
        } else {
            logDebug('AUDIO', 'Audio context already initialized', {
                state: audioContext.state
            });
        }

        showStatus('Welcome aboard! Ready for takeoff.');
        logInfo('UI', 'Welcome overlay hidden successfully');
    };

    function showWelcomeOverlay() {
        const welcomeOverlay = document.getElementById('welcomeOverlay');
        if (welcomeOverlay) {
            welcomeOverlay.style.display = 'flex';
            setTimeout(() => {
                welcomeOverlay.classList.remove('hidden');
            }, 10);
        }
    }

    // Help overlay functions
    function showHelpOverlay() {
        if (helpOverlay) {
            helpOverlay.classList.remove('hidden');
        }
    }

    function hideHelpOverlay() {
        if (helpOverlay) {
            helpOverlay.classList.add('hidden');
        }
    }

    function toggleHelpOverlay() {
        if (helpOverlay) {
            if (helpOverlay.classList.contains('hidden')) {
                showHelpOverlay();
            } else {
                hideHelpOverlay();
            }
        }
    }

    // Initialize the application
    function init() {
        logInfo('SYSTEM', '═══════════════════════════════════════════════');
        logInfo('SYSTEM', 'APPLICATION INITIALIZATION STARTED');
        logInfo('SYSTEM', '═══════════════════════════════════════════════');

        startTimer('app_initialization');

        try {
            // Load user settings
            logDebug('SYSTEM', 'Loading user settings');
            loadSettings();

            // Set up canvas to ensure proper sizing
            logDebug('SYSTEM', 'Initializing canvases');
            resetAllCanvases();

            // Set up event listeners
            logDebug('SYSTEM', 'Setting up event listeners');
            setupEventListeners();

            // Show cockpit expanded by default so Take Off button is visible
            cockpitContainer.classList.remove('collapsed');
            logDebug('UI', 'Cockpit container expanded by default');

            // Update UI with default values
            logDebug('UI', 'Updating UI state');
            updateUIState();

            // Initially hide plane
            plane.style.display = 'none';
            logDebug('UI', 'Plane element hidden');

            // Set initial UI state for effect panels
            document.getElementById('filterControlsPanel').style.display = 'none';
            document.getElementById('compressorControlsPanel').style.display = 'none';
            logDebug('UI', 'Effect panels hidden');

            // Initially disable land button
            if (landButton) {
                landButton.disabled = true;
                logDebug('UI', 'Land button disabled');
            }

            // Show welcome message
            showStatus('Welcome aboard! Click "Take Off" to begin your musical journey.');

            const duration = endTimer('app_initialization');
            logInfo('SYSTEM', `✓ Application initialized in ${duration}ms`);
            logInfo('SYSTEM', '═══════════════════════════════════════════════');

        } catch (error) {
            logError('SYSTEM', 'Application initialization failed', error);
            endTimer('app_initialization');
            throw error;
        }
    }
    
    // Load user settings from localStorage
    function loadSettings() {
        if (localStorage.getItem('musicAirplaneSettings')) {
            try {
                const settings = JSON.parse(localStorage.getItem('musicAirplaneSettings'));
                
                // Apply dark mode if saved
                if (settings.darkMode) {
                    document.body.classList.add('dark-mode');
                    darkModeToggle.checked = true;
                }
                
                // Load safety settings
                if (settings.safeLowFreq) {
                    safeLowFreq = settings.safeLowFreq;
                    safeLowFreqControl.value = safeLowFreq;
                    document.getElementById('safeLowFreqValue').textContent = safeLowFreq + ' Hz';
                }
                
                if (settings.limiterThreshold) {
                    limiterThreshold = settings.limiterThreshold;
                    limiterThresholdControl.value = limiterThreshold;
                    document.getElementById('limiterThresholdValue').textContent = limiterThreshold + ' dB';
                }
                
                console.log('Settings loaded:', settings);
            } catch (e) {
                console.error('Error loading settings:', e);
            }
        }
    }
    
    // Save user settings to localStorage
    function saveSettings() {
        const settings = {
            darkMode: darkModeToggle.checked,
            safeLowFreq: parseInt(safeLowFreqControl.value),
            limiterThreshold: parseFloat(limiterThresholdControl.value)
        };
        
        localStorage.setItem('musicAirplaneSettings', JSON.stringify(settings));
        console.log('Settings saved:', settings);
        
        // Apply the settings immediately
        if (darkModeToggle.checked) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }
        
        safeLowFreq = parseInt(safeLowFreqControl.value);
        limiterThreshold = parseFloat(limiterThresholdControl.value);
        
        // Update audio nodes if they exist
        updateAudioSafetySettings();
        
        // Hide the settings panel
        settingsPanel.style.display = 'none';
        
        // Show a confirmation message
        showStatus('Settings saved successfully');
    }
    
    // Setup event listeners
    function setupEventListeners() {
        logDebug('SYSTEM', 'Setting up event listeners');

        // Cockpit toggle
        cockpitToggle.addEventListener('click', () => {
            logDebug('INPUT', 'Cockpit toggle clicked');
            toggleCockpit();
        });

        // Basic flight controls
        takeoffButton.addEventListener('click', () => {
            logDebug('INPUT', 'Take Off button clicked');
            window.takeOff();
        });

        landButton.addEventListener('click', () => {
            logDebug('INPUT', 'Land button clicked');
            window.land();
        });

        if (testAudioButton) {
            testAudioButton.addEventListener('click', () => {
                logDebug('INPUT', 'Test Audio button clicked');
                window.testAudio();
            });
        }

        fullscreenBtn.addEventListener('click', () => {
            logDebug('INPUT', 'Fullscreen button clicked');
            toggleFullScreen();
        });

        randomizeAllButton.addEventListener('click', () => {
            logDebug('INPUT', 'Randomize All button clicked');
            randomizeAll();
        });

        toggleUIButton.addEventListener('click', () => {
            logDebug('INPUT', 'Toggle UI button clicked');
            toggleUI();
        });

        clearTrailButton.addEventListener('click', () => {
            logDebug('INPUT', 'Clear Trail button clicked');
            clearTrail();
        });

        flightLogBtn.addEventListener('click', () => {
            logDebug('INPUT', 'Flight Log button clicked');
            showFlightLog();
        });
        
        // Flight control sliders
        altitudeControl.addEventListener('input', updateAltitude);
        tempoControl.addEventListener('input', updateTempo);
        persistenceControl.addEventListener('input', updatePersistence);
        trailIntensityControl.addEventListener('input', updateTrailIntensity);
        
        // Audio control sliders
        volumeControl.addEventListener('input', updateVolume);
        reverbControl.addEventListener('input', updateReverb);
        decayControl.addEventListener('input', updateDecay);
        bassLevelControl.addEventListener('input', updateBassLevel);
        
        // Effect toggles
        filterToggle.addEventListener('change', toggleFilter);
        lfoToggle.addEventListener('change', toggleLFO);
        compressorToggle.addEventListener('change', toggleCompressor);
        engineToggle.addEventListener('change', toggleEngine);
        windToggle.addEventListener('change', toggleWind);
        altitudeFilterToggle.addEventListener('change', toggleAltitudeFilter);
        rainToggle.addEventListener('change', toggleRain);
        thunderToggle.addEventListener('change', toggleThunder);
        musicalParticlesToggle.addEventListener('change', toggleMusicalParticles);

        // Musical particles controls
        particleAttackControl.addEventListener('input', function() {
            particleAttack = parseFloat(this.value);
            document.getElementById('particleAttackValue').textContent = particleAttack.toFixed(2) + 's';
        });

        particleReleaseControl.addEventListener('input', function() {
            particleRelease = parseFloat(this.value);
            document.getElementById('particleReleaseValue').textContent = particleRelease.toFixed(1) + 's';
        });

        particleGravityControl.addEventListener('input', function() {
            particleGravity = parseFloat(this.value);
            document.getElementById('particleGravityValue').textContent = particleGravity.toFixed(1);
        });

        particleDensityControl.addEventListener('input', function() {
            particleDensity = parseFloat(this.value);
            document.getElementById('particleDensityValue').textContent = Math.floor(particleDensity * 100) + '%';
        });

        // Filter controls
        filterCutoffControl.addEventListener('input', updateFilterCutoff);
        lfoRateControl.addEventListener('input', updateLfoRate);
        lfoAmountControl.addEventListener('input', updateLfoAmount);
        
        // Compressor controls
        compThresholdControl.addEventListener('input', updateCompressorThreshold);
        compRatioControl.addEventListener('input', updateCompressorRatio);
        compAttackControl.addEventListener('input', updateCompressorAttack);
        compReleaseControl.addEventListener('input', updateCompressorRelease);
        
        // Preset selectors
        filterPresetsSelect.addEventListener('change', applyFilterPreset);
        compressorPresetsSelect.addEventListener('change', applyCompressorPreset);
        
        // Artist selector
        artistSelector.addEventListener('change', function() {
            selectArtist(this.value);
        });
        
        // Destination buttons
        destinationButtons.forEach(button => {
            button.addEventListener('click', function() {
                const destId = this.id.replace('dest', '').toLowerCase();
                changeDestination(destId);
            });
        });
        
        // Settings panel
        settingsButton.addEventListener('click', openSettings);
        saveSettingsBtn.addEventListener('click', saveSettings);
        closeSettingsBtn.addEventListener('click', closeSettings);

        // Help overlay
        helpButton.addEventListener('click', showHelpOverlay);
        helpCloseBtn.addEventListener('click', hideHelpOverlay);
        helpOverlay.addEventListener('click', function(e) {
            if (e.target === helpOverlay) {
                hideHelpOverlay();
            }
        });

        // Dark mode toggle
        darkModeToggle.addEventListener('change', function() {
            if (this.checked) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        });
        
        // Safe low frequency control
        safeLowFreqControl.addEventListener('input', function() {
            const value = parseInt(this.value);
            document.getElementById('safeLowFreqValue').textContent = value + ' Hz';
        });
        
        // Limiter threshold control
        limiterThresholdControl.addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('limiterThresholdValue').textContent = value.toFixed(1) + ' dB';
        });
        
        // Emergency eject button
        emergencyEjectBtn.addEventListener('click', emergencyEject);
        
        // Announcement panel click dismissal
        document.getElementById('announcement').addEventListener('click', fadeOutAnnouncement);
        
        // Window resize handler
        window.addEventListener('resize', function() {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(function() {
                resizeCanvases();
            }, 250);
        });

        // Welcome overlay - attach directly with multiple fallbacks
        const welcomeStartBtn = document.getElementById('welcomeStartBtn');
        const welcomeOverlay = document.getElementById('welcomeOverlay');

        if (welcomeStartBtn) {
            console.log('Welcome button found, attaching listener');

            // Primary click handler
            welcomeStartBtn.addEventListener('click', function(e) {
                console.log('Welcome button clicked!');
                e.preventDefault();
                e.stopPropagation();
                window.hideWelcomeOverlay();
            }, { capture: true });

            // Backup: also listen for any pointer events
            welcomeStartBtn.addEventListener('pointerdown', function(e) {
                console.log('Welcome button pointer down!');
                e.preventDefault();
                e.stopPropagation();
                window.hideWelcomeOverlay();
            });

            // Mobile touch support
            welcomeStartBtn.addEventListener('touchstart', function(e) {
                console.log('Welcome button touched!');
                e.preventDefault();
                e.stopPropagation();
                window.hideWelcomeOverlay();
            }, { passive: false });

            // Make absolutely sure it's clickable
            welcomeStartBtn.style.pointerEvents = 'auto';
            welcomeStartBtn.style.cursor = 'pointer';
            welcomeStartBtn.style.touchAction = 'manipulation';

        } else {
            console.error('Welcome button NOT found!');
        }

        // Also allow clicking the dark background (but not the content) to dismiss it
        if (welcomeOverlay) {
            welcomeOverlay.addEventListener('click', function(e) {
                if (e.target === welcomeOverlay) {
                    console.log('Welcome overlay background clicked, hiding...');
                    hideWelcomeOverlay();
                }
            });
        }

        // Landing destination system
        const destinationCards = document.querySelectorAll('.destination-card');
        destinationCards.forEach(card => {
            card.addEventListener('click', function() {
                // Remove selected class from all cards
                destinationCards.forEach(c => c.classList.remove('selected'));

                // Add selected class to clicked card
                this.classList.add('selected');

                // Get the space key
                const spaceKey = this.getAttribute('data-space');

                // Complete landing at this destination
                completeLanding(spaceKey);
            });
        });

        // Cancel landing button
        const cancelLandingBtn = document.getElementById('cancelLandingBtn');
        if (cancelLandingBtn) {
            cancelLandingBtn.addEventListener('click', hideLandingSelector);
        }

        // Atmosphere selectors
        const timeSelect = document.getElementById('timeSelect');
        if (timeSelect) {
            timeSelect.addEventListener('change', function() {
                currentTime = this.value;
            });
        }

        const weatherSelect = document.getElementById('weatherSelect');
        if (weatherSelect) {
            weatherSelect.addEventListener('change', function() {
                currentWeather = this.value;
            });
        }

        const seasonSelect = document.getElementById('seasonSelect');
        if (seasonSelect) {
            seasonSelect.addEventListener('change', function() {
                currentSeason = this.value;
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Prevent shortcuts when typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    if (isFlying) {
                        window.land();
                    } else {
                        window.takeOff();
                    }
                    break;
                case 'c':
                    e.preventDefault();
                    toggleCockpit();
                    break;
                case 'u':
                    e.preventDefault();
                    toggleUI();
                    break;
                case 'f':
                    e.preventDefault();
                    toggleFullScreen();
                    break;
                case 'r':
                    e.preventDefault();
                    randomizeAll();
                    break;
                case 't':
                    e.preventDefault();
                    clearTrail();
                    break;
                case 'l':
                    e.preventDefault();
                    showFlightLog();
                    break;
                case 'h':
                    e.preventDefault();
                    toggleHelpOverlay();
                    break;
                case 'escape':
                    e.preventDefault();
                    // Close help overlay if it's open, otherwise emergency eject
                    if (helpOverlay && !helpOverlay.classList.contains('hidden')) {
                        hideHelpOverlay();
                    } else {
                        emergencyEject();
                    }
                    break;
            }
        });

        // ===== INTERACTIVE MAP CLICKING - Play notes based on click position =====
        function handleMapClick(e) {
            // Only allow when flying
            if (!isFlying || !audioContext) return;

            // Get click position relative to canvas
            const rect = flightCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Normalize to 0-1 range
            const normalizedX = x / rect.width;
            const normalizedY = y / rect.height;

            // Play a note based on click position
            playInteractiveNote(normalizedX, normalizedY);

            // Visual feedback - create a ripple effect at click position
            createClickRipple(x, y);
        }

        // Add click listener to flight canvas
        if (flightCanvas) {
            flightCanvas.addEventListener('click', handleMapClick);

            // Also handle touch events for mobile
            flightCanvas.addEventListener('touchstart', function(e) {
                e.preventDefault(); // Prevent scrolling
                const touch = e.touches[0];
                const rect = flightCanvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const normalizedX = x / rect.width;
                const normalizedY = y / rect.height;

                playInteractiveNote(normalizedX, normalizedY);
                createClickRipple(x, y);
            }, { passive: false });

            logDebug('UI', 'Interactive map clicking enabled');
        }
    }

    // Toggle cockpit display
    function toggleCockpit() {
        const isCollapsed = cockpitContainer.classList.contains('collapsed');
        
        if (isCollapsed) {
            cockpitContainer.classList.remove('collapsed');
            cockpitContainer.classList.add('expanded');
            cockpitToggle.textContent = 'Hide Controls';
        } else {
            cockpitContainer.classList.remove('expanded');
            cockpitContainer.classList.add('collapsed');
            cockpitToggle.textContent = 'Flight Controls';
        }
    }
    
    // Toggle UI visibility
    function toggleUI() {
        uiVisible = !uiVisible;
        
        if (uiVisible) {
            flightContainer.classList.remove('hide-ui');
            toggleUIButton.textContent = 'Hide UI';
        } else {
            flightContainer.classList.add('hide-ui');
            toggleUIButton.textContent = 'Show UI';
        }
    }
    
    // Update UI state based on current settings
    function updateUIState() {
        // Update volume value
        document.getElementById('volumeValue').textContent = parseFloat(volumeControl.value).toFixed(2);
        
        // Update reverb value
        document.getElementById('reverbValue').textContent = Math.floor(parseFloat(reverbControl.value) * 100) + '%';
        
        // Update decay value
        document.getElementById('decayValue').textContent = parseFloat(decayControl.value).toFixed(1) + 's';
        
        // Update bass level value
        document.getElementById('bassLevelValue').textContent = Math.floor(parseFloat(bassLevelControl.value) * 100) + '%';
        
        // Update altitude slider text
        const altitudeValue = parseFloat(altitudeControl.value);
        let altitudeText = "Cruising";
        if (altitudeValue < 0.8) altitudeText = "Low Altitude";
        else if (altitudeValue > 1.2) altitudeText = "High Altitude";
        document.getElementById('altitudeValue').textContent = altitudeText;
        
        // Update tempo value
        document.getElementById('tempoValue').textContent = parseInt(tempoControl.value);
        document.getElementById('tempoBPM').textContent = parseInt(tempoControl.value) + ' BPM';
        
        // Update persistence value
        document.getElementById('persistenceValue').textContent = Math.floor(parseFloat(persistenceControl.value) * 100) + '%';
        
        // Update trail intensity value
        document.getElementById('trailIntensityValue').textContent = parseFloat(trailIntensityControl.value).toFixed(1);
        
        // Update filter controls
        document.getElementById('filterCutoffValue').textContent = parseInt(filterCutoffControl.value) + ' Hz';
        document.getElementById('lfoRateValue').textContent = lfoDivisions[parseInt(lfoRateControl.value)].name;
        document.getElementById('lfoAmountValue').textContent = parseInt(lfoAmountControl.value) + '%';
        
        // Update compressor controls
        document.getElementById('compThresholdValue').textContent = parseInt(compThresholdControl.value) + ' dB';
        document.getElementById('compRatioValue').textContent = parseFloat(compRatioControl.value).toFixed(1) + ':1';
        document.getElementById('compAttackValue').textContent = parseFloat(compAttackControl.value).toFixed(2) + 's';
        document.getElementById('compReleaseValue').textContent = parseFloat(compReleaseControl.value).toFixed(2) + 's';
        
        // Update LED indicators
        updateLEDIndicators();
        
        // Update artist info
        updateArtistInfo();
        
        // Update gauges
        updateGauges();
    }
    
    // Update LED indicators
    function updateLEDIndicators() {
        // Filter LED
        if (isFilterEnabled) {
            filterLed.classList.add('active');
            filterLed.classList.add('filter');
        } else {
            filterLed.classList.remove('active');
            filterLed.classList.remove('filter');
        }
        
        // LFO LED
        if (isLfoEnabled) {
            lfoLed.classList.add('active');
        } else {
            lfoLed.classList.remove('active');
        }
        
        // Compressor LED
        if (isCompressorEnabled) {
            compressorLed.classList.add('active');
            compressorLed.classList.add('compressor');
        } else {
            compressorLed.classList.remove('active');
            compressorLed.classList.remove('compressor');
        }
    }
    
    // Update artist info in UI
    function updateArtistInfo() {
        // Get the artist style info
        const artist = artistStyles[currentArtist];
        
        if (artist) {
            artistInfo.innerHTML = `
                <div>${currentArtistName}</div>
                <div class="artist-style">${artist.description}</div>
            `;
        } else {
            artistInfo.innerHTML = `
                <div>Various Artists</div>
                <div class="artist-style">Mixed Inspiration</div>
            `;
        }
    }
    
    // Update gauges
    function updateGauges() {
        // Update flight time needle (rotates based on elapsed time - full circle after 1 hour)
        if (flightStartTime) {
            const elapsedMs = Date.now() - flightStartTime;
            const hourProgress = (elapsedMs / (60 * 60 * 1000)) % 1; // Progress through an hour (0-1)
            const degrees = hourProgress * 360;
            timeNeedle.style.transform = `translateX(-50%) rotate(${degrees}deg)`;
        } else {
            timeNeedle.style.transform = 'translateX(-50%) rotate(0deg)';
        }
        
        // Update altitude needle (rotates based on altitude control)
        const altValue = parseFloat(altitudeControl.value);
        const altDegrees = ((altValue - 0.5) / 1.5) * 360; // Map 0.5-2.0 to 0-360
        altitudeNeedle.style.transform = `translateX(-50%) rotate(${altDegrees}deg)`;
        
        // Update altitude display
        const altitudeFeet = Math.floor(altValue * 25000);
        document.getElementById('flightAltitude').textContent = altitudeFeet.toLocaleString() + ' ft';
        
        // Update tempo needle (rotates based on tempo control)
        const tempoValue = parseInt(tempoControl.value);
        const tempoDegrees = ((tempoValue - 40) / 160) * 360; // Map 40-200 to 0-360
        tempoNeedle.style.transform = `translateX(-50%) rotate(${tempoDegrees}deg)`;
    }
    
    // Open settings panel
    function openSettings() {
        settingsPanel.style.display = 'block';
    }
    
    // Close settings panel
    function closeSettings() {
        settingsPanel.style.display = 'none';
    }
    
    // Toggle fullscreen
    function toggleFullScreen() {
        const doc = window.document;
        const docEl = doc.documentElement;
      
        const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen ||
                              docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen ||
                             doc.webkitExitFullscreen || doc.msExitFullscreen;
      
        if (!doc.fullscreenElement && !doc.mozFullScreenElement &&
            !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            requestFullScreen.call(docEl);
            fullscreenBtn.textContent = "Exit Full";
        } else {
            cancelFullScreen.call(doc);
            fullscreenBtn.textContent = "Full Screen";
        }
    }
    
    // Set canvas sizes
    function resizeCanvases() {
        const container = document.querySelector('.flight-display');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        setCanvasDimensions(width, height);
        
        // Force redraw if flying
        if (isFlying) {
            drawLandscape();
            drawStars();
            drawNoteVisualization();
            if (trailPermaMode && smoothedTrail.length > 0) {
                drawPermanentTrail();
            }
        }
    }
    
    // Helper function to set canvas dimensions
    function setCanvasDimensions(width, height) {
        // Make sure we have valid dimensions
        if (width <= 0 || height <= 0) {
            width = window.innerWidth;
            height = window.innerHeight * 0.7; // 70vh
        }
        
        [flightCanvas, noteCanvas, landscapeCanvas, starsCanvas, trailCanvas].forEach(canvas => {
            if (canvas) {
                // Set the actual drawing buffer size
                canvas.width = width;
                canvas.height = height;
                
                // Ensure CSS dimensions match
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
            }
        });
    }
    
    // Add this function to force a full reset of all canvases
    function resetAllCanvases() {
        // Force a resize of all canvases
        resizeCanvases();
        
        // Clear all canvases
        if (flightCtx) flightCtx.clearRect(0, 0, flightCanvas.width, flightCanvas.height);
        if (noteCtx) noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
        if (landscapeCtx) landscapeCtx.clearRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);
        if (starsCtx) starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
        if (trailCtx) trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
        
        // Add a timeout to force another resize after a brief delay
        // This helps in some browsers where the initial size might not be correct
        setTimeout(resizeCanvases, 100);
    }
    
    // Initialize audio context with safety features
    function initializeAudio() {
        try {
            // Check if AudioContext is supported
            if (!window.AudioContext && !window.webkitAudioContext) {
                throw new Error('Web Audio API is not supported in this browser');
            }
            
            // Only create a new AudioContext if it doesn't exist or is closed
            if (!audioContext || audioContext.state === 'closed') {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Created new AudioContext');
            }
            
            // Resume context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully');
                    showStatus('Cabin audio system resumed successfully!');
                }).catch(err => {
                    console.warn('Could not resume AudioContext automatically:', err);
                });
            }
            
            // Create master gain node
            masterGainNode = audioContext.createGain();
            masterGainNode.gain.setValueAtTime(parseFloat(volumeControl.value), audioContext.currentTime);
            
            // Create high-pass filter (ALWAYS ACTIVE - prevents frequencies below 20Hz)
            highPassFilter = audioContext.createBiquadFilter();
            highPassFilter.type = 'highpass';
            highPassFilter.frequency.setValueAtTime(safeLowFreq, audioContext.currentTime);
            highPassFilter.Q.value = 0.7; // Moderate Q for a gentle slope
            
            // Create bass EQ filter (low-shelf type)
            bassEQNode = audioContext.createBiquadFilter();
            bassEQNode.type = 'lowshelf';
            bassEQNode.frequency.setValueAtTime(250, audioContext.currentTime); // 250Hz is a good point for bass control
            
            // Set initial bass level from control
            const bassLevel = parseFloat(bassLevelControl.value);
            const scaledGain = bassLevel * 6 - 3; // Range from -3dB to +3dB
            bassEQNode.gain.setValueAtTime(scaledGain, audioContext.currentTime);
            
            // Create safety limiter (ALWAYS ACTIVE)
            limiterNode = audioContext.createDynamicsCompressor();
            limiterNode.threshold.setValueAtTime(limiterThreshold, audioContext.currentTime);
            limiterNode.ratio.setValueAtTime(20, audioContext.currentTime); // Hard limiting
            limiterNode.attack.setValueAtTime(0.001, audioContext.currentTime); // Fast attack
            limiterNode.release.setValueAtTime(0.1, audioContext.currentTime); // Quick release
            limiterNode.knee.setValueAtTime(0, audioContext.currentTime); // Hard knee for true limiting
            
            // Create reverb setup
            setupReverb();
            
            // Create filter (but don't enable unless toggled)
            setupFilter();
            
            // Create compressor (but don't enable unless toggled)
            setupCompressor();
            
            // Set up the complete audio chain
            setupAudioChain();
            
            // Set up audio meter
            setupAudioMeter();
            
            showStatus('Cabin audio system initialized! Click Take Off to start.');
            
            if (takeoffButton) {
                takeoffButton.disabled = false;
            }
            
            return true;
        } catch (error) {
            console.error('Audio Initialization Error:', error);
            showStatus('Cabin audio system error: ' + error.message + '. Try a different browser.');
            return false;
        }
    }
    
    // Update audio safety settings
    function updateAudioSafetySettings() {
        if (audioContext) {
            // Update high pass filter
            if (highPassFilter) {
                highPassFilter.frequency.setValueAtTime(safeLowFreq, audioContext.currentTime);
                console.log('Updated high-pass filter frequency to', safeLowFreq, 'Hz');
            }
            
            // Update limiter
            if (limiterNode) {
                limiterNode.threshold.setValueAtTime(limiterThreshold, audioContext.currentTime);
                console.log('Updated limiter threshold to', limiterThreshold, 'dB');
            }
        }
    }
    
    // Set up audio chain
    function setupAudioChain() {
        if (!audioContext || !masterGainNode) return false;
        
        try {
            // First disconnect all nodes to rebuild the chain
            try {
                masterGainNode.disconnect();
                if (highPassFilter) highPassFilter.disconnect();
                if (bassEQNode) bassEQNode.disconnect();
                if (filterNode) filterNode.disconnect();
                if (compressorNode) compressorNode.disconnect();
                if (limiterNode) limiterNode.disconnect();
                if (reverbNode) reverbNode.disconnect();
                if (dryGainNode) dryGainNode.disconnect();
                if (wetGainNode) wetGainNode.disconnect();
            } catch (e) {
                console.warn("Error disconnecting nodes:", e);
            }
            
            // Build the audio chain based on which effects are enabled
            let lastNode = masterGainNode;
            
            // ALWAYS include high-pass filter first for safety (prevent <20Hz content)
            if (highPassFilter) {
                lastNode.connect(highPassFilter);
                lastNode = highPassFilter;
            }
            
            // Next include bass EQ if available
            if (bassEQNode) {
                lastNode.connect(bassEQNode);
                lastNode = bassEQNode;
            }

            // Connect cabin pressure filter if enabled (altitude-based)
            if (cabinPressureFilter && isCabinPressureEnabled) {
                lastNode.connect(cabinPressureFilter);
                lastNode = cabinPressureFilter;
            }

            // Connect filter if enabled
            if (filterNode && isFilterEnabled) {
                lastNode.connect(filterNode);
                lastNode = filterNode;
            }
            
            // Connect compressor if enabled
            if (compressorNode && isCompressorEnabled) {
                lastNode.connect(compressorNode);
                lastNode = compressorNode;
            }
            
            // ALWAYS include limiter for safety
            if (limiterNode) {
                lastNode.connect(limiterNode);
                lastNode = limiterNode;
            }
            
            // Connect reverb if available
            if (reverbNode && wetGainNode && dryGainNode) {
                // Split signal for wet/dry mix
                lastNode.connect(dryGainNode);
                lastNode.connect(reverbNode);
                reverbNode.connect(wetGainNode);
                
                // Both wet and dry paths go to destination
                dryGainNode.connect(audioContext.destination);
                wetGainNode.connect(audioContext.destination);
            } else {
                // Direct to destination if no reverb
                lastNode.connect(audioContext.destination);
            }
            
            console.log("Audio chain established successfully");
            return true;
        } catch (error) {
            console.error("Error setting up audio chain:", error);
            return false;
        }
    }
    
    // Setup reverb
    function setupReverb() {
        try {
            // Create a convolver node for reverb
            reverbNode = audioContext.createConvolver();
            
            // Create wet/dry gain nodes for mixing
            wetGainNode = audioContext.createGain();
            dryGainNode = audioContext.createGain();
            
            // Set initial reverb level
            const reverbLevel = parseFloat(document.getElementById('reverb').value);
            wetGainNode.gain.setValueAtTime(reverbLevel, audioContext.currentTime);
            dryGainNode.gain.setValueAtTime(1 - reverbLevel, audioContext.currentTime);
            
            // Create impulse response buffer
            createReverbImpulse(2); // 2 second reverb
            
            // The actual connections will be made in setupAudioChain()
            
            console.log('Cabin atmosphere reverb setup successful');
            return true;
        } catch (error) {
            console.error('Reverb Setup Error:', error);
            showStatus('Cabin atmosphere setup error: ' + error.message);
            return false;
        }
    }
    
    // Create impulse response for reverb
    function createReverbImpulse(duration) {
        try {
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);
            
            // Create a simple exponential decay
            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                // Exponential decay
                const amplitude = Math.random() * Math.exp(-t * 4);
                left[i] = amplitude * (Math.random() * 2 - 1);
                right[i] = amplitude * (Math.random() * 2 - 1);
            }
            
            reverbNode.buffer = impulse;
            convolverBuffer = impulse;
            
            console.log('Created cabin atmosphere impulse response');
            return true;
        } catch (error) {
            console.error('Error creating reverb impulse:', error);
            return false;
        }
    }
    
    // Update reverb settings
    function updateReverb() {
        const value = parseFloat(reverbControl.value);
        document.getElementById('reverbValue').textContent = Math.floor(value * 100) + '%';
        
        if (!wetGainNode || !dryGainNode) return;
        
        wetGainNode.gain.setValueAtTime(value, audioContext.currentTime);
        
        // At 100% reverb, use only wet signal (pure reverb)
        // Between 95-100%, gradually fade out the dry signal
        let dryValue;
        if (value >= 0.95) {
            // Scale 0.95-1.0 to 0.2-0.0 for smooth transition to pure reverb
            dryValue = 0.2 * (1 - ((value - 0.95) / 0.05));
        } else {
            dryValue = 1 - value;
        }
        
        dryGainNode.gain.setValueAtTime(dryValue, audioContext.currentTime);
        
        // Update trail properties based on reverb level
        updateTrailProperties(value);
    }
    
    // Update trail properties based on reverb level
    function updateTrailProperties(reverbValue) {
        // Adjust trail length based on reverb
        // Higher reverb = longer trail
        MAX_TRAIL_POINTS = 100 + Math.floor(reverbValue * 400); // 100 to 500 points
    }
    
    // Setup audio meter
    function setupAudioMeter() {
        if (!audioContext || !masterGainNode) return;
        
        try {
            // Create analyzer node
            audioAnalyser = audioContext.createAnalyser();
            audioAnalyser.fftSize = 1024;
            audioAnalyser.smoothingTimeConstant = 0.85;
            
            // Connect analyzer after the master gain but before the limiter
            // This allows us to monitor levels before they're limited
            masterGainNode.connect(audioAnalyser);
            
            // Start updating the meter
            const bufferLength = audioAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            audioUpdateInterval = setInterval(() => {
                if (audioContext && audioAnalyser && audioMeterElement) {
                    audioAnalyser.getByteTimeDomainData(dataArray);
                    
                    // Calculate RMS value
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        const amplitude = (dataArray[i] - 128) / 128;
                        sum += amplitude * amplitude;
                    }
                    const rms = Math.sqrt(sum / bufferLength);
                    
                    // Convert to dB (avoid -Infinity for silence)
                    const db = rms > 0 ? 20 * Math.log10(rms) : -100;
                    
                    // Map to percentage for meter (from -60dB to 0dB)
                    const percentage = Math.max(0, Math.min(100, (db + 60) * (100 / 60)));
                    
                    // Update meter
                    audioMeterElement.style.width = percentage + '%';
                    
                    // Color meter based on level
                    if (percentage > 90) {
                        audioMeterElement.style.backgroundColor = '#e74c3c'; // Red for high levels
                    } else if (percentage > 70) {
                        audioMeterElement.style.backgroundColor = '#f39c12'; // Orange for medium-high levels
                    } else {
                        audioMeterElement.style.backgroundColor = '#2ecc71'; // Green for safe levels
                    }
                    
                    // Update text label (format to 1 decimal place, show infinity for very low levels)
                    let dbText = db < -60 ? '-∞' : db.toFixed(1);
                    audioLevelLabel.textContent = dbText + ' dB';
                }
            }, 100);
            
            console.log('Audio meter initialized');
        } catch (error) {
            console.error('Error setting up audio meter:', error);
        }
    }
    
    // Setup filter
    function setupFilter() {
        try {
            if (!audioContext) return false;
            
            // Create low-pass filter
            filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'lowpass';
            filterNode.Q.value = 1.0; // Resonance (1.0 is neutral)
            
            // Set initial cutoff frequency from control
            const cutoffValue = filterCutoffControl ? parseInt(filterCutoffControl.value) : 20000;
            filterNode.frequency.setValueAtTime(cutoffValue, audioContext.currentTime);
            
            // Setup filter in audio chain
            setupAudioChain();
            
            console.log(`Low-pass filter initialized at ${cutoffValue}Hz`);
            
            return true;
        } catch (error) {
            console.error('Error setting up filter:', error);
            showStatus('Air Filter setup error: ' + error.message);
            return false;
        }
    }
    
    // Setup compressor
    function setupCompressor() {
        try {
            if (!audioContext) return false;
            
            // Create compressor node
            compressorNode = audioContext.createDynamicsCompressor();
            
            // Set initial parameters from controls
            const threshold = parseInt(compThresholdControl.value);
            const ratio = parseFloat(compRatioControl.value);
            const attack = parseFloat(compAttackControl.value);
            const release = parseFloat(compReleaseControl.value);
            
            compressorNode.threshold.setValueAtTime(threshold, audioContext.currentTime);
            compressorNode.ratio.setValueAtTime(ratio, audioContext.currentTime);
            compressorNode.attack.setValueAtTime(attack, audioContext.currentTime);
            compressorNode.release.setValueAtTime(release, audioContext.currentTime);
            compressorNode.knee.setValueAtTime(1, audioContext.currentTime); // Soft knee
            
            // Setup compressor in audio chain
            setupAudioChain();
            
            console.log(`Compressor initialized with threshold: ${threshold}dB, ratio: ${ratio}:1, attack: ${attack}s, release: ${release}s`);
            
            return true;
        } catch (error) {
            console.error('Error setting up compressor:', error);
            showStatus('Cabin Pressure System error: ' + error.message);
            return false;
        }
    }

    // Setup engine hum
    function setupEngineHum() {
        try {
            if (!audioContext) return false;

            // Create oscillator for engine drone
            engineOscillator = audioContext.createOscillator();
            engineOscillator.type = 'sawtooth';
            engineOscillator.frequency.setValueAtTime(55, audioContext.currentTime); // Low A note

            // Create gain node for engine volume
            engineGain = audioContext.createGain();
            engineGain.gain.setValueAtTime(0.15, audioContext.currentTime);

            // Create lowpass filter to make it more drone-like
            const engineFilter = audioContext.createBiquadFilter();
            engineFilter.type = 'lowpass';
            engineFilter.frequency.setValueAtTime(200, audioContext.currentTime);
            engineFilter.Q.setValueAtTime(1, audioContext.currentTime);

            // Connect: oscillator -> filter -> gain -> master
            engineOscillator.connect(engineFilter);
            engineFilter.connect(engineGain);
            engineGain.connect(masterGainNode);

            // Start the oscillator
            engineOscillator.start();

            console.log('Engine hum initialized');
            return true;
        } catch (error) {
            console.error('Error setting up engine hum:', error);
            return false;
        }
    }

    // Setup wind noise
    function setupWindNoise() {
        try {
            if (!audioContext) return false;

            // Create buffer for white noise
            const bufferSize = audioContext.sampleRate * 2;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            // Create buffer source
            windNoiseNode = audioContext.createBufferSource();
            windNoiseNode.buffer = noiseBuffer;
            windNoiseNode.loop = true;

            // Create bandpass filter for wind character
            windNoiseFilter = audioContext.createBiquadFilter();
            windNoiseFilter.type = 'bandpass';
            windNoiseFilter.frequency.setValueAtTime(800, audioContext.currentTime);
            windNoiseFilter.Q.setValueAtTime(0.5, audioContext.currentTime);

            // Create gain node for wind volume
            windNoiseGain = audioContext.createGain();
            windNoiseGain.gain.setValueAtTime(0, audioContext.currentTime); // Start at 0, increase with velocity

            // Connect: noise -> filter -> gain -> master
            windNoiseNode.connect(windNoiseFilter);
            windNoiseFilter.connect(windNoiseGain);
            windNoiseGain.connect(masterGainNode);

            // Start the noise
            windNoiseNode.start();

            console.log('Wind noise initialized');
            return true;
        } catch (error) {
            console.error('Error setting up wind noise:', error);
            return false;
        }
    }

    // Setup rain ambience (inspired by pink noise + reverb)
    function setupRainAmbience() {
        try {
            if (!audioContext) return false;

            // Create buffer for pink-ish noise (filtered white noise)
            const bufferSize = audioContext.sampleRate * 2;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            // Generate white noise
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            // Create buffer source
            rainNoiseNode = audioContext.createBufferSource();
            rainNoiseNode.buffer = noiseBuffer;
            rainNoiseNode.loop = true;

            // HPF at 400Hz (remove deep rumble)
            const rainHPF = audioContext.createBiquadFilter();
            rainHPF.type = 'highpass';
            rainHPF.frequency.setValueAtTime(400, audioContext.currentTime);
            rainHPF.Q.setValueAtTime(0.5, audioContext.currentTime);

            // LPF for rain character (variable drops)
            rainFilter = audioContext.createBiquadFilter();
            rainFilter.type = 'lowpass';
            rainFilter.frequency.setValueAtTime(7000, audioContext.currentTime);
            rainFilter.Q.setValueAtTime(1.0, audioContext.currentTime);

            // Create reverb for spaciousness
            rainReverb = audioContext.createConvolver();
            createSimpleReverb(rainReverb, 2.5, 0.5); // 2.5s reverb, 0.5 decay

            // Gain nodes
            rainReverbGain = audioContext.createGain();
            rainReverbGain.gain.setValueAtTime(0.7, audioContext.currentTime);

            rainGain = audioContext.createGain();
            rainGain.gain.setValueAtTime(0, audioContext.currentTime); // Start at 0

            // Connect: noise -> HPF -> LPF -> reverb -> gain -> master
            rainNoiseNode.connect(rainHPF);
            rainHPF.connect(rainFilter);
            rainFilter.connect(rainReverb);
            rainReverb.connect(rainReverbGain);
            rainReverbGain.connect(rainGain);
            rainGain.connect(masterGainNode);

            // Start the noise
            rainNoiseNode.start();

            // Slowly fade in rain over 10 seconds
            rainGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 10);

            console.log('Rain ambience initialized');
            return true;
        } catch (error) {
            console.error('Error setting up rain:', error);
            return false;
        }
    }

    // Setup distant thunder
    function setupThunder() {
        try {
            if (!audioContext) return false;

            // Create buffer for pink-ish noise
            const bufferSize = audioContext.sampleRate * 2;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            // Generate white noise
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            // Create buffer source
            thunderNoiseNode = audioContext.createBufferSource();
            thunderNoiseNode.buffer = noiseBuffer;
            thunderNoiseNode.loop = true;

            // HPF at 20Hz (keep the rumble)
            const thunderHPF = audioContext.createBiquadFilter();
            thunderHPF.type = 'highpass';
            thunderHPF.frequency.setValueAtTime(20, audioContext.currentTime);
            thunderHPF.Q.setValueAtTime(0.7, audioContext.currentTime);

            // LPF with modulation for thunder character
            thunderFilter = audioContext.createBiquadFilter();
            thunderFilter.type = 'lowpass';
            thunderFilter.frequency.setValueAtTime(1500, audioContext.currentTime);
            thunderFilter.Q.setValueAtTime(3.0, audioContext.currentTime);

            // LFO for filter modulation
            thunderLFO = audioContext.createOscillator();
            thunderLFO.type = 'sine';
            thunderLFO.frequency.setValueAtTime(1, audioContext.currentTime); // 1Hz modulation

            const thunderLFOGain = audioContext.createGain();
            thunderLFOGain.gain.setValueAtTime(1000, audioContext.currentTime); // Modulation depth

            thunderLFO.connect(thunderLFOGain);
            thunderLFOGain.connect(thunderFilter.frequency);

            // Create reverb for spacious thunder
            thunderReverb = audioContext.createConvolver();
            createSimpleReverb(thunderReverb, 4.0, 0.7); // 4s reverb, 0.7 decay

            // Gain nodes
            thunderReverbGain = audioContext.createGain();
            thunderReverbGain.gain.setValueAtTime(0.8, audioContext.currentTime);

            thunderGain = audioContext.createGain();
            thunderGain.gain.setValueAtTime(0, audioContext.currentTime); // Start at 0

            // Connect chain
            thunderNoiseNode.connect(thunderHPF);
            thunderHPF.connect(thunderFilter);
            thunderFilter.connect(thunderReverb);
            thunderReverb.connect(thunderReverbGain);
            thunderReverbGain.connect(thunderGain);
            thunderGain.connect(masterGainNode);

            // Start nodes
            thunderNoiseNode.start();
            thunderLFO.start();

            // Trigger thunder rumbles periodically (every 15-45 seconds)
            startThunderRumbles();

            console.log('Thunder initialized');
            return true;
        } catch (error) {
            console.error('Error setting up thunder:', error);
            return false;
        }
    }

    // Create a simple reverb impulse response
    function createSimpleReverb(convolverNode, duration, decay) {
        const sampleRate = audioContext.sampleRate;
        const length = sampleRate * duration;
        const impulse = audioContext.createBuffer(2, length, sampleRate);
        const left = impulse.getChannelData(0);
        const right = impulse.getChannelData(1);

        for (let i = 0; i < length; i++) {
            const n = length - i;
            left[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
        }

        convolverNode.buffer = impulse;
    }

    // Trigger thunder rumbles at random intervals
    function startThunderRumbles() {
        if (thunderInterval) {
            clearInterval(thunderInterval);
        }

        const triggerThunder = () => {
            if (!isThunderEnabled || !isFlying || !thunderGain) return;

            // Random thunder intensity
            const intensity = 0.05 + Math.random() * 0.15; // 0.05 to 0.2
            const duration = 3 + Math.random() * 4; // 3-7 seconds

            // Fade in
            thunderGain.gain.cancelScheduledValues(audioContext.currentTime);
            thunderGain.gain.setValueAtTime(thunderGain.gain.value, audioContext.currentTime);
            thunderGain.gain.linearRampToValueAtTime(intensity, audioContext.currentTime + 1);

            // Fade out
            thunderGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

            console.log(`Thunder rumble: intensity ${intensity.toFixed(2)}, duration ${duration.toFixed(1)}s`);

            // Schedule next thunder (15-45 seconds later)
            const nextDelay = 15000 + Math.random() * 30000;
            thunderInterval = setTimeout(triggerThunder, nextDelay);
        };

        // Trigger first thunder after 5-15 seconds
        const initialDelay = 5000 + Math.random() * 10000;
        thunderInterval = setTimeout(triggerThunder, initialDelay);
    }

    // Stop thunder rumbles
    function stopThunderRumbles() {
        if (thunderInterval) {
            clearTimeout(thunderInterval);
            thunderInterval = null;
        }

        if (thunderGain && audioContext) {
            thunderGain.gain.cancelScheduledValues(audioContext.currentTime);
            thunderGain.gain.setValueAtTime(0, audioContext.currentTime);
        }
    }

    // Setup cabin pressure filter (altitude-based)
    function setupCabinPressureFilter() {
        try {
            if (!audioContext) return false;

            // Create lowpass filter that will be controlled by altitude
            cabinPressureFilter = audioContext.createBiquadFilter();
            cabinPressureFilter.type = 'lowpass';
            cabinPressureFilter.frequency.setValueAtTime(22050, audioContext.currentTime); // Start fully open
            cabinPressureFilter.Q.setValueAtTime(0.7, audioContext.currentTime);

            // This filter will be inserted in the audio chain
            setupAudioChain();

            console.log('Cabin pressure filter initialized');
            return true;
        } catch (error) {
            console.error('Error setting up cabin pressure filter:', error);
            return false;
        }
    }

    // Setup LFO
    function setupLFO() {
        try {
            if (!audioContext) return false;
            
            // Ensure we have a filter before setting up LFO
            if (!filterNode || !isFilterEnabled) {
                setupFilter();
            }
            
            // Clean up existing LFO if it exists
            if (lfoOscillator) {
                try {
                    lfoOscillator.stop();
                    lfoOscillator.disconnect();
                } catch (e) {
                    console.warn("Error cleaning up existing LFO:", e);
                }
            }
            
            // Create LFO oscillator
            lfoOscillator = audioContext.createOscillator();
            lfoOscillator.type = 'sine';
            
            // Create gain node to control LFO amount
            lfoGain = audioContext.createGain();
            
            // Calculate frequency based on current BPM
            const bpm = parseFloat(tempoControl.value) || 90;
            const lfoRateIndex = parseInt(lfoRateControl.value);
            const divisionInfo = lfoDivisions[lfoRateIndex] || lfoDivisions[2]; // Default to 1/4 note
            const frequency = (bpm / 60) * divisionInfo.value;
            
            lfoOscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            // Get the current filter cutoff
            const cutoffValue = parseInt(filterCutoffControl.value);
            
            // Connect LFO through gain to filter frequency
            lfoOscillator.connect(lfoGain);
            lfoGain.connect(filterNode.frequency);
            
            // Set LFO amount - crucial fix here
            const lfoAmountValue = parseInt(lfoAmountControl.value);
            
            // Scale amount to get a reasonable modulation depth
            // This is the key fix - we calculate the LFO modulation amount
            // relative to the current cutoff frequency
            const modDepth = (lfoAmountValue / 100) * (cutoffValue * 0.8);
            lfoGain.gain.setValueAtTime(modDepth, audioContext.currentTime);
            
            // Start the oscillator
            lfoOscillator.start();
            
            console.log(`LFO initialized at ${frequency}Hz with amount ${lfoAmountValue}% (modDepth: ${modDepth}Hz)`);
            
            // Update LED
            lfoLed.classList.add('active');
            
            return true;
        } catch (error) {
            console.error('Error setting up LFO:', error);
            showStatus('Turbulence setup error: ' + error.message);
            return false;
        }
    }
    
    // Update slider controls
    function updateVolume() {
        const volumeValue = parseFloat(volumeControl.value);
        document.getElementById('volumeValue').textContent = volumeValue.toFixed(2);
        
        // Adjust master gain
        if (masterGainNode) {
            masterGainNode.gain.setValueAtTime(volumeValue, audioContext.currentTime);
        }
    }
    
    function updateDecay() {
        const decayValue = parseFloat(decayControl.value);
        document.getElementById('decayValue').textContent = decayValue.toFixed(1) + 's';
        
        // Update max trail points based on decay
        MAX_TRAIL_POINTS = 100 + Math.floor(decayValue * 40);
    }
    
    function updateTempo() {
        const tempoValue = parseInt(tempoControl.value);
        document.getElementById('tempoValue').textContent = tempoValue;
        document.getElementById('tempoBPM').textContent = tempoValue + ' BPM';

        // Update tempo needle in gauge
        const tempoDegrees = ((tempoValue - 40) / 160) * 360; // Map 40-200 to 0-360
        tempoNeedle.style.transform = `translateX(-50%) rotate(${tempoDegrees}deg)`;

        // Update LFO with tempo
        updateLfoFrequencyWithTempo();

        // Update BPM-synced animations if flying
        if (isFlying) {
            syncAnimationToBPM();
        }
    }
    
    function updateAltitude() {
        const altitudeValue = parseFloat(altitudeControl.value);
        let altitudeText = "Cruising";

        if (altitudeValue < 0.8) altitudeText = "Low Altitude";
        else if (altitudeValue > 1.2) altitudeText = "High Altitude";

        document.getElementById('altitudeValue').textContent = altitudeText;

        // Track altitude in flight log
        trackAltitude(altitudeValue);
        
        // Update altitude needle in gauge
        const altDegrees = ((altitudeValue - 0.5) / 1.5) * 360; // Map 0.5-2.0 to 0-360
        altitudeNeedle.style.transform = `translateX(-50%) rotate(${altDegrees}deg)`;
        
        // Update altitude display
        const altitudeFeet = Math.floor(altitudeValue * 25000);
        document.getElementById('flightAltitude').textContent = altitudeFeet.toLocaleString() + ' ft';
    }
    
    function updatePersistence() {
        // Get new persistence value
        elementPersistence = parseFloat(persistenceControl.value);
        document.getElementById('persistenceValue').textContent = Math.floor(elementPersistence * 100) + '%';
        
        // Update permanent flag for all elements based on persistence
        mountains.forEach(mountain => {
            mountain.permanentElement = elementPersistence >= 0.7;
        });
        
        clouds.forEach(cloud => {
            cloud.permanentElement = elementPersistence >= 0.7;
        });
        
        cities.forEach(city => {
            city.permanentElement = elementPersistence >= 0.5;
        });
    }
    
    function updateTrailIntensity() {
        // Get new intensity value
        trailIntensity = parseFloat(trailIntensityControl.value);
        document.getElementById('trailIntensityValue').textContent = trailIntensity.toFixed(1);
        
        // Redraw trail with new intensity if permanent trail mode is on
        if (trailPermaMode && smoothedTrail.length > 0) {
            drawPermanentTrail();
        }
    }
    
    function updateBassLevel() {
        const bassLevel = parseFloat(bassLevelControl.value);
        document.getElementById('bassLevelValue').textContent = Math.floor(bassLevel * 100) + '%';
        
        // Update bass EQ if it exists
        if (bassEQNode && audioContext) {
            // Adjust gain (scaled to prevent excessive bass)
            const scaledGain = bassLevel * 6 - 3; // Range from -3dB to +3dB
            bassEQNode.gain.setTargetAtTime(scaledGain, audioContext.currentTime, 0.1);
            console.log(`Updated bass level: ${scaledGain}dB`);
        }
    }
    
    // Update filter cutoff
    function updateFilterCutoff() {
        const cutoffValue = parseInt(filterCutoffControl.value);
        document.getElementById('filterCutoffValue').textContent = cutoffValue + ' Hz';
        
        // Update filter if it exists and is enabled
        if (filterNode && isFilterEnabled) {
            // Set new cutoff value
            filterNode.frequency.setTargetAtTime(
                cutoffValue, 
                audioContext.currentTime, 
                0.1
            );
            
            // If LFO is enabled, we need to update the LFO amount 
            // based on the new cutoff frequency
            if (isLfoEnabled && lfoGain) {
                // Get the current LFO amount percentage
                const lfoAmountValue = parseInt(lfoAmountControl.value);
                
                // Recalculate modulation depth based on new cutoff
                const modDepth = (lfoAmountValue / 100) * (cutoffValue * 0.8);
                
                // Update LFO gain
                lfoGain.gain.setTargetAtTime(
                    modDepth,
                    audioContext.currentTime,
                    0.1
                );
                
                console.log(`Updated filter cutoff: ${cutoffValue}Hz with LFO modDepth: ${modDepth}Hz`);
            } else {
                console.log(`Updated filter cutoff: ${cutoffValue}Hz`);
            }
        }
    }
    
    // Update LFO rate
    function updateLfoRate() {
        const lfoRateIndex = parseInt(lfoRateControl.value);
        const divisionInfo = lfoDivisions[lfoRateIndex] || lfoDivisions[2]; // Default to 1/4 note
        document.getElementById('lfoRateValue').textContent = divisionInfo.name;
        
        currentLfoRate = lfoRateIndex;
        
        // Update LFO if it exists and is enabled
        if (lfoOscillator && isLfoEnabled) {
            // Calculate frequency based on current BPM
            const bpm = parseFloat(tempoControl.value) || 90;
            const frequency = (bpm / 60) * divisionInfo.value;
            
            lfoOscillator.frequency.setTargetAtTime(
                frequency,
                audioContext.currentTime,
                0.1
            );
            
            console.log(`Updated LFO rate: ${frequency}Hz (${divisionInfo.name} at ${bpm} BPM)`);
        }
    }
    
    // Update LFO amount
    function updateLfoAmount() {
        const lfoAmountValue = parseInt(lfoAmountControl.value);
        document.getElementById('lfoAmountValue').textContent = lfoAmountValue + '%';
        
        currentLfoAmount = lfoAmountValue;
        
        // Update LFO gain if it exists and is enabled
        if (lfoGain && isLfoEnabled && filterNode) {
            // Get current filter cutoff as reference point
            const cutoffValue = parseInt(filterCutoffControl.value);
            
            // Scale amount to get a reasonable modulation depth
            // relative to the current cutoff frequency
            const modDepth = (lfoAmountValue / 100) * (cutoffValue * 0.8);
            
            // Set LFO gain to control modulation depth
            lfoGain.gain.setTargetAtTime(
                modDepth,
                audioContext.currentTime,
                0.1
            );
            
            console.log(`Updated LFO amount: ${lfoAmountValue}% (modDepth: ${modDepth}Hz)`);
        }
    }
    
    // Update compressor threshold
    function updateCompressorThreshold() {
        const thresholdValue = parseInt(compThresholdControl.value);
        document.getElementById('compThresholdValue').textContent = thresholdValue + ' dB';
        
        // Update compressor if it exists and is enabled
        if (compressorNode && isCompressorEnabled) {
            compressorNode.threshold.setTargetAtTime(
                thresholdValue, 
                audioContext.currentTime, 
                0.01
            );
            console.log(`Updated compressor threshold: ${thresholdValue}dB`);
        }
    }
    
    // Update compressor ratio
    function updateCompressorRatio() {
        const ratioValue = parseFloat(compRatioControl.value);
        document.getElementById('compRatioValue').textContent = ratioValue.toFixed(1) + ':1';
        
        // Update compressor if it exists and is enabled
        if (compressorNode && isCompressorEnabled) {
            compressorNode.ratio.setTargetAtTime(
                ratioValue, 
                audioContext.currentTime, 
                0.01
            );
            console.log(`Updated compressor ratio: ${ratioValue}:1`);
        }
    }
    
    // Update compressor attack
    function updateCompressorAttack() {
        const attackValue = parseFloat(compAttackControl.value);
        document.getElementById('compAttackValue').textContent = attackValue.toFixed(2) + 's';
        
        // Update compressor if it exists and is enabled
        if (compressorNode && isCompressorEnabled) {
            compressorNode.attack.setTargetAtTime(
                attackValue, 
                audioContext.currentTime, 
                0.01
            );
            console.log(`Updated compressor attack: ${attackValue}s`);
        }
    }
    
    // Update compressor release
    function updateCompressorRelease() {
        const releaseValue = parseFloat(compReleaseControl.value);
        document.getElementById('compReleaseValue').textContent = releaseValue.toFixed(2) + 's';
        
        // Update compressor if it exists and is enabled
        if (compressorNode && isCompressorEnabled) {
            compressorNode.release.setTargetAtTime(
                releaseValue, 
                audioContext.currentTime, 
                0.01
            );
            console.log(`Updated compressor release: ${releaseValue}s`);
        }
    }
    
    // Update LFO frequency when tempo changes
    function updateLfoFrequencyWithTempo() {
        if (!lfoOscillator || !isLfoEnabled) return;
        
        const bpm = parseFloat(tempoControl.value) || 90;
        const lfoRateIndex = parseInt(lfoRateControl.value);
        const divisionInfo = lfoDivisions[lfoRateIndex] || lfoDivisions[2]; // Default to 1/4 note
        const frequency = (bpm / 60) * divisionInfo.value;
        
        lfoOscillator.frequency.setTargetAtTime(
            frequency,
            audioContext.currentTime,
            0.1
        );
        
        console.log(`LFO frequency updated to ${frequency}Hz (${divisionInfo.name} at ${bpm} BPM)`);
    }
    
    // Toggle filter
    function toggleFilter() {
        isFilterEnabled = filterToggle.checked;
        
        // Update visual filter indicator
        if (filterIndicator) {
            filterIndicator.classList.toggle('active', isFilterEnabled);
        }
        
        // Update LED indicator
        filterLed.classList.toggle('active', isFilterEnabled);
        filterLed.classList.toggle('filter', isFilterEnabled);
        
        if (isFilterEnabled) {
            // Enable filter if it exists
            if (filterNode && audioContext) {
                // Update filter cutoff from current control value
                const cutoffValue = parseInt(filterCutoffControl.value);
                filterNode.frequency.setValueAtTime(cutoffValue, audioContext.currentTime);
                
                // Make sure the filter is in the audio chain
                setupAudioChain();
                
                showStatus('Air Filter enabled');
            } else {
                // Create filter if it doesn't exist
                setupFilter();
            }
        } else {
            // Bypass filter by setting to maximum frequency
            if (filterNode && audioContext) {
                filterNode.frequency.setValueAtTime(20000, audioContext.currentTime);
                
                // Reconnect the audio chain
                setupAudioChain();
                
                showStatus('Air Filter disabled');
            }
            
            // Disable LFO if it's active
            if (isLfoEnabled) {
                lfoToggle.checked = false;
                toggleLFO();
            }
        }
    }
    
    // Toggle LFO
    function toggleLFO() {
        isLfoEnabled = lfoToggle.checked;
        
        // Update LED indicator
        lfoLed.classList.toggle('active', isLfoEnabled);
        
        if (isLfoEnabled) {
            // First ensure filter is enabled
            if (!isFilterEnabled) {
                isFilterEnabled = true;
                filterToggle.checked = true;
                filterLed.classList.add('active');
                filterLed.classList.add('filter');
                filterIndicator.classList.add('active');
                setupFilter();
            }
            
            // Enable LFO if it exists
            if (lfoOscillator && lfoGain && audioContext) {
                // Calculate frequency based on current BPM and LFO rate
                const bpm = parseFloat(tempoControl.value) || 90;
                const lfoRateIndex = parseInt(lfoRateControl.value);
                const divisionInfo = lfoDivisions[lfoRateIndex] || lfoDivisions[2]; // Default to 1/4 note
                const frequency = (bpm / 60) * divisionInfo.value;
                
                lfoOscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                
                // Set LFO amount based on current value
                updateLfoAmount();
                
                showStatus('Turbulence modulation enabled');
            } else {
                // Create LFO if it doesn't exist
                setupLFO();
            }
        } else {
            // Stop LFO if it exists
            if (lfoOscillator && audioContext) {
                try {
                    lfoOscillator.stop();
                    lfoOscillator.disconnect();
                    lfoOscillator = null;
                    
                    // Reset LFO gain
                    if (lfoGain) {
                        lfoGain.gain.setValueAtTime(0, audioContext.currentTime);
                    }
                } catch (error) {
                    console.error('Error stopping LFO:', error);
                }
            }
            
            showStatus('Turbulence modulation disabled');
        }
    }
    
    // Toggle compressor
    function toggleCompressor() {
        isCompressorEnabled = compressorToggle.checked;
        
        // Update LED indicator
        compressorLed.classList.toggle('active', isCompressorEnabled);
        compressorLed.classList.toggle('compressor', isCompressorEnabled);
        
        if (isCompressorEnabled) {
            // Enable compressor if it exists
            if (compressorNode && audioContext) {
                // Update compressor parameters from current control values
                updateCompressorThreshold();
                updateCompressorRatio();
                updateCompressorAttack();
                updateCompressorRelease();
                
                // Make sure the compressor is in the audio chain
                setupAudioChain();
                
                showStatus('Cabin Pressure System enabled');
            } else {
                // Create compressor if it doesn't exist
                setupCompressor();
            }
        } else {
            // Bypass compressor by disconnecting it
            if (compressorNode && audioContext) {
                // Reconnect the audio chain without the compressor
                setupAudioChain();
                
                showStatus('Cabin Pressure System disabled');
            }
        }
    }

    // Toggle engine hum
    function toggleEngine() {
        isEngineEnabled = engineToggle.checked;

        // Update LED indicator
        const engineLed = document.getElementById('engineLed');
        engineLed.classList.toggle('led-on', isEngineEnabled);

        if (isEngineEnabled) {
            if (!engineOscillator && audioContext) {
                setupEngineHum();
            } else if (engineGain && audioContext) {
                engineGain.gain.setValueAtTime(0.15, audioContext.currentTime);
            }
            showStatus('Engine hum enabled');
        } else {
            if (engineGain && audioContext) {
                engineGain.gain.setValueAtTime(0, audioContext.currentTime);
                showStatus('Engine hum disabled');
            }
        }
    }

    // Toggle wind noise
    function toggleWind() {
        isWindEnabled = windToggle.checked;

        // Update LED indicator
        const windLed = document.getElementById('windLed');
        windLed.classList.toggle('led-on', isWindEnabled);

        if (isWindEnabled) {
            if (!windNoiseNode && audioContext) {
                setupWindNoise();
            }
            showStatus('Wind noise enabled');
        } else {
            if (windNoiseGain && audioContext) {
                windNoiseGain.gain.setValueAtTime(0, audioContext.currentTime);
                showStatus('Wind noise disabled');
            }
        }
    }

    // Toggle altitude-based filter
    function toggleAltitudeFilter() {
        isCabinPressureEnabled = altitudeFilterToggle.checked;

        // Update LED indicator
        const altitudeFilterLed = document.getElementById('altitudeFilterLed');
        altitudeFilterLed.classList.toggle('led-on', isCabinPressureEnabled);

        if (isCabinPressureEnabled) {
            if (!cabinPressureFilter && audioContext) {
                setupCabinPressureFilter();
            } else if (audioContext) {
                // Rebuild audio chain to include the filter
                setupAudioChain();
            }
            showStatus('Altitude filter enabled - sound changes with height');
        } else {
            if (cabinPressureFilter && audioContext) {
                cabinPressureFilter.frequency.setValueAtTime(22050, audioContext.currentTime);
                // Rebuild audio chain to remove the filter
                setupAudioChain();
                showStatus('Altitude filter disabled');
            }
        }
    }

    // Toggle rain ambience
    function toggleRain() {
        isRainEnabled = rainToggle.checked;

        // Update LED indicator
        const rainLed = document.getElementById('rainLed');
        rainLed.classList.toggle('led-on', isRainEnabled);

        if (isRainEnabled) {
            if (!rainNoiseNode && audioContext) {
                setupRainAmbience();
            }
            showStatus('Rain ambience enabled - soothing rainfall');
        } else {
            if (rainGain && audioContext) {
                rainGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);
                showStatus('Rain ambience disabled');
            }
        }
    }

    // Toggle distant thunder
    function toggleThunder() {
        isThunderEnabled = thunderToggle.checked;

        // Update LED indicator
        const thunderLed = document.getElementById('thunderLed');
        thunderLed.classList.toggle('led-on', isThunderEnabled);

        if (isThunderEnabled) {
            if (!thunderNoiseNode && audioContext) {
                setupThunder();
            } else {
                // Restart thunder rumbles if already initialized
                startThunderRumbles();
            }
            showStatus('Distant thunder enabled - rumbles in the distance');
        } else {
            stopThunderRumbles();
            if (thunderGain && audioContext) {
                thunderGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);
                showStatus('Thunder disabled');
            }
        }
    }

    // Toggle musical particles
    function toggleMusicalParticles() {
        isMusicalParticlesEnabled = musicalParticlesToggle.checked;

        // Update LED indicator
        const musicalParticlesLed = document.getElementById('musicalParticlesLed');
        musicalParticlesLed.classList.toggle('led-on', isMusicalParticlesEnabled);

        // Show/hide controls panel
        const controlsPanel = document.getElementById('musicalParticlesControlsPanel');
        if (controlsPanel) {
            controlsPanel.style.display = isMusicalParticlesEnabled ? 'block' : 'none';
        }

        if (isMusicalParticlesEnabled) {
            showStatus('Musical particles enabled - land to hear them!');
        } else {
            showStatus('Musical particles disabled');
        }
    }

    // Update immersive audio based on flight dynamics
    function updateImmersiveAudio() {
        if (!audioContext || !isFlying || !altitudeControl) return;

        // Get current altitude (0-1) from control
        const altitude = parseFloat(altitudeControl.value);

        // Calculate velocity based on plane direction
        const velocity = Math.sqrt(planeDirection.x * planeDirection.x + planeDirection.y * planeDirection.y);

        // Update engine hum based on velocity
        if (isEngineEnabled && engineOscillator && engineGain) {
            // Engine frequency increases with speed (55Hz to 85Hz)
            const engineFreq = 55 + velocity * 1500;
            engineOscillator.frequency.setValueAtTime(engineFreq, audioContext.currentTime);

            // Engine volume also increases slightly with speed
            const engineVol = 0.12 + velocity * 1.5;
            engineGain.gain.setValueAtTime(Math.min(engineVol, 0.25), audioContext.currentTime);
        }

        // Update wind noise based on velocity
        if (isWindEnabled && windNoiseGain && windNoiseFilter) {
            // Wind volume increases with speed
            const windVol = velocity * 0.8;
            windNoiseGain.gain.setValueAtTime(Math.min(windVol, 0.15), audioContext.currentTime);

            // Wind filter frequency also changes with speed
            const windFreq = 400 + velocity * 2000;
            windNoiseFilter.frequency.setValueAtTime(windFreq, audioContext.currentTime);
        }

        // Update cabin pressure filter based on altitude
        if (isCabinPressureEnabled && cabinPressureFilter) {
            // Higher altitude = lower filter cutoff (thinner air, muffled sound)
            // At altitude 0: full frequency (22050 Hz)
            // At altitude 1: reduced frequency (800 Hz)
            const filterFreq = 22050 - (altitude * 21250);
            cabinPressureFilter.frequency.setValueAtTime(filterFreq, audioContext.currentTime);
        }

        // Store last velocity for future use
        lastVelocity.x = planeDirection.x;
        lastVelocity.y = planeDirection.y;
    }

    // Apply filter preset
    function applyFilterPreset(e) {
        const presetName = e.target.value;
        if (!presetName || !filterPresets[presetName]) return;
        
        const preset = filterPresets[presetName];
        
        // Reset select to placeholder
        e.target.value = '';
        
        // Update UI controls to match preset
        filterCutoffControl.value = preset.cutoff;
        lfoRateControl.value = preset.lfoRate;
        lfoAmountControl.value = preset.lfoAmount;
        
        // Update labels
        document.getElementById('filterCutoffValue').textContent = `${preset.cutoff} Hz`;
        document.getElementById('lfoRateValue').textContent = `${lfoDivisions[preset.lfoRate].name}`;
        document.getElementById('lfoAmountValue').textContent = `${preset.lfoAmount}%`;
        
        // Enable filter if not enabled
        if (!isFilterEnabled) {
            filterToggle.checked = true;
            toggleFilter();
        }
        
        // Enable or disable LFO based on preset
        if (isLfoEnabled !== preset.enableLfo) {
            lfoToggle.checked = preset.enableLfo;
            toggleLFO();
        }
        
        // Apply filter settings
        updateFilterCutoff();
        updateLfoRate();
        updateLfoAmount();
        
        // Show announcement
        showStatus(`Applied ${preset.name} filter preset!`);
    }
    
    // Apply compressor preset
    function applyCompressorPreset(e) {
        const presetName = e.target.value;
        if (!presetName || !compressorPresets[presetName]) return;
        
        const preset = compressorPresets[presetName];
        
        // Reset select to placeholder
        e.target.value = '';
        
        // Update UI controls to match preset
        compThresholdControl.value = preset.threshold;
        compRatioControl.value = preset.ratio;
        compAttackControl.value = preset.attack;
        compReleaseControl.value = preset.release;
        
        // Update labels
        document.getElementById('compThresholdValue').textContent = `${preset.threshold} dB`;
        document.getElementById('compRatioValue').textContent = `${preset.ratio}:1`;
        document.getElementById('compAttackValue').textContent = `${preset.attack}s`;
        document.getElementById('compReleaseValue').textContent = `${preset.release}s`;
        
        // Enable compressor if not enabled
        if (!isCompressorEnabled) {
            compressorToggle.checked = true;
            toggleCompressor();
        }
        
        // Apply compressor settings
        updateCompressorThreshold();
        updateCompressorRatio();
        updateCompressorAttack();
        updateCompressorRelease();
        
        // Show announcement
        showStatus(`Applied ${preset.name} cabin pressure preset!`);
    }
    
    // Clear trail
    function clearTrail() {
        // Clear the permanent trail array
        smoothedTrail = [];
        
        // Clear the trail canvas
        if (trailCtx) trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
        
        // Show status message
        showStatus('Trail cleared!');
    }
    
    // Randomize all parameters
    function randomizeAll() {
        // Randomize audio parameters
        volumeControl.value = (0.05 + Math.random() * 0.2).toFixed(2); // Reduced maximum volume
        updateVolume();
        
        bassLevelControl.value = (0.4 + Math.random() * 0.6).toFixed(2); // Keep some bass but vary it
        updateBassLevel();
        
        decayControl.value = (1 + Math.random() * 9).toFixed(1);
        updateDecay();
        
        reverbControl.value = Math.random().toFixed(2);
        updateReverb();
        
        // Randomize flight parameters
        altitudeControl.value = (0.5 + Math.random() * 1.5).toFixed(2);
        updateAltitude();
        
        tempoControl.value = Math.floor(60 + Math.random() * 100); // More reasonable tempo range
        updateTempo();
        
        persistenceControl.value = Math.random().toFixed(2);
        updatePersistence();
        
        trailIntensityControl.value = (0.1 + Math.random() * 4.9).toFixed(1);
        updateTrailIntensity();
        
        // Randomize filter parameters
        filterCutoffControl.value = Math.floor(1000 + Math.random() * 19000);
        updateFilterCutoff();
        
        lfoRateControl.value = Math.floor(Math.random() * 8);
        updateLfoRate();
        
        lfoAmountControl.value = Math.floor(Math.random() * 100);
        updateLfoAmount();
        
        // Randomize compressor parameters
        compThresholdControl.value = Math.floor(-60 + Math.random() * 60);
        updateCompressorThreshold();
        
        compRatioControl.value = (1 + Math.random() * 19).toFixed(1);
        updateCompressorRatio();
        
        compAttackControl.value = Math.random().toFixed(2);
        updateCompressorAttack();
        
        compReleaseControl.value = Math.random().toFixed(2);
        updateCompressorRelease();
        
        // Randomly enable/disable effects
        const randomFilterEnabled = Math.random() > 0.5;
        filterToggle.checked = randomFilterEnabled;
        toggleFilter();
        
        if (randomFilterEnabled) {
            const randomLfoEnabled = Math.random() > 0.5;
            lfoToggle.checked = randomLfoEnabled;
            if (randomLfoEnabled) toggleLFO();
        }
        
        const randomCompEnabled = Math.random() > 0.5;
        compressorToggle.checked = randomCompEnabled;
        toggleCompressor();
        
        // Randomly select a destination
        const destinations = ['worldTour', 'asia', 'europe', 'africa', 'oceania', 'americas', 'impressionist', 'minimalist'];
        changeDestination(destinations[Math.floor(Math.random() * destinations.length)]);
        
        // Randomly select an artist
        const artists = ['brianeno', 'eriksatie', 'haroldbudd', 'starsofthelid', 'boardsofcanada', 
                         'williambasinski', 'stevereich', 'timhecker', 'ryuichisakamoto', 
                         'aphextwin', 'jonhopkins', 'various'];
        selectArtist(artists[Math.floor(Math.random() * artists.length)]);
        
        // Show announcement
        showStatus('All parameters randomized!');
    }
    
    // Select artist
    function selectArtist(artistId) {
        // Update artist name
        switch(artistId) {
            case 'brianeno':
                currentArtistName = 'Brian Eno';
                break;
            case 'eriksatie':
                currentArtistName = 'Erik Satie';
                break;
            case 'haroldbudd':
                currentArtistName = 'Harold Budd';
                break;
            case 'starsofthelid':
                currentArtistName = 'Stars of the Lid';
                break;
            case 'boardsofcanada':
                currentArtistName = 'Boards of Canada';
                break;
            case 'williambasinski':
                currentArtistName = 'William Basinski';
                break;
            case 'stevereich':
                currentArtistName = 'Steve Reich';
                break;
            case 'timhecker':
                currentArtistName = 'Tim Hecker';
                break;
            case 'ryuichisakamoto':
                currentArtistName = 'Ryuichi Sakamoto';
                break;
            case 'aphextwin':
                currentArtistName = 'Aphex Twin';
                break;
            case 'jonhopkins':
                currentArtistName = 'Jon Hopkins';
                break;
            case 'various':
            default:
                currentArtistName = 'Various Artists';
                artistId = 'various';
        }
        
        // Update UI
        document.getElementById('currentArtist').textContent = `Cabin music: ${currentArtistName}`;
        
        // Update artist info
        updateArtistInfo();
        
        // Update current artist
        currentArtist = artistId;
        
        // Update tempo and other parameters based on artist style
        if (artistStyles[artistId]) {
            // Update tempo if artist has specific tempo
    if (artistStyles[artistId].tempo && tempoControl) {
        tempoControl.value = artistStyles[artistId].tempo;
        updateTempo();
    }

    // Update decay if artist has specific decay
    if (artistStyles[artistId].decay && decayControl) {
        decayControl.value = artistStyles[artistId].decay;
        updateDecay();
    }

    // Update reverb if artist has specific reverb
    if (artistStyles[artistId].reverb && reverbControl) {
        reverbControl.value = artistStyles[artistId].reverb;
        updateReverb();
    }

    // Update musical notes based on artist style
    if (artistStyles[artistId].harmonicNotes) {
        harmonicNotes = artistStyles[artistId].harmonicNotes;
    }
    if (artistStyles[artistId].planeNotes) {
        planeNotes = artistStyles[artistId].planeNotes;
    }

    // Force sequencers to select new patterns with artist-specific notes
    if (sequencer1) sequencer1.selectPattern();
    if (sequencer2) sequencer2.selectPattern();

    // Track artist change in flight log
    trackArtistChange(currentArtistName);

    // Show status message
    showStatus(`Now playing music inspired by ${currentArtistName}.`);
}

// Change destination - make globally accessible
function changeDestination(destId) {
    // Update destination name
    switch(destId) {
        case 'worldTour':
            currentDestinationName = 'World Tour';
            break;
        case 'asia':
            currentDestinationName = 'Asia';
            break;
        case 'europe':
            currentDestinationName = 'Europe';
            break;
        case 'africa':
            currentDestinationName = 'Africa';
            break;
        case 'oceania':
            currentDestinationName = 'Oceania';
            break;
        case 'americas':
            currentDestinationName = 'Americas';
            break;
        case 'impressionist':
            currentDestinationName = 'Impressionist';
            break;
        case 'minimalist':
            currentDestinationName = 'Minimalist';
            break;
        default:
            currentDestinationName = 'World Tour';
            destId = 'worldTour';
    }
    
    // Update UI elements
    document.getElementById('currentDestination').textContent = `Destination: ${currentDestinationName}`;
    
    // Update button styling - remove selected class from all buttons
    destinationButtons.forEach(btn => {
        btn.classList.remove('selected');
    });
    
    // Find and add selected class to current destination button
    destinationButtons.forEach(btn => {
        if (btn.id.toLowerCase() === 'dest' + destId.toLowerCase()) {
            btn.classList.add('selected');
        }
    });
    
    // Update current destination
    currentDestination = destId;
    
    // Update musical scales based on destination
    if (musicalScales[destId]) {
        harmonicNotes = musicalScales[destId].harmonicNotes;
        planeNotes = musicalScales[destId].planeNotes;

        // Force sequencers to select new patterns
        if (sequencer1) sequencer1.selectPattern();
        if (sequencer2) sequencer2.selectPattern();
    }

    // Initialize gradient colors for new destination
    const palette = gradientPalettes[destId] || gradientPalettes.worldTour;
    const initialPalette = palette[0];
    currentGradientColors = {...initialPalette};
    targetGradientColors = {...initialPalette};

    // Show announcement about the destination change
    const announcementElement = document.getElementById('announcement');
    const announcementText = document.getElementById('announcementText');
    if (announcementElement && announcementText) {
        announcementText.textContent = `We're now embarking on a journey to ${currentDestinationName}.`;
        announcementElement.style.display = 'block';
        announcementElement.style.opacity = '1';
        
        // Hide announcement after delay
        setTimeout(() => {
            fadeOutAnnouncement();
        }, 7000);
    }

    // Track destination change in flight log
    trackDestinationChange(currentDestinationName);

    // Show status message
    showStatus(`Flight route changed to ${currentDestinationName}.`);
}
// Assign to window immediately - NO conditions
window.changeDestination = changeDestination;

// Emergency eject function
function emergencyEject() {
    try {
        console.log('⚠️ EMERGENCY EJECT activated ⚠️');
        
        // First stop all audio
        if (audioContext) {
            // Clear all active oscillators
            if (activeOscillators && activeOscillators.length > 0) {
                activeOscillators.forEach(osc => {
                    try {
                        osc.stop();
                        osc.disconnect();
                    } catch (e) {
                        console.warn('Error stopping oscillator:', e);
                    }
                });
                activeOscillators = [];
            }
            
            // Stop LFO if it's active
            if (lfoOscillator) {
                try {
                    lfoOscillator.stop();
                    lfoOscillator.disconnect();
                    lfoOscillator = null;
                } catch (e) {
                    console.warn('Error stopping LFO:', e);
                }
            }
            
            // Disconnect and recreate master gain to cut all audio
            if (masterGainNode) {
                try {
                    masterGainNode.disconnect();
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    setupAudioChain(); // Reconnect with zero gain
                } catch (e) {
                    console.warn('Error recreating master gain:', e);
                }
            }
            
            // Suspend audio context
            audioContext.suspend().then(() => {
                console.log('AudioContext suspended by emergency eject');
            }).catch(e => {
                console.warn('Error suspending AudioContext:', e);
            });
        }
        
        // Stop flight
        isFlying = false;

        // Stop BPM sync
        stopBPMSync();

        // Reset UI
        takeoffButton.disabled = false;
        landButton.disabled = true;
        
        // Clear sequencers
        if (sequencer1) {
            sequencer1.stop();
            sequencer1 = null;
        }
        
        if (sequencer2) {
            sequencer2.stop();
            sequencer2 = null;
        }
        
        // Stop timers
        if (flightTimerInterval) clearInterval(flightTimerInterval);
        if (audioUpdateInterval) clearInterval(audioUpdateInterval);
        
        showStatus('<strong>EMERGENCY EJECT ACTIVATED</strong><br>All audio systems shut down');
        
        // Show an announcement
        const announcementElement = document.getElementById('announcement');
        const announcementText = document.getElementById('announcementText');
        if (announcementElement && announcementText) {
            announcementText.innerHTML = '<strong>EMERGENCY EJECT ACTIVATED</strong><br>All audio systems have been shut down. Click "Take Off" to restart when ready.';
            announcementElement.style.display = 'block';
            announcementElement.style.opacity = '1';
            
            // Keep the announcement visible until clicked
            if (announcementTimer) clearTimeout(announcementTimer);
        }
    } catch (error) {
        console.error('Error in emergency eject:', error);
    }
}

// ============================================================================
// INTERACTIVE MAP NOTE PLAYING
// ============================================================================

// Play a note based on click/tap position on the map
function playInteractiveNote(normalizedX, normalizedY) {
    try {
        if (!audioContext || audioContext.state !== 'running') {
            console.warn('AudioContext not available for interactive note');
            return;
        }

        // Get current pattern from sequencer1 if available, otherwise use a default scale
        let pattern = sequencer1 && sequencer1.currentPattern
            ? sequencer1.currentPattern
            : [0, 2, 4, 5, 7, 9, 11, 12]; // Default to major scale

        // Map Y position (top to bottom) to note index in pattern
        // Top = highest note, bottom = lowest note
        const noteIndex = Math.floor((1 - normalizedY) * pattern.length);
        const clampedIndex = Math.max(0, Math.min(pattern.length - 1, noteIndex));
        const noteValue = pattern[clampedIndex];

        // Map X position to base frequency
        // Left = lower octave, right = higher octave
        const baseFreqMultiplier = 0.5 + (normalizedX * 1.5); // Range from 0.5x to 2x
        const altitude = parseFloat(altitudeControl?.value || 1);
        const baseFreq = 261.63 * altitude * baseFreqMultiplier; // Middle C adjusted

        // Calculate final frequency
        let frequency;
        if (typeof noteValue === 'number' && noteValue < 100) {
            // It's a semitone interval - convert to frequency
            frequency = baseFreq * Math.pow(2, noteValue / 12);
        } else {
            // It's already a frequency
            frequency = noteValue * baseFreqMultiplier;
        }

        // Clamp to safe range
        frequency = Math.min(20000, Math.max(safeLowFreq, frequency));

        // Get settings from controls
        const decayTime = parseFloat(decayControl?.value || 3);
        const volume = parseFloat(volumeControl?.value || 0.15) * 1.2; // Slightly louder for interactive notes

        // Create oscillator for the note
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        // Use a pleasant waveform
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

        // Quick attack, long decay
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + decayTime);

        // Connect to master gain (includes all effects)
        oscillator.connect(gainNode);
        gainNode.connect(masterGainNode);

        // Play the note
        oscillator.start();
        oscillator.stop(audioContext.currentTime + decayTime);

        // Flash plane lights in response
        flashPlaneLights(frequency);

        logDebug('INTERACTIVE', `Played note at ${frequency.toFixed(2)}Hz from position (${(normalizedX * 100).toFixed(0)}%, ${(normalizedY * 100).toFixed(0)}%)`);

    } catch (error) {
        console.error('Error playing interactive note:', error);
    }
}
// Assign to window immediately - NO conditions
window.playInteractiveNote = playInteractiveNote;

// Create visual ripple effect at click position
function createClickRipple(x, y) {
    if (!noteCircles) return;

    // Map click position to note color
    const normalizedX = x / flightCanvas.width;
    const colorIndex = Math.floor(normalizedX * colors.notes.length) % colors.notes.length;
    const rippleColor = colors.notes[colorIndex];

    // Create multiple expanding circles for ripple effect
    for (let i = 0; i < 3; i++) {
        setTimeout(() => {
            const circle = {
                x: x,
                y: y,
                radius: 5,
                maxRadius: 40 + (i * 15),
                color: rippleColor,
                opacity: 0.8 - (i * 0.2),
                growRate: 1.2 + (i * 0.3),
                sequencerId: 0 // Special ID for interactive notes
            };
            noteCircles.push(circle);
        }, i * 50); // Stagger the ripples
    }

    logDebug('INTERACTIVE', `Created click ripple at (${x}, ${y})`);
}
// Assign to window immediately - NO conditions
window.createClickRipple = createClickRipple;

// Test audio with a simple note
function testAudio() {
    try {
        // Initialize audio if not already done
        if (!audioContext) {
            initializeAudio();
        }

        // Resume audio context if suspended
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log('AudioContext resumed in testAudio');
                playTestTone();
            }).catch(err => {
                console.error('Failed to resume AudioContext in testAudio:', err);
                showStatus('Failed to resume cabin audio system. Try clicking the Take Off button.');
            });
        } else {
            playTestTone();
        }
    } catch (error) {
        console.error('Test audio error:', error);
        showStatus('Test audio error: ' + error.message);
    }
}
// Assign to window immediately - NO conditions
window.testAudio = testAudio;

// Play a test tone
function playTestTone() {
    try {
        if (!audioContext || !masterGainNode) {
            showStatus('Cabin audio system not initialized');
            return;
        }
        
        // Create a simple test tone
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        // Alternate between sine and triangle
        oscillator.type = Math.random() < 0.5 ? 'sine' : 'triangle';
        
        // Use a pleasant frequency
        const testFreq = 440 + Math.random() * 220;
        oscillator.frequency.setValueAtTime(testFreq, audioContext.currentTime);
        
        // Use current volume control value
        const volume = parseFloat(volumeControl.value);
        
        // Create amplitude envelope with nice fade in/out
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.1);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);
        
        // Connect nodes to the master gain (which has all safety nodes in chain)
        oscillator.connect(gainNode);
        gainNode.connect(masterGainNode);
        
        // Start and stop oscillator
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 2);
        
        // Show indication that sound is playing
        const testFreqRounded = Math.round(testFreq);
        showStatus(`Cabin audio check: ${testFreqRounded} Hz`);
        
        // Create visual feedback
        if (flightCanvas && noteCtx) {
            const circle = {
                x: flightCanvas.width / 2,
                y: flightCanvas.height / 2,
                radius: 5,
                maxRadius: 80,
                color: '#2ecc71',
                opacity: 0.8,
                growRate: 1
            };
            
            noteCircles.push(circle);
            
            // Draw the visualization even if not flying
            const drawTestVisual = () => {
                if (circle.radius <= circle.maxRadius) {
                    noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
                    
                    circle.radius += circle.growRate;
                    circle.opacity -= 0.01;
                    
                    noteCtx.beginPath();
                    noteCtx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                    noteCtx.strokeStyle = adjustOpacity('#2ecc71', circle.opacity);
                    noteCtx.lineWidth = 2;
                    noteCtx.stroke();
                    
                    requestAnimationFrame(drawTestVisual);
                } else {
                    // Clear when done
                    noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
                }
            };
            
            drawTestVisual();
        }
    } catch (error) {
        console.error('Play test tone error:', error);
        showStatus('Cabin audio test error: ' + error.message);
    }
}

// Take off function - make globally accessible
function takeOff() {
    logInfo('FLIGHT', '═══════════════════════════════════════════════');
    logInfo('FLIGHT', 'TAKEOFF SEQUENCE INITIATED');
    logInfo('FLIGHT', '═══════════════════════════════════════════════');

    startTimer('takeoff_sequence');

    try {
        // Check if already flying
        if (isFlying) {
            logWarn('FLIGHT', 'Takeoff requested but already flying');
            showStatus('Already in flight!', 'warning');
            return;
        }

        // Initialize audio if not already done
        if (!audioContext) {
            logInfo('AUDIO', 'Audio context not initialized, initializing now');
            initializeAudio();
        } else {
            logDebug('AUDIO', 'Audio context exists', { state: audioContext.state });
        }

        // Resume audio context if suspended
        if (audioContext && audioContext.state === 'suspended') {
            logInfo('AUDIO', 'Resuming suspended audio context');
            audioContext.resume().then(() => {
                logInfo('AUDIO', 'Audio context resumed successfully');
                continueWithTakeoff();
            }).catch(err => {
                logError('AUDIO', 'Failed to resume audio context', err);
                showStatus('⚠️ Audio may not work correctly', 'warning');
                // Try anyway
                continueWithTakeoff();
            });
        } else {
            continueWithTakeoff();
        }
    } catch (error) {
        logError('FLIGHT', 'Takeoff sequence failed', error);
        showStatus('Take off aborted: ' + error.message, 'error');
        endTimer('takeoff_sequence');
    }
}
// Assign to window immediately - NO conditions
window.takeOff = takeOff;

// Continue with takeoff after audio context is ready
function continueWithTakeoff() {
    logDebug('FLIGHT', 'Continuing takeoff sequence');

    if (isFlying) {
        logWarn('FLIGHT', 'Already flying, aborting takeoff');
        return;
    }

    const previousState = isFlying;
    isFlying = true;
    logStateChange('FLIGHT', 'isFlying', previousState, isFlying);

    // Reset flight start time
    flightStartTime = Date.now();
    lastAnnouncementTime = Date.now();
    pathStartTime = Date.now();

    logInfo('FLIGHT', 'Flight timers reset', {
        flightStartTime: new Date(flightStartTime).toISOString()
    });

    // Disable takeoff button, enable land button
    takeoffButton.disabled = true;
    landButton.disabled = false;
    logDebug('UI', 'Button states updated: takeoff disabled, land enabled');

    // Start flight visualization
    logDebug('FLIGHT', 'Starting flight visualization');
    startFlightVisualization();

    // Start BPM-synced animations
    logDebug('FLIGHT', 'Starting BPM-synced animations');
    startBPMSync();

    // Fade in master volume over 1 second
    if (masterGainNode && audioContext) {
        const targetVolume = parseFloat(volumeControl.value);
        masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
        masterGainNode.gain.linearRampToValueAtTime(targetVolume, audioContext.currentTime + 1);
        logDebug('AUDIO', `Fading in volume to ${targetVolume}`);
    } else {
        logWarn('AUDIO', 'Master gain node not available for volume fade');
    }

        // Initialize or restart immersive audio features
        if (isEngineEnabled) {
            if (!engineOscillator) {
                setupEngineHum();
            } else if (engineGain && audioContext) {
                // Fade back in if already exists
                engineGain.gain.setValueAtTime(0, audioContext.currentTime);
                engineGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 1);
            }
        }
        if (isWindEnabled) {
            if (!windNoiseNode) {
                setupWindNoise();
            } else if (windNoiseGain && audioContext) {
                // Wind starts at 0 and increases with velocity
                windNoiseGain.gain.setValueAtTime(0, audioContext.currentTime);
            }
        }
        if (isCabinPressureEnabled) {
            if (!cabinPressureFilter) {
                setupCabinPressureFilter();
            } else if (audioContext) {
                // Reset filter to open when taking off
                cabinPressureFilter.frequency.setValueAtTime(22050, audioContext.currentTime);
            }
        }

        // To ensure the plane starts with enough momentum
        planeDirection.x = 0.02;
        planeDirection.y = 0.01;

        // Start flight log session
        startFlightLog();

        // Display initial announcement
        const announcementElement = document.getElementById('announcement');
        const announcementText = document.getElementById('announcementText');
        if (announcementElement && announcementText) {
            announcementText.textContent = `Welcome aboard our flight to ${currentDestinationName}, inspired by ${currentArtistName}. We're taking off into our ambient journey.`;
            announcementElement.style.display = 'block';
            announcementElement.style.opacity = '1';
            
            // Hide announcement after delay
            setTimeout(() => {
                fadeOutAnnouncement();
            }, 7000);
        }
        
        // Log final configuration
        logInfo('FLIGHT', 'Flight configuration', {
            destination: currentDestinationName,
            artist: currentArtistName,
            tempo: tempoControl.value,
            altitude: altitudeControl.value,
            volume: volumeControl.value
        });

        // Show takeoff message
        showStatus('Taking off into ambient soundscape...');

        // Start updating flight info
        startFlightTimer();

        const duration = endTimer('takeoff_sequence');
        logInfo('FLIGHT', `✓ Takeoff complete in ${duration}ms`);
        logInfo('FLIGHT', '═══════════════════════════════════════════════');
    }
}

// Land function - make globally accessible
function land() {
    logInfo('FLIGHT', 'Land requested');

    if (!isFlying) {
        logWarn('FLIGHT', 'Land requested but not flying');
        showStatus('Not currently in flight', 'warning');
        return;
    }

    logDebug('FLIGHT', 'Showing landing destination selector');
    showLandingSelector();
}
// Ensure function is accessible via window object
window.land = land;

// Show landing destination selector
function showLandingSelector() {
    const landingOverlay = document.getElementById('landingOverlay');
    if (landingOverlay) {
        landingOverlay.classList.remove('hidden');
        showStatus('Choose your destination...');
    }
}

// Hide landing selector
function hideLandingSelector() {
    const landingOverlay = document.getElementById('landingOverlay');
    if (landingOverlay) {
        landingOverlay.classList.add('hidden');
    }
}

// Complete landing at selected destination
function completeLanding(spaceKey) {
    logInfo('FLIGHT', '═══════════════════════════════════════════════');
    logInfo('FLIGHT', 'LANDING SEQUENCE INITIATED');
    logInfo('FLIGHT', '═══════════════════════════════════════════════');

    startTimer('landing_sequence');

    if (!isFlying) {
        logWarn('FLIGHT', 'Landing requested but not flying');
        return;
    }

    try {
        const previousFlyingState = isFlying;
        const previousLandedState = isLanded;

        isFlying = false;
        isLanded = true;
        currentLandingSpace = spaceKey;

        // Stop BPM sync
        stopBPMSync();

        logStateChange('FLIGHT', 'isFlying', previousFlyingState, isFlying);
        logStateChange('FLIGHT', 'isLanded', previousLandedState, isLanded);

        const space = destinationSpaces[spaceKey];
        logInfo('FLIGHT', `Landing at: ${space.name}`, space);
        showStatus(`Landing at ${space.name}...`);

        // End flight log session
        endFlightLog(space.name);

        // Hide the selector
        hideLandingSelector();

        // Update button states
        takeoffButton.disabled = false;
        landButton.disabled = true;

        // Stop flight visualization
        stopFlightVisualization();

        // Stop flight timer
        stopFlightTimer();

        // Clear cities
        clearActiveCities();

        // Reset plane position to center
        planePosition = { x: 50, y: 50 };
        planeDirection = { x: 0, y: 0 };

        // Position plane in center
        if (plane && flightCanvas) {
            const planeCenterX = (flightCanvas.width / 2) - (plane.offsetWidth / 2);
            const planeCenterY = (flightCanvas.height / 2) - (plane.offsetHeight / 2);
            plane.style.left = `${planeCenterX}px`;
            plane.style.top = `${planeCenterY}px`;
            plane.style.transform = 'rotate(0deg)';
        }

        // Reset flight time
        const flightTimeEl = document.getElementById('flightTime');
        if (flightTimeEl) {
            flightTimeEl.textContent = '00:00:00';
        }

        // Apply landing space atmosphere
        applyLandingAtmosphere(spaceKey);

        // Fade out announcement if visible
        fadeOutAnnouncement();

        setTimeout(() => {
            showStatus(`Welcome to ${space.name}. Press Take Off to depart.`);
        }, 2000);

        const duration = endTimer('landing_sequence');
        logInfo('FLIGHT', `✓ Landing complete in ${duration}ms`);
        logInfo('FLIGHT', '═══════════════════════════════════════════════');

    } catch (error) {
        logError('FLIGHT', 'Landing sequence failed', error);
        showStatus('Landing error: ' + error.message, 'error');
        endTimer('landing_sequence');
    }
}

// Apply landing atmosphere
function applyLandingAtmosphere(spaceKey) {
    const space = destinationSpaces[spaceKey];
    if (!space) return;

    // Get atmosphere settings
    const time = timeSettings[currentTime];
    const weather = weatherSettings[currentWeather];
    const season = seasonSettings[currentSeason];

    // Apply space colors to the scene
    if (landscapeCtx && landscapeCanvas) {
        landscapeCtx.clearRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);

        // Fill with space colors
        const gradient = landscapeCtx.createLinearGradient(0, 0, 0, landscapeCanvas.height);
        gradient.addColorStop(0, space.colors.ceiling);
        gradient.addColorStop(0.3, space.colors.walls);
        gradient.addColorStop(0.7, space.colors.walls);
        gradient.addColorStop(1, space.colors.floor);

        landscapeCtx.fillStyle = gradient;
        landscapeCtx.fillRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);

        // Add time-based lighting overlay
        landscapeCtx.fillStyle = time.lightColor;
        landscapeCtx.globalAlpha = 0.1 * time.lightIntensity;
        landscapeCtx.fillRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);
        landscapeCtx.globalAlpha = 1.0;

        // Add text overlay with space info
        landscapeCtx.fillStyle = space.colors.accent;
        landscapeCtx.font = '24px -apple-system, sans-serif';
        landscapeCtx.textAlign = 'center';
        landscapeCtx.fillText(space.name, landscapeCanvas.width / 2, landscapeCanvas.height / 2 - 40);

        landscapeCtx.font = '14px -apple-system, sans-serif';
        landscapeCtx.fillStyle = adjustOpacity(space.colors.accent, 0.7);
        landscapeCtx.fillText(space.description, landscapeCanvas.width / 2, landscapeCanvas.height / 2);

        landscapeCtx.fillText(`${time.name} | ${weather.name} | ${season.name}`,
            landscapeCanvas.width / 2, landscapeCanvas.height / 2 + 30);
    }

    // Apply audio settings
    if (audioContext && masterGainNode) {
        // Calculate combined tempo modifier
        const combinedTempo = space.tempoModifier * time.tempoModifier * weather.soundModifier * season.soundModifier;

        // Apply reverb setting
        if (reverbControl) {
            reverbControl.value = space.reverb;
            updateReverb();
        }

        // Adjust tempo
        if (tempoControl) {
            const currentTempo = parseFloat(tempoControl.value);
            const newTempo = Math.max(0.3, Math.min(2.0, currentTempo * combinedTempo));
            tempoControl.value = newTempo;
            updateTempo();
        }

        // Gently fade in audio with new settings
        masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
        masterGainNode.gain.linearRampToValueAtTime(
            parseFloat(volumeControl.value) * 0.6,
            audioContext.currentTime + 3
        );
    }

    // Clear trails and particles
    planeTrail = [];
    smoothedTrail = [];
    if (trailCtx) {
        trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
    }

    // Initialize landing particles based on season
    initializeLandingParticles(season.particleType, weather.particleCount);

    // Start landed animation loop
    animateLandedState();

    console.log(`Landed at ${space.name} - ${time.name}, ${weather.name}, ${season.name}`);
}

// ============================================
// FLIGHT LOG SYSTEM
// ============================================

// Start a new flight log session
function startFlightLog() {
    flightSessionActive = true;
    const now = new Date();

    flightLog = {
        flightNumber: `MA${String(logCounter).padStart(4, '0')}`,
        departureTime: now,
        arrivalTime: null,
        totalFlightTime: 0,
        events: [],
        destinations: [],
        artists: [],
        effectsUsed: [],
        notesPlayed: 0,
        citiesVisited: new Set(),
        altitudeRange: { min: 1.0, max: 1.0 },
        currentSegmentStart: now,
        currentDestination: currentDestinationName,
        currentArtistName: currentArtistName
    };

    logCounter++;

    // Log takeoff event
    addLogEvent('takeoff', `Departed on flight to ${currentDestinationName}, cabin music by ${currentArtistName}`);

    // Track initial destination and artist
    flightLog.destinations.push({
        name: currentDestinationName,
        startTime: now,
        duration: 0
    });

    flightLog.artists.push({
        name: currentArtistName,
        startTime: now,
        duration: 0
    });
}

// End the flight log session
function endFlightLog(landingLocation) {
    if (!flightSessionActive) return;

    const now = new Date();
    flightLog.arrivalTime = now;
    flightLog.totalFlightTime = Math.floor((now - flightLog.departureTime) / 1000);

    // Update last destination duration
    if (flightLog.destinations.length > 0) {
        const lastDest = flightLog.destinations[flightLog.destinations.length - 1];
        lastDest.duration = Math.floor((now - lastDest.startTime) / 1000);
    }

    // Update last artist duration
    if (flightLog.artists.length > 0) {
        const lastArtist = flightLog.artists[flightLog.artists.length - 1];
        lastArtist.duration = Math.floor((now - lastArtist.startTime) / 1000);
    }

    // Log landing event
    addLogEvent('landing', `Arrived at ${landingLocation || 'destination'}`);

    flightSessionActive = false;
}

// Add an event to the flight log
function addLogEvent(eventType, description, details = {}) {
    const now = new Date();
    const timestamp = flightSessionActive && flightLog.departureTime
        ? Math.floor((now - flightLog.departureTime) / 1000)
        : 0;

    flightLog.events.push({
        type: eventType,
        timestamp: timestamp,
        description: description,
        time: now,
        details: details
    });
}

// Track destination change
function trackDestinationChange(newDestination) {
    if (!flightSessionActive) return;

    const now = new Date();

    // Close out previous destination
    if (flightLog.destinations.length > 0) {
        const lastDest = flightLog.destinations[flightLog.destinations.length - 1];
        lastDest.duration = Math.floor((now - lastDest.startTime) / 1000);
    }

    // Add new destination
    flightLog.destinations.push({
        name: newDestination,
        startTime: now,
        duration: 0
    });

    flightLog.currentDestination = newDestination;
    addLogEvent('destination_change', `Route changed to ${newDestination}`);
}

// Track artist change
function trackArtistChange(newArtist) {
    if (!flightSessionActive) return;

    const now = new Date();

    // Close out previous artist
    if (flightLog.artists.length > 0) {
        const lastArtist = flightLog.artists[flightLog.artists.length - 1];
        lastArtist.duration = Math.floor((now - lastArtist.startTime) / 1000);
    }

    // Add new artist
    flightLog.artists.push({
        name: newArtist,
        startTime: now,
        duration: 0
    });

    flightLog.currentArtistName = newArtist;
    const initials = getArtistInitials(newArtist);
    addLogEvent('artist_change', `Cabin music changed to ${initials}`);
}

// Track altitude changes
function trackAltitude(altitude) {
    if (!flightSessionActive) return;

    if (altitude < flightLog.altitudeRange.min) {
        flightLog.altitudeRange.min = altitude;
    }
    if (altitude > flightLog.altitudeRange.max) {
        flightLog.altitudeRange.max = altitude;
    }
}

// Track note play
function trackNotePlayed() {
    if (flightSessionActive) {
        flightLog.notesPlayed++;
    }
}

// Format duration in seconds to readable format
function formatDuration(seconds) {
    if (seconds < 60) {
        return `${seconds}s`;
    } else if (seconds < 3600) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}m ${secs}s`;
    } else {
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        return `${hours}h ${mins}m ${secs}s`;
    }
}

// Format timestamp for display
function formatTimestamp(date) {
    if (!date) return 'N/A';
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
}

// Format relative timestamp
function formatRelativeTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `+${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
}

// Convert artist name to initials
function getArtistInitials(artistName) {
    const initialsMap = {
        'Brian Eno': 'BE',
        'Erik Satie': 'ES',
        'Harold Budd': 'HB',
        'Stars of the Lid': 'SOTL',
        'Boards of Canada': 'BOC',
        'William Basinski': 'WB',
        'Steve Reich': 'SR',
        'Tim Hecker': 'TH',
        'Ryuichi Sakamoto': 'RS',
        'Aphex Twin': 'AT',
        'Jon Hopkins': 'JH',
        'Various Artists': 'VA'
    };
    return initialsMap[artistName] || artistName.split(' ').map(word => word[0]).join('');
}

// Generate the flight log HTML
function generateFlightLog() {
    const panel = document.getElementById('flightLogPanel');
    if (!panel) return;

    // Build the log HTML
    let html = `
        <div class="flight-log-header">
            <h2>✈ FLIGHT LOG: ${flightLog.flightNumber || 'N/A'}</h2>
            <button onclick="hideFlightLog()" class="log-close-btn">✕</button>
        </div>

        <div class="log-content">
            <!-- Flight Summary -->
            <div class="log-section">
                <h3>FLIGHT SUMMARY</h3>
                <div class="log-info-grid">
                    <div class="log-info-item">
                        <span class="log-label">Departure Time:</span>
                        <span class="log-value">${formatTimestamp(flightLog.departureTime)}</span>
                    </div>
                    <div class="log-info-item">
                        <span class="log-label">Arrival Time:</span>
                        <span class="log-value">${formatTimestamp(flightLog.arrivalTime)}</span>
                    </div>
                    <div class="log-info-item">
                        <span class="log-label">Total Flight Time:</span>
                        <span class="log-value">${formatDuration(flightLog.totalFlightTime)}</span>
                    </div>
                    <div class="log-info-item">
                        <span class="log-label">Status:</span>
                        <span class="log-value">${flightSessionActive ? 'IN FLIGHT' : 'COMPLETED'}</span>
                    </div>
                </div>
            </div>

            <!-- Statistics -->
            <div class="log-section">
                <h3>FLIGHT STATISTICS</h3>
                <div class="log-stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">NOTES PLAYED</div>
                        <div class="stat-value">${flightLog.notesPlayed}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ROUTES FLOWN</div>
                        <div class="stat-value">${flightLog.destinations.length}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">CABIN ARTISTS</div>
                        <div class="stat-value">${flightLog.artists.length}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ALTITUDE RANGE</div>
                        <div class="stat-value">${flightLog.altitudeRange.min.toFixed(2)} - ${flightLog.altitudeRange.max.toFixed(2)}</div>
                    </div>
                </div>
            </div>

            <!-- Destinations -->
            <div class="log-section">
                <h3>FLIGHT ROUTES</h3>
    `;

    if (flightLog.destinations.length > 0) {
        flightLog.destinations.forEach((dest, index) => {
            html += `
                <div class="timeline-event">
                    <div class="event-marker">${index + 1}</div>
                    <div class="event-content">
                        <div class="event-title">${dest.name}</div>
                        <div class="event-detail">Duration: ${formatDuration(dest.duration)}</div>
                    </div>
                </div>
            `;
        });
    } else {
        html += `<div class="log-empty">No routes recorded</div>`;
    }

    html += `
            </div>

            <!-- Artists / Music -->
            <div class="log-section">
                <h3>CABIN MUSIC PROGRAM</h3>
    `;

    if (flightLog.artists.length > 0) {
        flightLog.artists.forEach((artist, index) => {
            html += `
                <div class="timeline-event">
                    <div class="event-marker">♫</div>
                    <div class="event-content">
                        <div class="event-title">${getArtistInitials(artist.name)}</div>
                        <div class="event-detail">Duration: ${formatDuration(artist.duration)}</div>
                    </div>
                </div>
            `;
        });
    } else {
        html += `<div class="log-empty">No music program recorded</div>`;
    }

    html += `
            </div>

            <!-- Events Timeline -->
            <div class="log-section">
                <h3>FLIGHT EVENTS</h3>
    `;

    if (flightLog.events.length > 0) {
        flightLog.events.forEach((event, index) => {
            const eventIcon = event.type === 'takeoff' ? '🛫' :
                            event.type === 'landing' ? '🛬' :
                            event.type === 'destination_change' ? '🗺' :
                            event.type === 'artist_change' ? '♫' : '•';

            html += `
                <div class="timeline-event">
                    <div class="event-time">${formatRelativeTime(event.timestamp)}</div>
                    <div class="event-marker">${eventIcon}</div>
                    <div class="event-content">
                        <div class="event-description">${event.description}</div>
                    </div>
                </div>
            `;
        });
    } else {
        html += `<div class="log-empty">No events recorded</div>`;
    }

    html += `
            </div>
        </div>

        <div class="log-actions">
            <button onclick="downloadFlightLog()" class="log-action-btn">Download Log</button>
            <button onclick="hideFlightLog()" class="log-action-btn">Close</button>
        </div>
    `;

    panel.innerHTML = html;
}

// Show the flight log overlay
function showFlightLog() {
    generateFlightLog();
    const overlay = document.getElementById('flightLogOverlay');
    if (overlay) {
        overlay.classList.remove('hidden');
    }
}

// Hide the flight log overlay
function hideFlightLog() {
    const overlay = document.getElementById('flightLogOverlay');
    if (overlay) {
        overlay.classList.add('hidden');
    }
}

// Download flight log as text file
function downloadFlightLog() {
    let logText = `═══════════════════════════════════════════════════════════════\n`;
    logText += `            MUSIC FOR AIRPLANES - FLIGHT LOG\n`;
    logText += `═══════════════════════════════════════════════════════════════\n\n`;
    logText += `Flight Number: ${flightLog.flightNumber || 'N/A'}\n`;
    logText += `Departure Time: ${formatTimestamp(flightLog.departureTime)}\n`;
    logText += `Arrival Time: ${formatTimestamp(flightLog.arrivalTime)}\n`;
    logText += `Total Flight Time: ${formatDuration(flightLog.totalFlightTime)}\n`;
    logText += `Status: ${flightSessionActive ? 'IN FLIGHT' : 'COMPLETED'}\n\n`;

    logText += `───────────────────────────────────────────────────────────────\n`;
    logText += `FLIGHT STATISTICS\n`;
    logText += `───────────────────────────────────────────────────────────────\n`;
    logText += `Notes Played: ${flightLog.notesPlayed}\n`;
    logText += `Routes Flown: ${flightLog.destinations.length}\n`;
    logText += `Cabin Artists: ${flightLog.artists.length}\n`;
    logText += `Altitude Range: ${flightLog.altitudeRange.min.toFixed(2)} - ${flightLog.altitudeRange.max.toFixed(2)}\n\n`;

    logText += `───────────────────────────────────────────────────────────────\n`;
    logText += `FLIGHT ROUTES\n`;
    logText += `───────────────────────────────────────────────────────────────\n`;
    flightLog.destinations.forEach((dest, index) => {
        logText += `${index + 1}. ${dest.name} - Duration: ${formatDuration(dest.duration)}\n`;
    });
    logText += `\n`;

    logText += `───────────────────────────────────────────────────────────────\n`;
    logText += `CABIN MUSIC PROGRAM\n`;
    logText += `───────────────────────────────────────────────────────────────\n`;
    flightLog.artists.forEach((artist, index) => {
        logText += `${index + 1}. ${artist.name} - Duration: ${formatDuration(artist.duration)}\n`;
    });
    logText += `\n`;

    logText += `───────────────────────────────────────────────────────────────\n`;
    logText += `FLIGHT EVENTS\n`;
    logText += `───────────────────────────────────────────────────────────────\n`;
    flightLog.events.forEach((event) => {
        logText += `[${formatRelativeTime(event.timestamp)}] ${event.description}\n`;
    });
    logText += `\n`;

    logText += `═══════════════════════════════════════════════════════════════\n`;
    logText += `End of Flight Log\n`;
    logText += `═══════════════════════════════════════════════════════════════\n`;

    // Create and download file
    const blob = new Blob([logText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `FlightLog_${flightLog.flightNumber}_${formatTimestamp(flightLog.departureTime).replace(/:/g, '-')}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showStatus('Flight log downloaded');
}

// Animation loop for landed state
function animateLandedState() {
    if (!isLanded) return;

    // Redraw the landing atmosphere
    drawLandscape();

    // Continue animation
    requestAnimationFrame(animateLandedState);
}

// Initialize landing particles
function initializeLandingParticles(particleType, count) {
    landingParticles = [];
    if (count === 0) return;

    // Set ground level based on canvas height
    groundY = (landscapeCanvas?.height || 600) * 0.85; // 85% down the screen

    // Get current scale notes for musical particles
    const scaleNotes = destinations[currentDestination]?.harmonicNotes || destinations.worldTour.harmonicNotes;

    for (let i = 0; i < count; i++) {
        const isMusical = isMusicalParticlesEnabled && Math.random() < particleDensity;
        const note = isMusical ? scaleNotes[Math.floor(Math.random() * scaleNotes.length)][Math.floor(Math.random() * scaleNotes[0].length)] : null;

        landingParticles.push({
            x: Math.random() * (landscapeCanvas?.width || 800),
            y: Math.random() * -200, // Start above screen
            vx: (Math.random() - 0.5) * 2,
            vy: Math.random() * 0.5 + 0.5, // Initial fall speed
            size: Math.random() * 3 + 1,
            opacity: Math.random() * 0.5 + 0.3,
            type: particleType,
            isMusical: isMusical,
            note: note,
            hasPlayed: false,
            resting: false,
            fadeTime: 0,
            gravity: isMusical ? particleGravity : 1.0,
            sway: Math.random() * Math.PI * 2, // For swaying motion
            swaySpeed: 0.02 + Math.random() * 0.03,
            collisionCooldown: 0
        });
    }
}

// Play a note for a particle
function playParticleNote(particle) {
    if (!audioContext || !particle.isMusical || !particle.note) return;

    try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(particle.note, audioContext.currentTime);

        // Pan based on x position
        const panValue = ((particle.x / (landscapeCanvas?.width || 800)) - 0.5) * 2;
        const panNode = audioContext.createStereoPanner();
        panNode.pan.setValueAtTime(panValue, audioContext.currentTime);

        // Velocity based on fall speed
        const velocity = Math.min(1, particle.vy / 5) * 0.3; // Quieter than main notes

        // Soft attack and decay like falling leaves
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(velocity, audioContext.currentTime + particleAttack);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + particleRelease);

        // Connect: oscillator -> gain -> pan -> master
        oscillator.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(masterGainNode);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + particleRelease);

        particle.hasPlayed = true;

        // Log occasionally
        if (Math.random() < 0.1) {
            console.log('Particle landed:', particle.type, 'note:', particle.note.toFixed(2) + 'Hz');
        }
    } catch (error) {
        console.error('Error playing particle note:', error);
    }
}

// Play rustle sound for particle collision
function playParticleRustle(particle) {
    if (!audioContext || !isMusicalParticlesEnabled) return;

    try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filterNode = audioContext.createBiquadFilter();

        oscillator.type = 'triangle';
        const rustleFreq = 800 + Math.random() * 1200; // 800-2000 Hz
        oscillator.frequency.setValueAtTime(rustleFreq, audioContext.currentTime);

        filterNode.type = 'bandpass';
        filterNode.frequency.setValueAtTime(rustleFreq, audioContext.currentTime);
        filterNode.Q.setValueAtTime(5, audioContext.currentTime);

        const rustleAmp = 0.02 + Math.random() * 0.03; // Very quiet
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(rustleAmp, audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

        oscillator.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(masterGainNode);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.1);
    } catch (error) {
        console.error('Error playing rustle:', error);
    }
}

// Draw landing particles
function drawLandingParticles() {
    if (!isLanded || !landscapeCtx || !landscapeCanvas || landingParticles.length === 0) return;

    // Collision detection map
    const collisionMap = {};

    landingParticles.forEach((particle, index) => {
        if (particle.resting) {
            // Resting particles fade out slowly
            particle.fadeTime += 0.01;
            particle.opacity = Math.max(0, particle.opacity - 0.002);

            // Respawn particle when fully faded
            if (particle.opacity <= 0) {
                // Reinitialize with new properties
                const scaleNotes = destinations[currentDestination]?.harmonicNotes || destinations.worldTour.harmonicNotes;
                const isMusical = isMusicalParticlesEnabled && Math.random() < particleDensity;
                const note = isMusical ? scaleNotes[Math.floor(Math.random() * scaleNotes.length)][Math.floor(Math.random() * scaleNotes[0].length)] : null;

                particle.x = Math.random() * landscapeCanvas.width;
                particle.y = -Math.random() * 200;
                particle.vy = Math.random() * 0.5 + 0.5;
                particle.opacity = Math.random() * 0.5 + 0.3;
                particle.isMusical = isMusical;
                particle.note = note;
                particle.hasPlayed = false;
                particle.resting = false;
                particle.fadeTime = 0;
                particle.sway = Math.random() * Math.PI * 2;
            }
        } else {
            // Apply gravity
            particle.vy += particle.gravity * 0.05;

            // Apply swaying motion (like wind)
            particle.sway += particle.swaySpeed;
            const swayForce = Math.sin(particle.sway) * 0.5;
            particle.vx = swayForce;

            // Update position
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Wrap horizontally
            if (particle.x < 0) particle.x = landscapeCanvas.width;
            if (particle.x > landscapeCanvas.width) particle.x = 0;

            // Check if particle has landed
            if (particle.y >= groundY && !particle.hasPlayed) {
                particle.resting = true;
                particle.vy = 0;
                particle.y = groundY;

                // Play note if musical
                if (particle.isMusical) {
                    playParticleNote(particle);
                }
            }

            // Collision detection (for rustling)
            if (!particle.resting && particle.collisionCooldown === 0) {
                const gridX = Math.floor(particle.x / 10);
                const gridY = Math.floor(particle.y / 10);
                const key = `${gridX},${gridY}`;

                if (collisionMap[key]) {
                    // Collision detected
                    playParticleRustle(particle);
                    particle.collisionCooldown = 10;
                } else {
                    collisionMap[key] = true;
                }
            }

            if (particle.collisionCooldown > 0) {
                particle.collisionCooldown--;
            }
        }

        // Draw based on type
        landscapeCtx.globalAlpha = particle.opacity;

        // Musical particles glow slightly
        if (particle.isMusical && !particle.resting) {
            landscapeCtx.shadowBlur = 3;
            landscapeCtx.shadowColor = particle.type === 'snow' ? '#ffffff' :
                particle.type === 'leaf' ? '#ffa500' :
                particle.type === 'blossom' ? '#ff69b4' :
                '#ffffff';
        }

        landscapeCtx.fillStyle = particle.type === 'snow' ? '#ffffff' :
            particle.type === 'rain' ? '#88aacc' :
            particle.type === 'leaf' ? '#d4a574' :
            particle.type === 'blossom' ? '#ffccdd' :
            particle.type === 'dust' ? '#e0c090' :
            '#e0e0e0';

        if (particle.type === 'rain') {
            landscapeCtx.fillRect(particle.x, particle.y, 1, particle.size * 3);
        } else {
            landscapeCtx.beginPath();
            landscapeCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            landscapeCtx.fill();
        }

        landscapeCtx.shadowBlur = 0;
    });

    landscapeCtx.globalAlpha = 1.0;
}

// Start flight visualization
function startFlightVisualization() {
    console.log('Starting flight visualization');

    // Reset landed state
    isLanded = false;
    currentLandingSpace = null;
    landingParticles = [];

    // Reset path variables
    pathStartTime = Date.now();
    currentPath = 0;
    pathProgress = 0;

    // Show plane and ensure it has dimensions
    plane.style.display = 'block';

    // Position plane initially at starting position (visible on screen)
    // Start at 20% from left, middle of screen for better visibility
    if (flightCanvas && flightCanvas.width > 0) {
        planePosition.x = 20; // Start 20% from left edge
        planePosition.y = 50; // Middle vertically
        const left = (planePosition.x / 100) * flightCanvas.width;
        const top = (planePosition.y / 100) * flightCanvas.height;
        plane.style.left = `${left - 70}px`; // 70 is half of plane width (140px)
        plane.style.top = `${top - 35}px`;   // 35 is half of plane height (70px)
        plane.style.transform = 'rotate(0deg)';
        console.log('Plane positioned at:', left, top, 'Canvas dimensions:', flightCanvas.width, flightCanvas.height);
    } else {
        console.warn('flightCanvas not ready, dimensions:', flightCanvas ? flightCanvas.width : 'null');
    }

    // Start plane animation
    requestAnimationFrame(animatePlane);

    // Clear mountains/clouds for minimalist gradient aesthetic
    // Keep arrays empty to preserve clean Rothko-style visuals
    mountains = [];
    clouds = [];
    flightPaths = [];
    stars = [];
    planeTrail = [];
    smoothedTrail = [];

    // Create stars only (keep sky interesting but minimal)
    for (let i = 0; i < 100; i++) {
        createStar();
    }

    // Create cities
    createCities();

    // Draw landscape and stars
    drawLandscape();
    drawStars();

    // Set up sequencers
    sequencer1 = new AmbientSequencer(1);
    sequencer1.start();
    sequencer1.selectPattern();

    sequencer2 = new AmbientSequencer(2);
    setTimeout(() => {
        if (isFlying && sequencer2) {
            sequencer2.start();
            sequencer2.selectPattern();
        }
    }, 5000); // Start second sequencer after 5 seconds
}

// Stop flight visualization
function stopFlightVisualization() {
    console.log('Stopping flight visualization');
    
    // Stop any active oscillators
    if (activeOscillators && activeOscillators.length > 0) {
        activeOscillators.forEach(osc => {
            try {
                osc.stop();
            } catch (e) {
                console.warn('Error stopping oscillator:', e);
            }
        });
        activeOscillators = [];
    }
    
    // Stop any active sequencers
    if (sequencer1) {
        sequencer1.stop();
        sequencer1 = null;
    }
    
    if (sequencer2) {
        sequencer2.stop();
        sequencer2 = null;
    }
    
    // Stop LFO if it's active
    if (isLfoEnabled && lfoOscillator) {
        try {
            lfoOscillator.stop();
            lfoOscillator.disconnect();
            lfoOscillator = null;

            // Reset button state
            isLfoEnabled = false;
            lfoToggle.checked = false;
            lfoLed.classList.remove('active');
        } catch (error) {
            console.error('Error stopping LFO:', error);
        }
    }

    // Fade out immersive audio effects when landing
    if (audioContext) {
        if (engineGain) {
            engineGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
        }
        if (windNoiseGain) {
            windNoiseGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
        }
    }

    // Clean up immersive audio nodes (but keep them initialized for next takeoff)
    // They'll be restarted in startFlightVisualization if toggles are still on

    // Clear visualizations
    if (noteCtx && noteCanvas) {
        noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
    }
    if (flightCtx && flightCanvas) {
        flightCtx.clearRect(0, 0, flightCanvas.width, flightCanvas.height);
    }
    
    // Hide filter indicator if active
    if (filterIndicator) {
        filterIndicator.classList.remove('active');
    }
}

// Flight timer variables
let flightTimerInterval = null;

// Start flight timer
function startFlightTimer() {
    if (flightTimerInterval) clearInterval(flightTimerInterval);
    
    flightTimerInterval = setInterval(() => {
        if (!flightStartTime) {
            flightStartTime = Date.now();
        }
        
        // Calculate elapsed time
        const elapsedMs = Date.now() - flightStartTime;
        const hours = Math.floor(elapsedMs / (1000 * 60 * 60));
        const minutes = Math.floor((elapsedMs % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((elapsedMs % (1000 * 60)) / 1000);
        const timeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update time display
        const flightTimeEl = document.getElementById('flightTime');
        if (flightTimeEl) {
            flightTimeEl.textContent = timeStr;
        }
        
        // Update time needle
        if (timeNeedle) {
            const hourProgress = (elapsedMs / (60 * 60 * 1000)) % 1; // Progress through an hour (0-1)
            const degrees = hourProgress * 360;
            timeNeedle.style.transform = `translateX(-50%) rotate(${degrees}deg)`;
        }
        
        // Update altitude based on control value
        if (altitudeControl) {
            const altitudeValue = parseFloat(altitudeControl.value);
            const altitudeFeet = Math.floor(altitudeValue * 25000); // Scale to reasonable flight altitude
            const flightAltitudeEl = document.getElementById('flightAltitude');
            if (flightAltitudeEl) {
                flightAltitudeEl.textContent = `${altitudeFeet.toLocaleString()} ft`;
            }
        }
    }, 1000);
}

// Stop flight timer
function stopFlightTimer() {
    if (flightTimerInterval) {
        clearInterval(flightTimerInterval);
        flightTimerInterval = null; 
    }
}

// Movie-style flight path animation
function animatePlane() {
    if (!isFlying) return;
    
    if (!pathStartTime) pathStartTime = Date.now();
    
    const path = movieFlightPaths[currentPath];
    const elapsedTime = Date.now() - pathStartTime;
    pathProgress = Math.min(elapsedTime / path.duration, 1);
    
    let targetX, targetY;
    
    if (path.next && pathProgress > 0.5) {
        // Handle curved path with midpoint
        const progressInSecondHalf = (pathProgress - 0.5) * 2;
        targetX = path.end.x + (path.next.x - path.end.x) * progressInSecondHalf;
        targetY = path.end.y + (path.next.y - path.end.y) * progressInSecondHalf;
    } else if (path.next) {
        // First half of curved path
        const progressInFirstHalf = pathProgress * 2;
        targetX = path.start.x + (path.end.x - path.start.x) * progressInFirstHalf;
        targetY = path.start.y + (path.end.y - path.start.y) * progressInFirstHalf;
    } else {
        // Simple linear path
        targetX = path.start.x + (path.end.x - path.start.x) * pathProgress;
        targetY = path.start.y + (path.end.y - path.start.y) * pathProgress;
    }
    
    // Set plane position (as percentage of screen)
    planePosition.x = targetX;
    planePosition.y = targetY;
    
    // Calculate direction for plane rotation
    if (pathProgress < 1) {
        const dx = path.next && pathProgress > 0.5 ? path.next.x - path.end.x : path.end.x - path.start.x;
        const dy = path.next && pathProgress > 0.5 ? path.next.y - path.end.y : path.end.y - path.start.y;
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);

        // Position the plane element
        if (plane && flightCanvas) {
            const left = (planePosition.x / 100) * flightCanvas.width;
            const top = (planePosition.y / 100) * flightCanvas.height;

            plane.style.left = `${left - (plane.offsetWidth / 2)}px`;
            plane.style.top = `${top - (plane.offsetHeight / 2)}px`;
            plane.style.transform = `rotate(${angle}deg)`;

            // Add banking effect based on turn direction
            // Calculate angular velocity to detect turns
            const currentAngle = angle;
            const prevAngle = parseFloat(plane.dataset.prevAngle || angle);
            let angleDiff = currentAngle - prevAngle;

            // Normalize angle difference to -180 to 180
            if (angleDiff > 180) angleDiff -= 360;
            if (angleDiff < -180) angleDiff += 360;

            // Apply banking classes based on turn rate
            if (Math.abs(angleDiff) > 2) { // Threshold for banking
                if (angleDiff > 0) {
                    plane.classList.add('banking-right');
                    plane.classList.remove('banking-left');
                } else {
                    plane.classList.add('banking-left');
                    plane.classList.remove('banking-right');
                }
            } else {
                // Remove banking if flying straight
                plane.classList.remove('banking-left', 'banking-right');
            }

            // Store current angle for next frame
            plane.dataset.prevAngle = currentAngle;
        }
    }
    
    // Add point to trail
    if (trailCtx && flightCanvas) {
        const trailX = (planePosition.x / 100) * flightCanvas.width;
        const trailY = (planePosition.y / 100) * flightCanvas.height;
        
        planeTrail.push({ 
            x: trailX, 
            y: trailY,
            time: Date.now(),
            // Add frequency data for more reactive trail
            frequency: currentNoteData ? currentNoteData.frequency : 0
        });
        
        // Limit trail points
        if (planeTrail.length > MAX_TRAIL_POINTS) {
            planeTrail.shift();
        }
        
        // Draw the solid trail line instead of fading dots
        drawSolidTrail();
    }
    
    // Move cities in the opposite direction of the plane's movement
    // This creates a parallax effect as if the plane is moving over the terrain
    const virtualMovementX = planeDirection.x;
    const virtualMovementY = planeDirection.y;
    updateCityPositions(virtualMovementX, virtualMovementY, 0.5);
    
    // If we've reached the end of path, switch to next path
    if (pathProgress >= 1) {
        currentPath = (currentPath + 1) % movieFlightPaths.length;
        pathStartTime = Date.now();
        // Clear trail when switching paths
        planeTrail = [];
        trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
    }
    
    // Update immersive audio based on flight dynamics
    updateImmersiveAudio();

    // Update and draw new visual effects
    updateCloudParticles();
    updateContrailParticles();
    drawAtmosphericGlow();

    // Draw weather effects
    if (isRainEnabled) {
        drawRainEffect();
    }
    if (isThunderEnabled) {
        drawLightningFlash();
    }

    // Draw note visualization
    drawNoteVisualization();

    // Draw permanent trail (if enabled)
    if (trailPermaMode && smoothedTrail.length > 0) {
        drawPermanentTrail();
    }
    
    // Continue animation
    requestAnimationFrame(animatePlane);
}

// Create initial landscape
function createInitialLandscape() {
    // Clear existing elements
    mountains = [];
    clouds = [];
    flightPaths = [];
    stars = [];
    planeTrail = [];
    smoothedTrail = [];  // Clear smoothed trail
    
    // Make initial trail points that span the screen
    const screenWidth = landscapeCanvas.width;
    const screenHeight = landscapeCanvas.height;
    const centerY = screenHeight / 2;
    
    // Create initial trail that spans beyond screen edges
    for (let i = -100; i <= screenWidth + 100; i += 20) {
        const yVariation = Math.sin(i * 0.01) * 50;
        planeTrail.push({
            x: i,
            y: centerY + yVariation,
            frequency: 0
        });
    }
    
    // Create mountains - bigger
    for (let i = 0; i < 15; i++) {
        const size = 40 + Math.random() * 80; // Bigger initial mountains
        const mountain = {
            x: Math.random() * landscapeCanvas.width,
            y: landscapeCanvas.height - size / 2,
            width: size,
            height: size,
            color: colors.mountains[Math.floor(Math.random() * colors.mountains.length)],
            permanentElement: elementPersistence >= 0.5 // Link to persistence
        };
        mountains.push(mountain);
    }
    
    // Create clouds
    for (let i = 0; i < 20; i++) {
        createCloud();
    }
    
    // Create flight paths
    for (let i = 0; i < 5; i++) {
        const path = {
            x1: Math.random() * landscapeCanvas.width,
            y1: Math.random() * landscapeCanvas.height,
            x2: Math.random() * landscapeCanvas.width,
            y2: Math.random() * landscapeCanvas.height,
            width: 1 + Math.random() * 1.5,
            opacity: 0.08
        };
        flightPaths.push(path);
    }
    
    // Create stars
    for (let i = 0; i < 100; i++) {
        createStar();
    }
    
    // Create cities
    createCities();
    
    // Clear the trail canvas
    trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
}

// Create a cloud with more complex shape
function createCloud() {
    const size = 30 + Math.random() * 70;
    const cloudColor = colors.clouds[Math.floor(Math.random() * colors.clouds.length)];
    
    const cloud = {
        x: Math.random() * landscapeCanvas.width,
        y: Math.random() * (landscapeCanvas.height / 2),
        width: size,
        height: size / 2,
        opacity: 0.05 + Math.random() * 0.1,
        speed: 0.05 + Math.random() * 0.1,
        bubbles: 3 + Math.floor(Math.random() * 3),
        color: cloudColor,
        permanentElement: elementPersistence >= 0.7 // Link to persistence slider
    };
    clouds.push(cloud);
}

// Create a star
function createStar() {
    const size = 0.5 + Math.random() * 1.5;
    const opacity = 0.3 + Math.random() * 0.7;
    const twinkleSpeed = 0.001 + Math.random() * 0.005;
    
    const star = {
        x: Math.random() * starsCanvas.width,
        y: Math.random() * starsCanvas.height,
        size: size,
        opacity: opacity,
        color: colors.stars[Math.floor(Math.random() * colors.stars.length)],
        twinkleSpeed: twinkleSpeed,
        twinkleDir: Math.random() > 0.5 ? 1 : -1,
        permanentElement: true // Stars always stick around
    };
    stars.push(star);
}

// Create landscape element based on frequency
function createLandscapeElement(frequency) {
    const normalizedFreq = (frequency - 100) / 500;
    
    // Create mountain or building
    if (Math.random() < 0.6) {
        // MUCH larger sizes for buildings and mountains - increased by 2x
        const size = 40 + normalizedFreq * 160; // Previously 30 + normalizedFreq * 120
        
        // Determine if it's a mountain or a city building
        const isMountain = Math.random() < 0.7;
        const mountain = {
            x: Math.random() * landscapeCanvas.width,
            y: landscapeCanvas.height - size / 2,
            width: size,
            height: isMountain ? size : size * 2.5, // Taller buildings (previously 2.0)
            color: colors.mountains[Math.floor(Math.random() * colors.mountains.length)],
            opacity: 1,
            fadeRate: 0,
            isBuilding: !isMountain,
            // Link permanence directly to the persistence slider
            permanentElement: elementPersistence >= 0.5
        };
        mountains.push(mountain);
    } else {
        // Create a cloud
        createCloud();
    }
    
    // Occasionally create a star
    if (Math.random() < 0.3) {
        createStar();
    }
}

// Create cities with buffer from edges
function createCities() {
    // Define global city names and positions (relative to canvas)
    const cityData = [
        // North America
        { name: "New York", x: 0.20, y: 0.30, region: "na" },
        { name: "Chicago", x: 0.35, y: 0.25, region: "na" },
        { name: "Los Angeles", x: 0.45, y: 0.40, region: "na" },
        { name: "Miami", x: 0.30, y: 0.60, region: "na" },
        { name: "Mexico City", x: 0.40, y: 0.65, region: "na" },
        { name: "Toronto", x: 0.25, y: 0.22, region: "na" },
        { name: "Vancouver", x: 0.32, y: 0.15, region: "na" },
        { name: "Montreal", x: 0.27, y: 0.20, region: "na" },
        { name: "Denver", x: 0.38, y: 0.30, region: "na" },
        { name: "Seattle", x: 0.28, y: 0.18, region: "na" },
        
        // South America
        { name: "São Paulo", x: 0.50, y: 0.80, region: "sa" },
        { name: "Buenos Aires", x: 0.55, y: 0.85, region: "sa" },
        { name: "Rio de Janeiro", x: 0.45, y: 0.78, region: "sa" },
        { name: "Lima", x: 0.44, y: 0.75, region: "sa" },
        { name: "Bogotá", x: 0.42, y: 0.72, region: "sa" },
        
        // Europe
        { name: "London", x: 0.45, y: 0.18, region: "eu" },
        { name: "Paris", x: 0.48, y: 0.22, region: "eu" },
        { name: "Berlin", x: 0.52, y: 0.18, region: "eu" },
        { name: "Rome", x: 0.52, y: 0.28, region: "eu" },
        { name: "Madrid", x: 0.42, y: 0.26, region: "eu" },
        
        // Asia
        { name: "Tokyo", x: 0.70, y: 0.35, region: "as" },
        { name: "Beijing", x: 0.68, y: 0.28, region: "as" },
        { name: "Shanghai", x: 0.72, y: 0.35, region: "as" },
        { name: "Mumbai", x: 0.65, y: 0.45, region: "as" },
        { name: "Delhi", x: 0.68, y: 0.40, region: "as" },
        
        // Africa
        { name: "Cairo", x: 0.55, y: 0.40, region: "af" },
        { name: "Lagos", x: 0.45, y: 0.55, region: "af" },
        { name: "Johannesburg", x: 0.52, y: 0.75, region: "af" },
        { name: "Nairobi", x: 0.58, y: 0.60, region: "af" },
        { name: "Cape Town", x: 0.50, y: 0.80, region: "af" },
        
        // Oceania
        { name: "Sydney", x: 0.72, y: 0.75, region: "oc" },
        { name: "Melbourne", x: 0.68, y: 0.80, region: "oc" },
        { name: "Auckland", x: 0.78, y: 0.85, region: "oc" },
        { name: "Perth", x: 0.65, y: 0.70, region: "oc" },
        { name: "Brisbane", x: 0.74, y: 0.72, region: "oc" }
    ];
    
    const cityLabelsContainer = document.getElementById('cityLabels');
    cityLabelsContainer.innerHTML = ''; // Clear existing labels
    cities = []; // Reset cities array
    activeCities = []; // Reset active cities array
    
    const screenWidth = landscapeCanvas.width;
    const screenHeight = landscapeCanvas.height;
    
    const padding = 80; // Buffer from screen edges
    
    cityData.forEach(city => {
        // Add padding to keep cities away from edges
        const newX = padding + (city.x * (screenWidth - 2 * padding));
        const newY = padding + (city.y * (screenHeight - 2 * padding));
        
        // Create city object for our internal tracking
        const cityObj = {
            name: city.name,
            x: newX,
            y: newY,
            region: city.region,
            element: null,
            opacity: 0,
            active: false,
            permanentElement: elementPersistence >= 0.8
        };
        
        // Create DOM element for the city
        const cityLabel = document.createElement('div');
        cityLabel.className = `city-label region-${city.region || 'na'}`;
        cityLabel.textContent = city.name;
        cityLabel.style.left = `${newX}px`;
        cityLabel.style.top = `${newY}px`;
        cityLabel.style.opacity = "0"; // Start hidden
        
        // Store reference to the DOM element
        cityObj.element = cityLabel;
        cities.push(cityObj);
        
        // Add to the container
        cityLabelsContainer.appendChild(cityLabel);
    });
    
    console.log(`Created ${cities.length} cities`);
}

// Function to update city positions
function updateCityPositions(virtualMovementX, virtualMovementY, slowFactor) {
    cities.forEach(city => {
        // Skip movement for permanent elements when persistence is at max
        if (elementPersistence >= 0.7 && city.permanentElement) {
            // Don't move or fade cities at high persistence
            // Just ensure they remain visible if active
            if (city.active && city.element) {
                city.element.style.opacity = "1";
            }
        } else {
            // Normal movement for other cases
            city.x -= virtualMovementX * 2 * slowFactor * cityMovementSpeed;
            city.y -= virtualMovementY * 2 * slowFactor * cityMovementSpeed;
            
            // Keep cities on screen - wrapped when going out of bounds
            const screenWidth = landscapeCanvas.width;
            const screenHeight = landscapeCanvas.height;
            const padding = 80; // Same padding as when creating cities
            
            if (city.x < padding) {
                city.x = screenWidth - padding;
            } else if (city.x > screenWidth - padding) {
                city.x = padding;
            }
            
            if (city.y < padding) {
                city.y = screenHeight - padding;
            } else if (city.y > screenHeight - padding) {
                city.y = padding;
            }
            
            // Only adjust opacity for active cities
            if (city.active) {
                // If the city is near the edge, start fading it
                const isNearEdge = 
                    city.x < padding + 20 || 
                    city.x > screenWidth - (padding + 20) ||
                    city.y < padding + 20 || 
                    city.y > screenHeight - (padding + 20);
                    
                if (isNearEdge) {
                    city.opacity = Math.max(0, city.opacity - 0.01);
                    if (city.opacity <= 0) {
                        city.active = false;
                        // Remove from active cities
                        const index = activeCities.indexOf(city);
                        if (index > -1) {
                            activeCities.splice(index, 1);
                        }
                    }
                }
            }
        }
        
        // Update DOM element position and opacity
        if (city.element) {
            city.element.style.left = `${city.x}px`;
            city.element.style.top = `${city.y}px`;
            if (city.active) {
                city.element.style.opacity = city.opacity;
            }
        }
    });
}

// Function to clear all active cities
function clearActiveCities() {
    // Clear all active cities
    activeCities.forEach(city => {
        if (city.element) {
            city.active = false;
            city.element.style.opacity = "0";
        }
    });
    activeCities = [];
    noteCounter = 0;
}

// Show city with note
function showCityWithNote() {
    if (!cities || cities.length === 0) return;
    
    // Increment note counter
    noteCounter++;
    
    // Only show a city every X notes
    if (noteCounter % cityDisplayInterval !== 0) return;
    
    // Make sure we don't have too many active cities (max 5)
    if (activeCities.length >= 5) {
        // Hide the oldest active city
        const oldestCity = activeCities.shift();
        if (oldestCity && oldestCity.element) {
            oldestCity.active = false;
            oldestCity.element.style.opacity = "0";
        }
    }
    
    // Find cities that aren't currently active and are within screen bounds
    const inactiveCities = cities.filter(city => {
        // Only consider cities that are well within the screen bounds
        return !city.active && 
               city.x >= 50 && city.x <= landscapeCanvas.width - 50 && 
               city.y >= 50 && city.y <= landscapeCanvas.height - 50;
    });
    
    if (inactiveCities.length === 0) return;
    
    // Select a random inactive city
    const randomIndex = Math.floor(Math.random() * inactiveCities.length);
    const city = inactiveCities[randomIndex];
    
    if (city && city.element) {
        // Mark as active
        city.active = true;
        city.opacity = 1.0;
        activeCities.push(city);
        
        // Apply flash animation and make visible
        city.element.classList.remove('city-flash');
        // Use setTimeout to ensure the removal is processed before adding
        setTimeout(() => {
            city.element.classList.add('city-flash');
            city.element.style.opacity = "1";
        }, 10);
    }
}

// Make cities react to nearby notes with twinkling and glow
function makeCitiesReactToNote(noteX, noteY, frequency) {
    if (!activeCities || activeCities.length === 0) return;

    // Find cities within range of the note
    const reactionRadius = 150; // pixels

    activeCities.forEach(city => {
        if (!city || !city.element) return;

        // Calculate distance from note to city
        const dx = city.x - noteX;
        const dy = city.y - noteY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < reactionRadius) {
            // Make city glow based on proximity (closer = stronger glow)
            const intensity = 1 - (distance / reactionRadius);

            // Only react if intensity is significant
            if (intensity > 0.3) {
                // Trigger reactive glow animation
                city.element.classList.remove('note-reactive');
                // Force reflow
                void city.element.offsetWidth;
                city.element.classList.add('note-reactive');

                // Add extra twinkle stars based on note frequency
                if (Math.random() < intensity) {
                    addTwinkleStarToCity(city, frequency);
                }

                // Remove the class after animation completes
                setTimeout(() => {
                    if (city.element) {
                        city.element.classList.remove('note-reactive');
                    }
                }, 500);
            }
        }
    });
}

// Add temporary twinkling star effect to a city
function addTwinkleStarToCity(city, frequency) {
    if (!city || !city.element) return;

    // Map frequency to star color
    const normalizedFreq = Math.min(1, Math.max(0, (frequency - 100) / 1500));
    const hue = 180 + (normalizedFreq * 180); // Range from cyan to magenta

    // Create temporary star element
    const star = document.createElement('span');
    star.textContent = '✨';
    star.style.position = 'absolute';
    star.style.left = `${-10 + Math.random() * 20}px`;
    star.style.top = `${-10 + Math.random() * 20}px`;
    star.style.fontSize = `${8 + Math.random() * 6}px`;
    star.style.opacity = '1';
    star.style.pointerEvents = 'none';
    star.style.filter = `hue-rotate(${hue}deg)`;
    star.style.transition = 'opacity 0.8s ease-out, transform 0.8s ease-out';
    star.style.transform = 'scale(1)';

    city.element.style.position = 'relative';
    city.element.appendChild(star);

    // Fade out and remove
    setTimeout(() => {
        star.style.opacity = '0';
        star.style.transform = 'scale(0.5) translateY(-10px)';
        setTimeout(() => star.remove(), 800);
    }, 100);
}

// Show status message
function showStatus(message) {
    const statusMessage = document.getElementById('statusMessage');
    if (statusMessage) {
        // Add fade animation for better visual feedback
        statusMessage.classList.add('status-fade');
        statusMessage.innerHTML = message;

        setTimeout(() => {
            statusMessage.classList.remove('status-fade');
        }, 500);

        // Log to console as well for debugging
        console.log(`Status: ${message.replace(/<[^>]*>/g, '')}`);
    }
}

// Fade out announcement
function fadeOutAnnouncement() {
    const announcementElement = document.getElementById('announcement');
    if (announcementElement) {
        announcementElement.style.opacity = '0';
        setTimeout(() => {
            announcementElement.style.display = 'none';
            // Reset text color if it was changed
            const announcementText = document.getElementById('announcementText');
            if (announcementText) {
                announcementText.style.color = '';
            }
        }, 700); // Match the CSS transition time
    }
}

// Generate flight announcements based on music
function generateAnnouncement() {
    if (!lastNoteData.frequency || !currentNoteData.frequency) return;
    const announcementElement = document.getElementById('announcement');
    const announcementText = document.getElementById('announcementText');
    if (!announcementElement || !announcementText) return;
    
    // Calculate properties for announcement variables
    const freqDifference = Math.abs(currentNoteData.frequency - lastNoteData.frequency);
    const normalizedFreq = currentNoteData.frequency / 500;
    
    // Generate announcement components
    const altitude = Math.floor(currentNoteData.frequency * 20);
    const temperature = Math.floor(-20 + normalizedFreq * 40);
    
    // Turbulence intensity based on frequency difference
    let turbulence = "mild";
    if (freqDifference > 150) turbulence = "significant";
    if (freqDifference > 300) turbulence = "moderate";
    
    // Flight phase
    let phase = "cruising";
    if (normalizedFreq < 0.3) phase = "descent";
    if (normalizedFreq > 0.7) phase = "ascent";
    
    // Terrain type based on current visual elements
    const terrain = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
    
    // View description
    const view = viewTypes[Math.floor(Math.random() * viewTypes.length)];
    
    // Obstacle type
    const obstacle = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
    
    // Weather description
    const weather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
    
    // Progress description
    const progressTypes = ["progress", "headway", "speed", "altitude gain"];
    const progress = progressTypes[Math.floor(Math.random() * progressTypes.length)];
    
    // Time estimate
    const time = Math.floor(20 + Math.random() * 40);
    
    // Atmosphere description
    const atmosphere = atmosphereTypes[Math.floor(Math.random() * atmosphereTypes.length)];
    
    // Direction change based on frequency difference
    let change = "slight adjustment";
    if (freqDifference > 100) change = "minor course correction";
    if (freqDifference > 200) change = "significant course adjustment";
    
    // Get announcement templates based on artist
    let announcementTemplates = announcements;
    
    // Use artist-specific announcements if available
    if (artistAnnouncements[currentArtist] && Math.random() < 0.7) {
        announcementTemplates = artistAnnouncements[currentArtist];
    }
    
    // Select a random announcement template
    const template = announcementTemplates[Math.floor(Math.random() * announcementTemplates.length)];
    
    // Replace variables in template
    let announcement = template
        .replace("{altitude}", altitude)
        .replace("{temp}", temperature)
        .replace("{turbulence}", turbulence)
        .replace("{terrain}", terrain)
        .replace("{phase}", phase)
        .replace("{view}", view)
        .replace("{obstacle}", obstacle)
        .replace("{weather}", weather)
        .replace("{progress}", progress)
        .replace("{time}", time)
        .replace("{atmosphere}", atmosphere)
        .replace("{change}", change);
    
    // Display the announcement
    announcementText.textContent = announcement;
    announcementElement.style.display = 'block';
    announcementElement.style.opacity = '1';
    
    // Update the last announcement time
    lastAnnouncementTime = Date.now();
    
    // Clear previous timer if exists
    if (announcementTimer) clearTimeout(announcementTimer);
    
    // Hide announcement after a delay
    const fadeTime = 5000 + Math.random() * 2000;
    announcementTimer = setTimeout(() => {
        fadeOutAnnouncement();
    }, fadeTime);
}

// ===== SYNESTHETIC GRADIENT VISUALIZATION =====

// Color utility functions
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (Math.round(r) << 16) + (Math.round(g) << 8) + Math.round(b)).toString(16).slice(1);
}

function lerpColor(color1, color2, t) {
    const c1 = hexToRgb(color1);
    const c2 = hexToRgb(color2);
    if (!c1 || !c2) return color1;

    return rgbToHex(
        c1.r + (c2.r - c1.r) * t,
        c1.g + (c2.g - c1.g) * t,
        c1.b + (c2.b - c1.b) * t
    );
}

// Update gradient colors based on audio parameters
function updateGradientColors() {
    if (!isFlying) return;

    // Get current audio state
    const filterCutoff = filterNode ? parseFloat(filterCutoffControl?.value || 20000) : 20000;
    const reverbMix = parseFloat(reverbControl?.value || 0.3);
    const altitude = parseFloat(altitudeControl?.value || 0.5);

    // Select palette based on destination
    const palette = gradientPalettes[currentDestination] || gradientPalettes.worldTour;
    const paletteIndex = Math.floor((filterCutoff / 20000) * (palette.length - 1));
    const targetPalette = palette[Math.min(paletteIndex, palette.length - 1)];

    // Lerp to target colors
    targetGradientColors = {...targetPalette};

    currentGradientColors.top = lerpColor(currentGradientColors.top, targetGradientColors.top, gradientTransitionSpeed);
    currentGradientColors.middle = lerpColor(currentGradientColors.middle, targetGradientColors.middle, gradientTransitionSpeed);
    currentGradientColors.bottom = lerpColor(currentGradientColors.bottom, targetGradientColors.bottom, gradientTransitionSpeed);

    // Adjust brightness based on altitude
    const brightnessModifier = 0.7 + (altitude * 0.6); // 0.7 to 1.3
    // Note: Full brightness adjustment would require HSL conversion - keeping simple for performance
}

// Draw Rothko-inspired gradient background
function drawGradientBackground() {
    if (!landscapeCtx || !landscapeCanvas) return;

    const width = landscapeCanvas.width;
    const height = landscapeCanvas.height;

    // Create multi-stop vertical gradient
    const gradient = landscapeCtx.createLinearGradient(0, 0, 0, height);

    // Add color stops
    gradient.addColorStop(0, currentGradientColors.top);
    gradient.addColorStop(0.4, currentGradientColors.middle);
    gradient.addColorStop(1, currentGradientColors.bottom);

    // Fill entire canvas
    landscapeCtx.fillStyle = gradient;
    landscapeCtx.fillRect(0, 0, width, height);

    // Optional: Add subtle texture/noise for Rothko effect
    const reverbMix = parseFloat(reverbControl?.value || 0.3);
    if (reverbMix > 0.3) {
        landscapeCtx.globalAlpha = 0.02 * reverbMix;
        for (let i = 0; i < 50; i++) {
            landscapeCtx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            landscapeCtx.fillRect(
                Math.random() * width,
                Math.random() * height,
                Math.random() * 100,
                Math.random() * 100
            );
        }
        landscapeCtx.globalAlpha = 1.0;
    }
}

// Draw frequency-based terrain
function drawFrequencyTerrain() {
    if (!landscapeCtx || !landscapeCanvas || !audioAnalyser || !isFlying) return;

    const width = landscapeCanvas.width;
    const height = landscapeCanvas.height;

    // Get frequency data
    if (!frequencyData) {
        frequencyData = new Uint8Array(audioAnalyser.frequencyBinCount);
    }
    audioAnalyser.getByteFrequencyData(frequencyData);

    // Draw bass frequencies as terrain (bins 0-20)
    const bassData = frequencyData.slice(0, 20);
    const numPoints = bassData.length;
    const pointSpacing = width / (numPoints - 1);
    const baselineY = height * 0.75; // Terrain starts at 75% down

    // Create smooth bezier curve
    landscapeCtx.save();
    landscapeCtx.globalAlpha = 0.4;
    landscapeCtx.filter = 'blur(2px)';

    // Begin path for terrain
    landscapeCtx.beginPath();
    landscapeCtx.moveTo(0, height);

    for (let i = 0; i < numPoints; i++) {
        const x = i * pointSpacing;
        const amplitude = (bassData[i] / 255) * (height * 0.3); // Max 30% of screen
        const y = baselineY - amplitude;

        if (i === 0) {
            landscapeCtx.lineTo(x, y);
        } else {
            const prevX = (i - 1) * pointSpacing;
            const prevAmplitude = (bassData[i - 1] / 255) * (height * 0.3);
            const prevY = baselineY - prevAmplitude;

            // Smooth curve
            const cpX = (prevX + x) / 2;
            const cpY = (prevY + y) / 2;
            landscapeCtx.quadraticCurveTo(prevX, prevY, cpX, cpY);
        }
    }

    // Close path
    landscapeCtx.lineTo(width, height);
    landscapeCtx.closePath();

    // Fill with translucent gradient
    const terrainGradient = landscapeCtx.createLinearGradient(0, baselineY - height * 0.3, 0, height);
    terrainGradient.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
    terrainGradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
    landscapeCtx.fillStyle = terrainGradient;
    landscapeCtx.fill();

    landscapeCtx.restore();
}

// Draw stars
function drawStars() {
    starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);

    // Draw stars with twinkling effect
    stars.forEach(star => {
        // Update star twinkle
        star.opacity += star.twinkleSpeed * star.twinkleDir;

        // Reverse direction if reached min/max opacity
        if (star.opacity >= 1 || star.opacity <= 0.1) {
            star.twinkleDir *= -1;
        }

        // Draw the star
        starsCtx.fillStyle = adjustOpacity(star.color, star.opacity);
        starsCtx.beginPath();
        starsCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        starsCtx.fill();
    });

    // Randomly create shooting stars (1% chance per frame when flying at high altitude)
    const altitude = altitudeControl ? parseFloat(altitudeControl.value) : 1.0;
    if (isFlying && altitude > 0.7 && Math.random() < 0.01) {
        shootingStars.push({
            x: Math.random() * starsCanvas.width,
            y: Math.random() * (starsCanvas.height * 0.5), // Top half of screen
            length: 30 + Math.random() * 50,
            speed: 5 + Math.random() * 10,
            angle: Math.PI / 4 + Math.random() * Math.PI / 4, // Diagonal
            opacity: 1,
            brightness: 0.5 + Math.random() * 0.5
        });
    }

    // Update and draw shooting stars
    shootingStars = shootingStars.filter(star => {
        star.x += Math.cos(star.angle) * star.speed;
        star.y += Math.sin(star.angle) * star.speed;
        star.opacity -= 0.02;

        if (star.opacity > 0) {
            // Draw shooting star as a gradient line
            const gradient = starsCtx.createLinearGradient(
                star.x, star.y,
                star.x - Math.cos(star.angle) * star.length,
                star.y - Math.sin(star.angle) * star.length
            );
            gradient.addColorStop(0, `rgba(255, 255, 255, ${star.opacity * star.brightness})`);
            gradient.addColorStop(0.5, `rgba(200, 220, 255, ${star.opacity * star.brightness * 0.5})`);
            gradient.addColorStop(1, `rgba(150, 180, 255, 0)`);

            starsCtx.strokeStyle = gradient;
            starsCtx.lineWidth = 2;
            starsCtx.beginPath();
            starsCtx.moveTo(star.x, star.y);
            starsCtx.lineTo(
                star.x - Math.cos(star.angle) * star.length,
                star.y - Math.sin(star.angle) * star.length
            );
            starsCtx.stroke();
            return true;
        }
        return false;
    });
}

// Update and draw cloud particles
function updateCloudParticles() {
    if (!landscapeCtx || !landscapeCanvas) return;

    // Generate new cloud particles (slower rate than stars)
    if (isFlying && Math.random() < 0.02) {
        cloudParticles.push({
            x: -50,
            y: 50 + Math.random() * (landscapeCanvas.height * 0.4),
            size: 30 + Math.random() * 50,
            speed: 0.5 + Math.random() * 1.5,
            opacity: 0.1 + Math.random() * 0.2,
            color: `rgba(255, 255, 255, ${0.1 + Math.random() * 0.15})`
        });
    }

    // Update and draw cloud particles
    cloudParticles = cloudParticles.filter(cloud => {
        cloud.x += cloud.speed;

        if (cloud.x < landscapeCanvas.width + 100) {
            landscapeCtx.beginPath();
            landscapeCtx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
            landscapeCtx.fillStyle = cloud.color;
            landscapeCtx.fill();

            // Add some blur effect
            landscapeCtx.beginPath();
            landscapeCtx.arc(cloud.x, cloud.y, cloud.size * 0.7, 0, Math.PI * 2);
            landscapeCtx.fillStyle = `rgba(255, 255, 255, ${cloud.opacity * 0.5})`;
            landscapeCtx.fill();

            return true;
        }
        return false;
    });
}

// Update and draw contrail particles
function updateContrailParticles() {
    if (!landscapeCtx || !landscapeCanvas || !isFlying) return;

    // Get plane position in pixels
    const planeX = (planePosition.x / 100) * landscapeCanvas.width;
    const planeY = (planePosition.y / 100) * landscapeCanvas.height;

    // Generate contrail particles behind the plane
    if (Math.random() < 0.3) {
        contrailParticles.push({
            x: planeX,
            y: planeY,
            size: 2 + Math.random() * 4,
            opacity: 0.6,
            life: 1.0,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5
        });
    }

    // Update and draw contrail particles
    contrailParticles = contrailParticles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life -= 0.01;
        particle.opacity = particle.life * 0.6;
        particle.size *= 1.02; // Expand slightly

        if (particle.life > 0) {
            landscapeCtx.beginPath();
            landscapeCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            landscapeCtx.fillStyle = `rgba(200, 220, 255, ${particle.opacity})`;
            landscapeCtx.fill();
            return true;
        }
        return false;
    });
}

// Draw atmospheric glow around plane
function drawAtmosphericGlow() {
    if (!landscapeCtx || !landscapeCanvas || !isFlying) return;

    const altitude = parseFloat(altitudeControl.value);
    const velocity = Math.sqrt(planeDirection.x * planeDirection.x + planeDirection.y * planeDirection.y);

    // Glow increases at high altitude and high speed
    const targetOpacity = (altitude * 0.3 + velocity * 5) * 0.3;
    const targetRadius = 40 + altitude * 30 + velocity * 100;

    // Smooth transitions
    atmosphericGlow.opacity += (targetOpacity - atmosphericGlow.opacity) * 0.1;
    atmosphericGlow.radius += (targetRadius - atmosphericGlow.radius) * 0.1;

    if (atmosphericGlow.opacity > 0.05) {
        const planeX = (planePosition.x / 100) * landscapeCanvas.width;
        const planeY = (planePosition.y / 100) * landscapeCanvas.height;

        // Draw glow
        const gradient = landscapeCtx.createRadialGradient(
            planeX, planeY, 0,
            planeX, planeY, atmosphericGlow.radius
        );
        gradient.addColorStop(0, `rgba(150, 200, 255, ${atmosphericGlow.opacity})`);
        gradient.addColorStop(0.5, `rgba(100, 150, 255, ${atmosphericGlow.opacity * 0.5})`);
        gradient.addColorStop(1, 'rgba(50, 100, 200, 0)');

        landscapeCtx.fillStyle = gradient;
        landscapeCtx.fillRect(
            planeX - atmosphericGlow.radius,
            planeY - atmosphericGlow.radius,
            atmosphericGlow.radius * 2,
            atmosphericGlow.radius * 2
        );
    }
}

// Draw landscape
function drawLandscape() {
    landscapeCtx.clearRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);

    // SYNESTHETIC VISUALIZATION: Gradient + Frequency Terrain
    // Update colors based on audio parameters
    updateGradientColors();

    // Draw Rothko-inspired gradient background
    drawGradientBackground();

    // Draw frequency-based terrain overlay
    drawFrequencyTerrain();
    
    // Draw flight paths
    flightPaths.forEach(path => {
        landscapeCtx.beginPath();
        landscapeCtx.moveTo(path.x1, path.y1);
        landscapeCtx.lineTo(path.x2, path.y2);
        landscapeCtx.strokeStyle = path.opacity ? 
            `rgba(236, 240, 241, ${path.opacity})` : 
            colors.flightPaths;
        landscapeCtx.lineWidth = path.width;
        landscapeCtx.stroke();
    });
    
    // Draw mountains
    mountains = mountains.filter(mountain => {
        if (mountain.fadeRate && mountain.opacity <= 0) return false;
        
        if (mountain.isBuilding) {
            // Draw a building (rectangle)
            landscapeCtx.beginPath();
            
            // Apply opacity if fading
            if (mountain.fadeRate) {
                landscapeCtx.fillStyle = adjustOpacity(mountain.color, mountain.opacity);
                mountain.opacity -= mountain.fadeRate;
            } else {
                landscapeCtx.fillStyle = mountain.color;
            }
            
            // Draw a rectangle with small windows
            landscapeCtx.fillRect(
                mountain.x - mountain.width / 4, 
                mountain.y, 
                mountain.width / 2, 
                mountain.height
            );
            
            // Add windows
            const windowColor = 'rgba(255, 255, 200, 0.3)';
            const windowSize = mountain.width / 12;
            const buildingWidth = mountain.width / 2;
            const windowsPerFloor = Math.max(1, Math.floor(buildingWidth / windowSize) - 1);
            const floors = Math.max(2, Math.floor(mountain.height / windowSize) - 1);
            
            landscapeCtx.fillStyle = windowColor;
            
            for (let floor = 1; floor < floors; floor++) {
                for (let win = 0; win < windowsPerFloor; win++) {
                    // Only draw some windows (not all lights on)
                    if (Math.random() < 0.7) {
                        landscapeCtx.fillRect(
                            mountain.x - mountain.width / 4 + windowSize + win * (buildingWidth - windowSize) / windowsPerFloor,
                            mountain.y + floor * mountain.height / floors,
                            windowSize / 2,
                            windowSize / 2
                        );
                    }
                }
            }
        } else {
            // Triangle mountain
            landscapeCtx.beginPath();
            landscapeCtx.moveTo(mountain.x, mountain.y);
            landscapeCtx.lineTo(mountain.x - mountain.width / 2, mountain.y + mountain.height);
            landscapeCtx.lineTo(mountain.x + mountain.width / 2, mountain.y + mountain.height);
            landscapeCtx.closePath();
            
            // Apply opacity if fading
            if (mountain.fadeRate) {
                landscapeCtx.fillStyle = adjustOpacity(mountain.color, mountain.opacity);
                mountain.opacity -= mountain.fadeRate;
            } else {
                landscapeCtx.fillStyle = mountain.color;
            }
            
            landscapeCtx.fill();
        }
        
        return true;
    });
    
    // Draw clouds
    clouds = clouds.filter(cloud => {
        if (cloud.fadeRate && cloud.opacity <= 0) return false;
        
        // Move cloud
        cloud.x += cloud.speed;
        if (cloud.x > landscapeCanvas.width + cloud.width) {
            cloud.x = -cloud.width;
        }
        
        // Draw cloud (cluster of circles)
        const opacity = cloud.fadeRate ? cloud.opacity : cloud.opacity;
        landscapeCtx.fillStyle = typeof cloud.color === 'string' ? 
            adjustOpacity(cloud.color, opacity) : 
            adjustOpacity(colors.clouds[0], opacity);
        
        // Draw multiple circles to form cloud shape
        const bubbleCount = cloud.bubbles || 3;

        // Main circle
        landscapeCtx.beginPath();
        landscapeCtx.arc(cloud.x, cloud.y, cloud.width / 3, 0, Math.PI * 2);
        landscapeCtx.fill();
        
        // Additional circles to create cloud shape
        for (let i = 0; i < bubbleCount; i++) {
            const offsetX = (i - bubbleCount/2) * (cloud.width / bubbleCount);
            const offsetY = (Math.random() - 0.5) * (cloud.height / 3);
            const size = (0.5 + Math.random() * 0.5) * (cloud.width / 3);
            
            landscapeCtx.beginPath();
            landscapeCtx.arc(
                cloud.x + offsetX, 
                cloud.y + offsetY, 
                size, 
                0, 
                Math.PI * 2
            );
            landscapeCtx.fill();
        }
        
        // Apply fading if necessary
        if (cloud.fadeRate) {
            cloud.opacity -= cloud.fadeRate;
        }
        
        return true;
    });

    // Draw landing particles if landed
    if (isLanded) {
        drawLandingParticles();
    }
}

// Draw solid trail like in travel movies
function drawSolidTrail() {
    // Clear and redraw the entire trail each frame
    trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
    
    if (planeTrail.length > 1) {
        trailCtx.beginPath();
        trailCtx.moveTo(planeTrail[0].x, planeTrail[0].y);
        
        for (let i = 1; i < planeTrail.length; i++) {
            trailCtx.lineTo(planeTrail[i].x, planeTrail[i].y);
        }
        
        // Create a dash pattern for the classic "travel movie" look
        trailCtx.setLineDash([5, 5]);
        trailCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; // Classic red line
        trailCtx.lineWidth = 2;
        trailCtx.stroke();
        
        // Reset dash pattern
        trailCtx.setLineDash([]);
    }
}

// Draw permanent trail - Enhanced to be more reactive to music
function drawPermanentTrail() {
    // Skip if no trail or in hidden mode
    if (smoothedTrail.length < 2) return;
    
    // Get current intensity
    const intensity = parseFloat(trailIntensityControl.value);
    
    // First clear the canvas - only if not in permanent mode
    if (!trailPermaMode) {
        trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
    }
    
    // Create gradient for trail using artist color if available
    let trailColor = '#e74c3c'; // Default red
    if (artistStyles[currentArtist] && artistStyles[currentArtist].noteColor) {
        trailColor = artistStyles[currentArtist].noteColor;
    }
    
    // Draw the permanent trail
    trailCtx.lineJoin = 'round';
    trailCtx.lineCap = 'round';
    
    // For more music reactivity, use the current frequency to modulate the trail
    const currentFrequency = currentNoteData.frequency || 261.63; // Default to middle C if no note
    const frequencyFactor = Math.min(2, currentFrequency / 261.63); // Normalize around middle C with a cap
    
    // Start path
    trailCtx.beginPath();
    trailCtx.moveTo(smoothedTrail[0].x, smoothedTrail[0].y);
    
    // Draw smooth curve through points
    for (let i = 1; i < smoothedTrail.length; i++) {
        // Use frequency to modulate the trail
        const point = smoothedTrail[i];
        
        // Skip points with no frequency data in permanent trail
        if (!point.frequency) continue;
        
        // Calculate normalized frequency for this point
        const pointFreq = point.frequency || 261.63;
        const normalizedFreq = Math.min(1, (pointFreq - 100) / 800);
        
        // Adjust line width based on frequency, intensity, and current frequency factor
        // The frequencyFactor makes the trail "pulse" with the current note
        const width = 1 + (normalizedFreq * 10 * intensity * frequencyFactor);
        trailCtx.lineWidth = width;
        
        // Adjust opacity based on frequency, intensity, and current frequency factor
        const opacity = 0.2 + (normalizedFreq * 0.8 * intensity * (frequencyFactor * 0.5));
        trailCtx.strokeStyle = adjustOpacity(trailColor, opacity);
        
        // Connect to next point smoothly
        if (i < smoothedTrail.length - 1) {
            const xc = (point.x + smoothedTrail[i+1].x) / 2;
            const yc = (point.y + smoothedTrail[i+1].y) / 2;
            trailCtx.quadraticCurveTo(point.x, point.y, xc, yc);
        } else {
            trailCtx.lineTo(point.x, point.y);
        }
        
        // Complete current segment and start a new one to allow color changes
        trailCtx.stroke();
        trailCtx.beginPath();
        trailCtx.moveTo(point.x, point.y);
    }
}

// Enhanced drawNoteVisualization function for more vibrant visuals
function drawNoteVisualization() {
    noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
    
    // Draw expanding circles with enhanced styling
    noteCircles = noteCircles.filter(circle => {
        circle.radius += circle.growRate;
        circle.opacity -= 0.01;
        
        if (circle.radius > circle.maxRadius || circle.opacity <= 0) {
            return false;
        }
        
        // Add glow effect for more visual appeal
        const glow = 10 + (circle.radius / 5);
        noteCtx.shadowBlur = glow;
        noteCtx.shadowColor = circle.color;
        
        // Draw the circle
        noteCtx.beginPath();
        noteCtx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
        noteCtx.strokeStyle = adjustOpacity(circle.color, circle.opacity);
        noteCtx.lineWidth = 2;
        noteCtx.stroke();
        
        // Optional: Add a smaller filled circle for more emphasis
        if (circle.radius < 15) {
            noteCtx.beginPath();
            noteCtx.arc(circle.x, circle.y, circle.radius / 3, 0, Math.PI * 2);
            noteCtx.fillStyle = adjustOpacity(circle.color, circle.opacity * 0.7);
            noteCtx.fill();
        }
        
        // Reset shadow for next element
        noteCtx.shadowBlur = 0;
        
        return true;
    });
}

// ============================================================================
// PLANE VISUAL EFFECTS - Note-Reactive Lights & BPM Sync
// ============================================================================

// ============================================================================
// WEATHER VISUAL EFFECTS - Rain and Lightning
// ============================================================================

// Rain particles array
let rainDrops = [];

// Draw rain effect on canvas
function drawRainEffect() {
    if (!flightCanvas || !flightCtx) return;

    // Create new raindrops periodically
    if (Math.random() < 0.3) { // 30% chance each frame
        for (let i = 0; i < 3; i++) {
            rainDrops.push({
                x: Math.random() * flightCanvas.width,
                y: -10,
                length: 10 + Math.random() * 20,
                speed: 5 + Math.random() * 10,
                opacity: 0.3 + Math.random() * 0.4
            });
        }
    }

    // Update and draw raindrops
    flightCtx.save();
    flightCtx.strokeStyle = 'rgba(174, 194, 224, 0.6)'; // Light blue-white color
    flightCtx.lineWidth = 1;

    rainDrops = rainDrops.filter(drop => {
        // Update position
        drop.y += drop.speed;

        // Draw raindrop
        flightCtx.globalAlpha = drop.opacity;
        flightCtx.beginPath();
        flightCtx.moveTo(drop.x, drop.y);
        flightCtx.lineTo(drop.x, drop.y + drop.length);
        flightCtx.stroke();

        // Remove if off screen
        return drop.y < flightCanvas.height + 50;
    });

    flightCtx.restore();

    // Add subtle fog/mist effect
    flightCtx.fillStyle = 'rgba(180, 200, 220, 0.02)';
    flightCtx.fillRect(0, 0, flightCanvas.width, flightCanvas.height);
}

// Lightning flash effect
let lightningFlashTime = 0;
let nextLightningTime = Date.now() + 3000 + Math.random() * 7000; // Random 3-10 seconds
let lightningBrightness = 0;

function drawLightningFlash() {
    if (!flightCanvas || !flightCtx) return;

    const now = Date.now();

    // Trigger new lightning flash
    if (now >= nextLightningTime && lightningBrightness === 0) {
        lightningBrightness = 1;
        lightningFlashTime = now;
        nextLightningTime = now + 3000 + Math.random() * 7000; // Next flash in 3-10 seconds

        // Sometimes do a double flash
        if (Math.random() < 0.3) {
            setTimeout(() => {
                lightningBrightness = 1;
                lightningFlashTime = Date.now();
            }, 100 + Math.random() * 200);
        }
    }

    // Draw lightning flash
    if (lightningBrightness > 0) {
        const elapsed = now - lightningFlashTime;

        // Quick bright flash that fades rapidly
        if (elapsed < 100) {
            lightningBrightness = 1 - (elapsed / 100);
        } else if (elapsed < 150) {
            lightningBrightness = 0.5 * (1 - ((elapsed - 100) / 50));
        } else {
            lightningBrightness = 0;
        }

        if (lightningBrightness > 0) {
            flightCtx.save();
            flightCtx.fillStyle = `rgba(255, 255, 255, ${lightningBrightness * 0.3})`;
            flightCtx.fillRect(0, 0, flightCanvas.width, flightCanvas.height);

            // Add colored lightning tint (slight blue-purple)
            flightCtx.fillStyle = `rgba(200, 180, 255, ${lightningBrightness * 0.15})`;
            flightCtx.fillRect(0, 0, flightCanvas.width, flightCanvas.height);

            // Draw lightning bolts occasionally
            if (Math.random() < 0.3 && lightningBrightness > 0.7) {
                drawLightningBolt();
            }

            flightCtx.restore();
        }
    }
}

// Draw a lightning bolt
function drawLightningBolt() {
    if (!flightCtx) return;

    const startX = Math.random() * flightCanvas.width;
    const startY = 0;
    let x = startX;
    let y = startY;

    flightCtx.save();
    flightCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
    flightCtx.lineWidth = 2;
    flightCtx.shadowBlur = 10;
    flightCtx.shadowColor = 'rgba(200, 200, 255, 0.8)';
    flightCtx.beginPath();
    flightCtx.moveTo(x, y);

    // Create jagged lightning path
    const segments = 8 + Math.floor(Math.random() * 4);
    for (let i = 0; i < segments; i++) {
        x += (Math.random() - 0.5) * 60;
        y += (flightCanvas.height / segments) + (Math.random() - 0.5) * 30;
        flightCtx.lineTo(x, y);

        // Occasional branches
        if (Math.random() < 0.3) {
            flightCtx.moveTo(x, y);
            const branchX = x + (Math.random() - 0.5) * 80;
            const branchY = y + 40 + Math.random() * 40;
            flightCtx.lineTo(branchX, branchY);
            flightCtx.moveTo(x, y);
        }
    }

    flightCtx.stroke();
    flightCtx.restore();
}

// ============================================================================
// Flash plane lights when notes are played
function flashPlaneLights(frequency) {
    if (!plane) return;

    // Map frequency to a color hue (lower freq = red, higher = blue)
    const normalizedFreq = Math.min(1, Math.max(0, (frequency - 100) / 1500));
    const hue = 180 + (normalizedFreq * 180); // Range from cyan to magenta

    // Create a temporary light flash element
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.width = '6px';
    flash.style.height = '6px';
    flash.style.borderRadius = '50%';
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '12';
    flash.style.transition = 'opacity 0.3s ease-out';

    // Randomly flash one of the positions (nose, left wing, right wing, or tail)
    const positions = [
        { left: '50%', top: '10px', transform: 'translateX(-50%)' }, // Nose
        { left: '8px', top: '45px', transform: 'none' }, // Left wing
        { right: '8px', top: '45px', transform: 'none' }, // Right wing
        { left: '50%', bottom: '15px', transform: 'translateX(-50%)' } // Tail
    ];

    const pos = positions[Math.floor(Math.random() * positions.length)];
    Object.assign(flash.style, pos);

    flash.style.background = `hsl(${hue}, 100%, 60%)`;
    flash.style.boxShadow = `0 0 12px hsl(${hue}, 100%, 60%), 0 0 20px hsl(${hue}, 100%, 60%)`;
    flash.style.opacity = '1';

    plane.appendChild(flash);

    // Fade out and remove
    setTimeout(() => {
        flash.style.opacity = '0';
        setTimeout(() => flash.remove(), 300);
    }, 50);
}

// Update BPM-synced animation speed
let bpmSyncInterval = null;

function syncAnimationToBPM() {
    const bpm = parseFloat(tempoControl?.value) || 90;
    const beatDuration = 60 / bpm; // Duration of one beat in seconds

    // Update CSS animation durations dynamically
    if (plane) {
        plane.style.setProperty('--pulse-duration', `${beatDuration * 2}s`);
        plane.style.setProperty('--blink-duration', `${beatDuration * 1.5}s`);
    }

    // Update planePulse animation timing
    const styleSheet = Array.from(document.styleSheets).find(sheet => {
        try {
            return sheet.href === null || sheet.href.includes(window.location.hostname);
        } catch (e) {
            return false;
        }
    });

    if (styleSheet) {
        try {
            const rules = styleSheet.cssRules || styleSheet.rules;
            for (let i = 0; i < rules.length; i++) {
                const rule = rules[i];
                if (rule.selectorText === '.plane.flying') {
                    rule.style.animationDuration = `${beatDuration * 4}s, ${beatDuration * 2}s`;
                } else if (rule.selectorText === '.plane-engine::after') {
                    rule.style.animationDuration = `${beatDuration * 2}s`;
                }
            }
        } catch (e) {
            // Ignore CORS errors for external stylesheets
        }
    }
}

// Start BPM sync on tempo change
function startBPMSync() {
    syncAnimationToBPM();

    // Clear existing interval
    if (bpmSyncInterval) {
        clearInterval(bpmSyncInterval);
    }

    // Update every 100ms when flying
    bpmSyncInterval = setInterval(() => {
        if (isFlying) {
            syncAnimationToBPM();
        }
    }, 100);
}

// Stop BPM sync
function stopBPMSync() {
    if (bpmSyncInterval) {
        clearInterval(bpmSyncInterval);
        bpmSyncInterval = null;
    }
}

// Ensure BPM and visual effect functions are globally accessible
window.flashPlaneLights = flashPlaneLights;
window.syncAnimationToBPM = syncAnimationToBPM;
window.startBPMSync = startBPMSync;
window.stopBPMSync = stopBPMSync;
window.drawRainEffect = drawRainEffect;
window.drawLightningFlash = drawLightningFlash;
window.makeCitiesReactToNote = makeCitiesReactToNote;

// ============================================================================
// Sequencer class for ambient note generation
class AmbientSequencer {
    constructor(id) {
        this.id = id;
        this.currentPattern = null;
        this.patternIndex = 0;
        this.lastFrequency = 0;
        this.noteInterval = (3000 + Math.random() * 2000); // Different base interval for each sequencer
        this.nextNoteTime = 0;
    }

    selectPattern() {
        // Randomly choose between harmonic and plane note sets based on current destination
        this.currentPattern = Math.random() < 0.6 ? 
            harmonicNotes[Math.floor(Math.random() * harmonicNotes.length)] :
            planeNotes[Math.floor(Math.random() * planeNotes.length)];
        this.patternIndex = 0;
        
        // Randomize the next note interval
        // Use artist-specific note interval if available
        if (artistStyles[currentArtist] && artistStyles[currentArtist].noteInterval) {
            this.noteInterval = artistStyles[currentArtist].noteInterval * (0.8 + Math.random() * 0.4); // Slight randomness
        } else {
            this.noteInterval = 2000 + Math.random() * 5000;
        }
    }
    
    randomizeNoteTimer() {
        // Use BPM for timing
        let bpm = tempoControl ? parseFloat(tempoControl.value) : 90;
        
        // Calculate beat duration in seconds (60 seconds / BPM)
        const beatDuration = 60 / bpm;
        
        // Different note values for different sequencers
        // Sequencer 1: quarter notes, eighth notes, half notes
        // Sequencer 2: triplets, dotted notes
        let noteDuration;
        
        if (this.id === 1) {
            // For sequencer 1, use standard note values
            const noteValues = [0.5, 1, 2]; // half note, quarter note, eighth note (relative to beat)
            noteDuration = beatDuration * noteValues[Math.floor(Math.random() * noteValues.length)];
        } else {
            // For sequencer 2, use more complex rhythms
            const noteValues = [0.75, 1.5, 0.33, 0.66]; // dotted notes and triplets
            noteDuration = beatDuration * noteValues[Math.floor(Math.random() * noteValues.length)];
        }
        
        // Add slight humanization (±10%)
        const humanization = 1 + ((Math.random() * 0.2) - 0.1);
        noteDuration *= humanization;
        
        // Set next note time
        this.nextNoteTime = audioContext.currentTime + noteDuration;
    }

    playNote() {
        if (!isFlying || !audioContext) {
            if (!isFlying) console.log('Sequencer', this.id, ': Not flying, skipping note');
            if (!audioContext) console.log('Sequencer', this.id, ': No audio context, skipping note');
            return;
        }
        if (!this.currentPattern) this.selectPattern();

        try {
            // Check if audio context is running
            if (audioContext.state !== 'running') {
                console.warn('Sequencer', this.id, ': AudioContext not running (state:', audioContext.state, '), trying to resume...');
                audioContext.resume().then(() => {
                    console.log('Sequencer', this.id, ': AudioContext resumed in playNote');
                    // Try again after resuming
                    setTimeout(() => this.playNote(), 100);
                }).catch(err => {
                    console.error('Sequencer', this.id, ': Failed to resume AudioContext in playNote:', err);
                });
                return;
            }
            
            // Get settings from controls
            const decayTime = parseFloat(decayControl.value);
            const volume = parseFloat(volumeControl.value) * (this.id === 2 ? 0.7 : 1.0); // Sequencer 2 slightly quieter
            const altitude = parseFloat(altitudeControl.value);

            // Select a note from the current pattern
            const baseFreq = 261.63 * altitude; // Middle C adjusted by altitude
            const noteIndex = Math.floor(Math.random() * this.currentPattern.length); // Pick random note from pattern
            const noteFreq = this.currentPattern[noteIndex];
            
            // Prevent ultra-high frequencies that cause warnings
            let frequency;
            if (typeof noteFreq === 'number') {
                const rawFreq = baseFreq * Math.pow(2, noteFreq / 12);
                // Clamp frequency to a reasonable range to avoid warnings
                frequency = Math.min(20000, Math.max(safeLowFreq, rawFreq)); // Use safeLowFreq as minimum
            } else {
                frequency = Math.min(20000, Math.max(safeLowFreq, noteFreq)); // Use safeLowFreq as minimum
            }
            
            this.lastFrequency = frequency;

            // Store note data for announcements
            lastNoteData = {...currentNoteData};
            currentNoteData = {
                frequency: frequency,
                time: audioContext.currentTime,
                sequencerId: this.id
            };
            
            // Create oscillator
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Use different waveforms for variation based on sequencer
            const waveforms = this.id === 1 ? ['sine', 'triangle'] : ['sine', 'triangle', 'sawtooth'];
            oscillator.type = waveforms[Math.floor(Math.random() * waveforms.length)];
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            // Soft attack and long decay for ambient feel
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.2 + Math.random() * 0.3);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + decayTime);

            // Connect nodes to master gain (all safety nodes are in the chain from there)
            oscillator.connect(gainNode);
            gainNode.connect(masterGainNode);

            // Start and stop oscillator
            oscillator.start();
            oscillator.stop(audioContext.currentTime + decayTime);

            // Store for potential future management
            activeOscillators.push(oscillator);

            // Track note in flight log
            trackNotePlayed();

            // Log successful note creation (only occasionally to avoid spam)
            if (Math.random() < 0.1) {
                console.log('Sequencer', this.id, ': Playing note at', frequency.toFixed(2), 'Hz, decay:', decayTime + 's');
            }

            // Increment pattern index and occasionally randomize
            this.patternIndex++;
            if (Math.random() < 0.15) this.selectPattern();

            // Visualize note and affect plane movement
            this.visualizeNote(frequency);
            this.affectPlaneMovement(frequency);
            
            // Create a landscape element
            if (Math.random() < 0.4) {
                createLandscapeElement(frequency);
            }
            
            // Generate announcements based on note interaction
            if (this.id === 1 && Math.random() < 0.08) { // Only first sequencer generates announcements (8% chance)
                generateAnnouncement();
            }
            
            // Show a city with notes at regular intervals
            if (this.id === 1) {
                showCityWithNote();
            }
            
            // Randomize next note time
            this.randomizeNoteTimer();
            
            // Schedule next note check
            setTimeout(() => this.checkAndPlayNote(), 100);
            
        } catch (error) {
            console.error('Error playing note:', error);
            showStatus('Error playing note: ' + error.message);
            
            // Try again later
            this.randomizeNoteTimer();
            setTimeout(() => this.checkAndPlayNote(), 1000);
        }
    }
    
    checkAndPlayNote() {
        if (!isFlying || !audioContext) return;
        
        // Check if it's time to play the next note
        if (audioContext.currentTime >= this.nextNoteTime) {
            this.playNote();
        } else {
            // Check again soon
            setTimeout(() => this.checkAndPlayNote(), 100);
        }
    }
    
    // Enhanced visualizeNote function to create more visual flair
    visualizeNote(frequency) {
        // Create expanding circle at plane position
        const normalizedFreq = (frequency - 100) / 500;
        
        // Use artist-specific note color if available
        let noteColor;
        if (artistStyles[currentArtist] && artistStyles[currentArtist].noteColor) {
            noteColor = artistStyles[currentArtist].noteColor;
        } else {
            const colorIndex = Math.floor(normalizedFreq * colors.notes.length) % colors.notes.length;
            noteColor = colors.notes[colorIndex] || colors.notes[0];
        }
        
        // Use the actual plane position
        const planePixelX = (planePosition.x * flightCanvas.width / 100);
        const planePixelY = (planePosition.y * flightCanvas.height / 100);
        
        // Create multiple circles with varying distances from the plane
        // More circles = more visual flair
        const circleCount = this.id === 1 ? 3 : 2; // More circles for primary sequencer
        
        for (let i = 0; i < circleCount; i++) {
            // Wider distribution of circles
            const distanceFactor = 20 + (i * 15); // Increasing distance for each circle
            const xOffset = (Math.random() * distanceFactor * 2) - distanceFactor;
            const yOffset = (Math.random() * distanceFactor * 2) - distanceFactor;
            
            // Only create circles that aren't directly on the plane
            if (Math.abs(xOffset) > 10 || Math.abs(yOffset) > 10) {
                const circle = {
                    x: planePixelX + xOffset,
                    y: planePixelY + yOffset,
                    radius: 3 + (Math.random() * 4), // Varying initial radius
                    maxRadius: 20 + Math.random() * 50, // Larger max radius for more visible effects
                    color: noteColor,
                    opacity: 0.7 + (Math.random() * 0.3), // Varying opacity
                    growRate: 0.4 + Math.random() * 0.6, // Varying growth rate
                    sequencerId: this.id
                };
                
                noteCircles.push(circle);
            }
        }
        
        // Add point to the permanent trail using the newest frequency
        // Higher probability = more trail points = more visual interest
        if (isFlying && trailPermaMode && Math.random() < 0.35) {
            smoothedTrail.push({
                x: planePixelX,
                y: planePixelY,
                frequency: frequency
            });
            
            // Limit trail points
            if (smoothedTrail.length > MAX_SMOOTHED_POINTS) {
                smoothedTrail.shift();
            }
        }

        // Trigger note-reactive lights
        flashPlaneLights(frequency);

        // Make nearby cities glow in response to notes
        makeCitiesReactToNote(planePixelX, planePixelY, frequency);
    }

    affectPlaneMovement(frequency) {
        // Change plane direction based on frequency
        const normalizedFreq = (frequency - 100) / 500;
        
        // Add a small random change to direction
        planeDirection.x += (Math.random() * 0.1 - 0.05) * normalizedFreq;
        planeDirection.y += (Math.random() * 0.1 - 0.05) * normalizedFreq;
        
        // Limit direction change
        planeDirection.x = Math.max(-0.1, Math.min(0.1, planeDirection.x));
        planeDirection.y = Math.max(-0.07, Math.min(0.07, planeDirection.y));
        
        // Normalize direction vector for consistent speed
        const magnitude = Math.sqrt(
            planeDirection.x * planeDirection.x + 
            planeDirection.y * planeDirection.y
        );
        
        if (magnitude > 0) {
            planeDirection.x /= magnitude;
            planeDirection.y /= magnitude;
            
            // Scale direction based on frequency and tempo
            const tempo = tempoControl ? parseFloat(tempoControl.value) : 90;
            const tempoFactor = tempo / 100; // Base speed at 100 BPM
            const speedFactor = (0.1 + (normalizedFreq * 0.15)) * tempoFactor * planeMovementSpeed;
            
            planeDirection.x *= speedFactor;
            planeDirection.y *= speedFactor;
        }
    }
    
    start() {
        if (!audioContext) return;
        this.randomizeNoteTimer();
        this.checkAndPlayNote();
    }
    
    stop() {
        // Nothing to do here, the checks in playNote will prevent further notes
    }
}

// Initialize the application when document is ready
document.addEventListener('DOMContentLoaded', init);

// Initialize even if DOMContentLoaded already fired (for some browsers)
if (document.readyState === 'interactive' || document.readyState === 'complete') {
    console.log('Document already loaded, initializing immediately');
    init();
}
// =============================================================================
// NEW IFE UI CONTROLS
// =============================================================================

// Panel collapse/expand
const controlPanel = document.getElementById('controlPanel');
const panelHeader = document.getElementById('panelHeader');
let isPanelExpanded = false;

function togglePanel() {
    isPanelExpanded = !isPanelExpanded;
    if (isPanelExpanded) {
        controlPanel.classList.remove('collapsed');
        controlPanel.classList.add('expanded');
        logDebug('UI', 'Control panel expanded');
    } else {
        controlPanel.classList.add('collapsed');
        controlPanel.classList.remove('expanded');
        logDebug('UI', 'Control panel collapsed');
    }
}

panelHeader.addEventListener('click', togglePanel);

// Tab switching
const tabButtons = document.querySelectorAll('.tab-button');
const tabContents = document.querySelectorAll('.tab-content');

tabButtons.forEach(button => {
    button.addEventListener('click', () => {
        const tabName = button.getAttribute('data-tab');
        
        // Remove active from all tabs
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabContents.forEach(content => content.classList.remove('active'));
        
        // Add active to clicked tab
        button.classList.add('active');
        const activeContent = document.getElementById(`${tabName}-tab`) || document.getElementById(`${tabName}-tab-content`);
        if (activeContent) {
            activeContent.classList.add('active');
        }
        
        logDebug('UI', `Switched to tab: ${tabName}`);
    });
});

// Update header stats in real-time
function updateHeaderStats() {
    // Flight time
    const headerFlightTime = document.getElementById('headerFlightTime');
    const flightTime = document.getElementById('flightTime');
    if (headerFlightTime && flightTime) {
        headerFlightTime.textContent = flightTime.textContent;
    }
    
    // Altitude
    const headerAltitude = document.getElementById('headerAltitude');
    const flightAltitude = document.getElementById('flightAltitude');
    if (headerAltitude && flightAltitude) {
        headerAltitude.textContent = flightAltitude.textContent;
    }
    
    // Destination
    const headerDestination = document.getElementById('headerDestination');
    const currentDest = document.getElementById('currentDestination');
    if (headerDestination && currentDest) {
        headerDestination.textContent = currentDest.textContent;
    }
    
    // Tempo
    const headerTempo = document.getElementById('headerTempo');
    const tempoBPM = document.getElementById('tempoBPM');
    if (headerTempo && tempoBPM) {
        headerTempo.textContent = tempoBPM.textContent;
    }
    
    // Status
    const headerStatus = document.getElementById('headerStatus');
    if (headerStatus) {
        headerStatus.textContent = isFlying ? 'In Flight' : (isLanded ? 'Landed' : 'Ready');
    }
}

// Update header stats every second
setInterval(updateHeaderStats, 1000);

// Keyboard shortcut to toggle panel (C key still works)
document.addEventListener('keydown', (e) => {
    if (e.key === 'c' || e.key === 'C') {
        // Original cockpit toggle
        if (cockpitToggle && typeof cockpitToggle.click === 'function') {
            // Keep the old function working
        }
        // Also toggle new panel
        togglePanel();
    }
});

// Sync dark mode toggle in both locations
const darkModeToggle2 = document.getElementById('darkModeToggle2');
if (darkModeToggle2 && darkModeToggle) {
    darkModeToggle2.addEventListener('change', function() {
        darkModeToggle.checked = this.checked;
        darkModeToggle.dispatchEvent(new Event('change'));
    });
    
    darkModeToggle.addEventListener('change', function() {
        darkModeToggle2.checked = this.checked;
    });
}

// Update all slider value displays
function setupSliderValueDisplays() {
    // Volume
    const volumeControl = document.getElementById('volume');
    const volumeValue = document.getElementById('volumeValue');
    if (volumeControl && volumeValue) {
        volumeControl.addEventListener('input', () => {
            volumeValue.textContent = parseFloat(volumeControl.value).toFixed(2);
        });
    }
    
    // Reverb
    const reverbControl = document.getElementById('reverb');
    const reverbValue = document.getElementById('reverbValue');
    if (reverbControl && reverbValue) {
        reverbControl.addEventListener('input', () => {
            reverbValue.textContent = Math.round(parseFloat(reverbControl.value) * 100) + '%';
        });
    }
    
    // Decay
    const decayControl = document.getElementById('decay');
    const decayValue = document.getElementById('decayValue');
    if (decayControl && decayValue) {
        decayControl.addEventListener('input', () => {
            decayValue.textContent = parseFloat(decayControl.value).toFixed(1) + 's';
        });
    }
    
    // Bass Level
    const bassLevelControl = document.getElementById('bassLevel');
    const bassLevelValue = document.getElementById('bassLevelValue');
    if (bassLevelControl && bassLevelValue) {
        bassLevelControl.addEventListener('input', () => {
            bassLevelValue.textContent = Math.round(parseFloat(bassLevelControl.value) * 100) + '%';
        });
    }
    
    // Tempo
    const tempoControlSlider = document.getElementById('tempo');
    const tempoValueDisplay = document.getElementById('tempoValue');
    if (tempoControlSlider && tempoValueDisplay) {
        tempoControlSlider.addEventListener('input', () => {
            tempoValueDisplay.textContent = tempoControlSlider.value;
        });
    }
    
    // Altitude
    const altitudeControlSlider = document.getElementById('altitude');
    const altitudeValueDisplay = document.getElementById('altitudeValue');
    if (altitudeControlSlider && altitudeValueDisplay) {
        altitudeControlSlider.addEventListener('input', () => {
            const val = parseFloat(altitudeControlSlider.value);
            if (val < 0.7) altitudeValueDisplay.textContent = 'Low';
            else if (val < 1.3) altitudeValueDisplay.textContent = 'Cruising';
            else altitudeValueDisplay.textContent = 'High';
        });
    }
    
    // Trail Intensity
    const trailIntensityControlSlider = document.getElementById('trailIntensity');
    const trailIntensityValueDisplay = document.getElementById('trailIntensityValue');
    if (trailIntensityControlSlider && trailIntensityValueDisplay) {
        trailIntensityControlSlider.addEventListener('input', () => {
            trailIntensityValueDisplay.textContent = parseFloat(trailIntensityControlSlider.value).toFixed(1);
        });
    }
    
    // Persistence
    const persistenceControlSlider = document.getElementById('persistence');
    const persistenceValueDisplay = document.getElementById('persistenceValue');
    if (persistenceControlSlider && persistenceValueDisplay) {
        persistenceControlSlider.addEventListener('input', () => {
            persistenceValueDisplay.textContent = Math.round(parseFloat(persistenceControlSlider.value) * 100) + '%';
        });
    }
    
    // Filter Cutoff
    const filterCutoffControl = document.getElementById('filterCutoff');
    const filterCutoffValue = document.getElementById('filterCutoffValue');
    if (filterCutoffControl && filterCutoffValue) {
        filterCutoffControl.addEventListener('input', () => {
            filterCutoffValue.textContent = filterCutoffControl.value + ' Hz';
        });
    }
    
    // LFO Rate
    const lfoRateControl = document.getElementById('lfoRate');
    const lfoRateValue = document.getElementById('lfoRateValue');
    if (lfoRateControl && lfoRateValue) {
        lfoRateControl.addEventListener('input', () => {
            const divisionNames = ['1/16 Note', '1/8 Note', '1/4 Note', '1/2 Note', '1 Bar', '2 Bars', '4 Bars', '8 Bars'];
            lfoRateValue.textContent = divisionNames[parseInt(lfoRateControl.value)] || '1/4 Note';
        });
    }
    
    // LFO Amount
    const lfoAmountControl = document.getElementById('lfoAmount');
    const lfoAmountValue = document.getElementById('lfoAmountValue');
    if (lfoAmountControl && lfoAmountValue) {
        lfoAmountControl.addEventListener('input', () => {
            lfoAmountValue.textContent = lfoAmountControl.value + '%';
        });
    }
    
    // Compressor controls
    const compThresholdControl = document.getElementById('compThreshold');
    const compThresholdValue = document.getElementById('compThresholdValue');
    if (compThresholdControl && compThresholdValue) {
        compThresholdControl.addEventListener('input', () => {
            compThresholdValue.textContent = compThresholdControl.value + ' dB';
        });
    }
    
    const compRatioControl = document.getElementById('compRatio');
    const compRatioValue = document.getElementById('compRatioValue');
    if (compRatioControl && compRatioValue) {
        compRatioControl.addEventListener('input', () => {
            compRatioValue.textContent = compRatioControl.value + ':1';
        });
    }
    
    const compAttackControl = document.getElementById('compAttack');
    const compAttackValue = document.getElementById('compAttackValue');
    if (compAttackControl && compAttackValue) {
        compAttackControl.addEventListener('input', () => {
            compAttackValue.textContent = parseFloat(compAttackControl.value).toFixed(2) + 's';
        });
    }
    
    const compReleaseControl = document.getElementById('compRelease');
    const compReleaseValue = document.getElementById('compReleaseValue');
    if (compReleaseControl && compReleaseValue) {
        compReleaseControl.addEventListener('input', () => {
            compReleaseValue.textContent = parseFloat(compReleaseControl.value).toFixed(2) + 's';
        });
    }
    
    // Musical particles controls
    const particleAttackControlSlider = document.getElementById('particleAttackControl');
    const particleAttackValueDisplay = document.getElementById('particleAttackValue');
    if (particleAttackControlSlider && particleAttackValueDisplay) {
        particleAttackControlSlider.addEventListener('input', () => {
            particleAttackValueDisplay.textContent = parseFloat(particleAttackControlSlider.value).toFixed(2) + 's';
        });
    }
    
    const particleReleaseControlSlider = document.getElementById('particleReleaseControl');
    const particleReleaseValueDisplay = document.getElementById('particleReleaseValue');
    if (particleReleaseControlSlider && particleReleaseValueDisplay) {
        particleReleaseControlSlider.addEventListener('input', () => {
            particleReleaseValueDisplay.textContent = parseFloat(particleReleaseControlSlider.value).toFixed(1) + 's';
        });
    }
    
    const particleGravityControlSlider = document.getElementById('particleGravityControl');
    const particleGravityValueDisplay = document.getElementById('particleGravityValue');
    if (particleGravityControlSlider && particleGravityValueDisplay) {
        particleGravityControlSlider.addEventListener('input', () => {
            particleGravityValueDisplay.textContent = parseFloat(particleGravityControlSlider.value).toFixed(1);
        });
    }
    
    const particleDensityControlSlider = document.getElementById('particleDensityControl');
    const particleDensityValueDisplay = document.getElementById('particleDensityValue');
    if (particleDensityControlSlider && particleDensityValueDisplay) {
        particleDensityControlSlider.addEventListener('input', () => {
            particleDensityValueDisplay.textContent = Math.round(parseFloat(particleDensityControlSlider.value) * 100) + '%';
        });
    }
    
    // Settings panel controls
    const safeLowFreqControl = document.getElementById('safeLowFreq');
    const safeLowFreqValue = document.getElementById('safeLowFreqValue');
    if (safeLowFreqControl && safeLowFreqValue) {
        safeLowFreqControl.addEventListener('input', () => {
            safeLowFreqValue.textContent = safeLowFreqControl.value + ' Hz';
        });
    }
    
    const limiterThresholdControl = document.getElementById('limiterThreshold');
    const limiterThresholdValue = document.getElementById('limiterThresholdValue');
    if (limiterThresholdControl && limiterThresholdValue) {
        limiterThresholdControl.addEventListener('input', () => {
            limiterThresholdValue.textContent = parseFloat(limiterThresholdControl.value).toFixed(1) + ' dB';
        });
    }
}

// Initialize slider displays when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupSliderValueDisplays);
} else {
    setupSliderValueDisplays();
}

// Map destination buttons to use new styling
const destButtons = document.querySelectorAll('.destination-btn');
destButtons.forEach(btn => {
    btn.addEventListener('click', () => {
        destButtons.forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
    });
});

// Show/hide musical particles controls
const musicalParticlesToggleControl = document.getElementById('musicalParticlesToggle');
const musicalParticlesPanel = document.getElementById('musicalParticlesControlsPanel');
if (musicalParticlesToggleControl && musicalParticlesPanel) {
    musicalParticlesToggleControl.addEventListener('change', function() {
        if (this.checked) {
            musicalParticlesPanel.style.display = 'block';
        } else {
            musicalParticlesPanel.style.display = 'none';
        }
    });
}

logInfo('UI', 'IFE-style UI controls initialized');

// =============================================================================
// THEME SYSTEM
// =============================================================================

function initThemeSystem() {
    const themeSelector = document.getElementById('themeSelector');
    const body = document.body;
    
    // Load saved theme
    const savedTheme = localStorage.getItem('cabin-theme') || 'classic';
    if (themeSelector) {
        themeSelector.value = savedTheme;
        applyTheme(savedTheme);
    }
    
    // Theme change handler
    if (themeSelector) {
        themeSelector.addEventListener('change', function() {
            const theme = this.value;
            applyTheme(theme);
            localStorage.setItem('cabin-theme', theme);
            logInfo('THEME', 'Theme changed to: ' + theme);
        });
    }
    
    function applyTheme(theme) {
        // Remove all theme classes
        body.classList.remove('theme-dawn', 'theme-ocean', 'theme-northern', 'theme-desert');
        
        // Apply selected theme
        if (theme !== 'classic') {
            body.classList.add('theme-' + theme);
        }
    }
}

// =============================================================================
// ENHANCED PLANE ANIMATIONS
// =============================================================================

function initPlaneAnimations() {
    const plane = document.getElementById('plane');
    if (!plane) return;
    
    let planeRotation = 0;
    let targetRotation = 0;
    
    function updatePlaneAnimation() {
        if (!isFlying) return;
        
        // Add flying class for bobbing animation
        plane.classList.add('flying');
        
        // Smooth rotation based on direction
        const dx = planeDirection.x;
        const dy = planeDirection.y;
        targetRotation = Math.atan2(dy, dx) * (180 / Math.PI);
        
        // Smooth interpolation
        planeRotation += (targetRotation - planeRotation) * 0.1;
        plane.style.setProperty('--plane-rotation', planeRotation + 'deg');
        
        requestAnimationFrame(updatePlaneAnimation);
    }
    
    // Start animation when flying
    if (isFlying) {
        updatePlaneAnimation();
    }
}

// =============================================================================
// MAP INTERACTIVITY ENHANCEMENTS
// =============================================================================

function initMapInteractivity() {
    const cityLabels = document.querySelectorAll('.city-label');
    
    // Make city markers glow when their scale/region is active
    function updateCityGlow(activeRegion) {
        cityLabels.forEach(label => {
            if (label.classList.contains('region-' + activeRegion)) {
                label.classList.add('active-scale');
            } else {
                label.classList.remove('active-scale');
            }
        });
    }
    
    // Create destination markers (pulsing circles)
    function createDestinationMarker(x, y) {
        const marker = document.createElement('div');
        marker.className = 'destination-marker';
        marker.style.left = x + 'px';
        marker.style.top = y + 'px';
        marker.style.zIndex = '8';
        document.getElementById('flightContainer').appendChild(marker);
        return marker;
    }
    
    window.updateCityGlow = updateCityGlow;
    window.createDestinationMarker = createDestinationMarker;
}

// =============================================================================
// AUDIO-REACTIVE POLISH
// =============================================================================

function initAudioReactive() {
    const audioMeter = document.getElementById('audioMeter');
    const audioLevelLabel = document.getElementById('audioLevelLabel');
    
    // Create volume meter fill element
    if (audioMeter && !audioMeter.querySelector('.volume-meter-fill')) {
        const fill = document.createElement('div');
        fill.className = 'volume-meter-fill';
        fill.style.width = '0%';
        audioMeter.appendChild(fill);
    }
    
    // Update volume meter with smooth easing
    let currentVolume = 0;
    function updateVolumeMeter(level) {
        const fill = audioMeter ? audioMeter.querySelector('.volume-meter-fill') : null;
        if (!fill) return;
        
        // Smooth easing
        currentVolume += (level - currentVolume) * 0.3;
        const percentage = Math.min(100, currentVolume * 100);
        fill.style.width = percentage + '%';
        
        // Update dB label
        if (audioLevelLabel) {
            const db = currentVolume > 0 ? (20 * Math.log10(currentVolume)).toFixed(1) : '-∞';
            audioLevelLabel.textContent = db + ' dB';
        }
    }
    
    window.updateVolumeMeter = updateVolumeMeter;
    
    // LED indicators pulse with beat
    function pulseLEDIndicators() {
        const leds = document.querySelectorAll('.led-indicator');
        leds.forEach(led => {
            if (isFlying) {
                led.classList.add('active');
            } else {
                led.classList.remove('active');
            }
        });
    }
    
    setInterval(pulseLEDIndicators, 1000);
}

// =============================================================================
// CONTROL PANEL ENHANCEMENTS
// =============================================================================

function initControlPanelEnhancements() {
    // Collapsible sections
    const collapsibleSections = document.querySelectorAll('.control-section.collapsible');
    collapsibleSections.forEach(section => {
        const title = section.querySelector('.control-section-title');
        if (title) {
            title.addEventListener('click', () => {
                section.classList.toggle('collapsed');
            });
        }
    });
    
    // Swipe gesture for mobile panel toggle
    let touchStartY = 0;
    let touchEndY = 0;
    const panelHeader = document.getElementById('panelHeader');
    const controlPanel = document.getElementById('controlPanel');
    
    if (panelHeader && controlPanel) {
        panelHeader.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        panelHeader.addEventListener('touchend', (e) => {
            touchEndY = e.changedTouches[0].clientY;
            handleSwipe();
        }, { passive: true });
        
        function handleSwipe() {
            const swipeDistance = touchStartY - touchEndY;
            if (Math.abs(swipeDistance) > 50) {
                if (swipeDistance > 0) {
                    // Swipe up - expand
                    if (controlPanel.classList.contains('collapsed')) {
                        togglePanel();
                    }
                } else {
                    // Swipe down - collapse
                    if (controlPanel.classList.contains('expanded')) {
                        togglePanel();
                    }
                }
            }
        }
    }
}

// =============================================================================
// ARTFUL DETAILS
// =============================================================================

function initArtfulDetails() {
    // Time-of-day lighting tint (cycles through day)
    let timeOfDay = 0; // 0-24 hour simulation
    const mapView = document.querySelector('.map-view');
    
    function updateTimeOfDay() {
        if (!isFlying) return;
        
        timeOfDay += 0.01; // Slowly advance time
        if (timeOfDay >= 24) timeOfDay = 0;
        
        // Remove all time classes
        mapView.classList.remove('time-dawn', 'time-day', 'time-dusk', 'time-night');
        
        // Apply appropriate class
        if (timeOfDay < 6) {
            mapView.classList.add('time-night');
        } else if (timeOfDay < 8) {
            mapView.classList.add('time-dawn');
        } else if (timeOfDay < 17) {
            mapView.classList.add('time-day');
        } else if (timeOfDay < 20) {
            mapView.classList.add('time-dusk');
        } else {
            mapView.classList.add('time-night');
        }
    }
    
    setInterval(updateTimeOfDay, 1000);
    
    // Floating ambient particles
    function createAmbientParticles() {
        const particlesContainer = document.getElementById('ambientParticles');
        if (!particlesContainer) return;
        
        for (let i = 0; i < 5; i++) {
            const particle = document.createElement('div');
            particle.className = 'ambient-particle';
            particle.style.left = (Math.random() * 100) + '%';
            particle.style.top = (Math.random() * 100) + '%';
            particle.style.animationDelay = (Math.random() * 20) + 's';
            particle.style.animationDuration = (15 + Math.random() * 10) + 's';
            particlesContainer.appendChild(particle);
        }
    }
    
    createAmbientParticles();
}

// =============================================================================
// MOBILE OPTIMIZATIONS
// =============================================================================

function initMobileOptimizations() {
    // Prevent zoom on double-tap (already in CSS, but reinforce)
    document.addEventListener('dblclick', (e) => {
        e.preventDefault();
    }, { passive: false });
    
    // Improve scrolling performance
    const tabContents = document.querySelectorAll('.tab-content');
    tabContents.forEach(content => {
        let isScrolling = false;
        content.addEventListener('scroll', () => {
            isScrolling = true;
        }, { passive: true });
        
        // Optimize rendering during scroll
        setInterval(() => {
            if (isScrolling) {
                isScrolling = false;
            }
        }, 100);
    });
    
    // Haptic feedback simulation (visual only)
    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(button => {
        button.addEventListener('touchstart', function() {
            this.style.transform = 'scale(0.95)';
        }, { passive: true });
        
        button.addEventListener('touchend', function() {
            this.style.transform = '';
        }, { passive: true });
    });
}

// =============================================================================
// INITIALIZE ALL ENHANCEMENTS
// =============================================================================

function initAllEnhancements() {
    try {
        initThemeSystem();
        logInfo('ENHANCEMENTS', 'Theme system initialized');
    } catch (e) {
        logError('ENHANCEMENTS', 'Theme system failed', e);
    }
    
    try {
        initPlaneAnimations();
        logInfo('ENHANCEMENTS', 'Plane animations initialized');
    } catch (e) {
        logError('ENHANCEMENTS', 'Plane animations failed', e);
    }
    
    try {
        initMapInteractivity();
        logInfo('ENHANCEMENTS', 'Map interactivity initialized');
    } catch (e) {
        logError('ENHANCEMENTS', 'Map interactivity failed', e);
    }
    
    try {
        initAudioReactive();
        logInfo('ENHANCEMENTS', 'Audio-reactive features initialized');
    } catch (e) {
        logError('ENHANCEMENTS', 'Audio-reactive failed', e);
    }
    
    try {
        initControlPanelEnhancements();
        logInfo('ENHANCEMENTS', 'Control panel enhancements initialized');
    } catch (e) {
        logError('ENHANCEMENTS', 'Control panel enhancements failed', e);
    }
    
    try {
        initArtfulDetails();
        logInfo('ENHANCEMENTS', 'Artful details initialized');
    } catch (e) {
        logError('ENHANCEMENTS', 'Artful details failed', e);
    }
    
    try {
        initMobileOptimizations();
        logInfo('ENHANCEMENTS', 'Mobile optimizations initialized');
    } catch (e) {
        logError('ENHANCEMENTS', 'Mobile optimizations failed', e);
    }
    
    logInfo('ENHANCEMENTS', '=== All enhancements initialized successfully ===');
}

// Call after DOMContentLoaded
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initAllEnhancements, 100);
    });
} else {
    setTimeout(initAllEnhancements, 100);
}

// =============================================================================
// CONSOLIDATED GLOBAL FUNCTION ASSIGNMENTS
// Assign all critical functions to window object in one place
// =============================================================================
window.takeOff = takeOff;
window.land = land;
window.testAudio = testAudio;
window.changeDestination = changeDestination;
window.hideWelcomeOverlay = hideWelcomeOverlay;
window.hideFlightLog = hideFlightLog;
window.downloadFlightLog = downloadFlightLog;
window.playInteractiveNote = playInteractiveNote;
window.createClickRipple = createClickRipple;
window.flashPlaneLights = flashPlaneLights;
window.syncAnimationToBPM = syncAnimationToBPM;
window.startBPMSync = startBPMSync;
window.stopBPMSync = stopBPMSync;
window.drawRainEffect = drawRainEffect;
window.drawLightningFlash = drawLightningFlash;
window.makeCitiesReactToNote = makeCitiesReactToNote;

console.log('[INIT] All critical functions assigned to window object');

// =============================================================================
// GLOBAL FUNCTION SAFETY CHECK
// Ensure all critical functions are accessible globally
// This prevents ReferenceErrors if functions are called before assignment
// =============================================================================
(function() {
    'use strict';

    // List of functions that must be globally accessible
    const criticalFunctions = [
        'takeOff',
        'land',
        'testAudio',
        'changeDestination',
        'hideWelcomeOverlay',
        'hideFlightLog',
        'downloadFlightLog',
        'playInteractiveNote',
        'createClickRipple',
        'flashPlaneLights',
        'syncAnimationToBPM',
        'startBPMSync',
        'stopBPMSync',
        'drawRainEffect',
        'drawLightningFlash',
        'makeCitiesReactToNote'
    ];

    // Check each function and log if missing
    criticalFunctions.forEach(funcName => {
        if (typeof window[funcName] !== 'function') {
            console.warn(`[SAFETY CHECK] Function '${funcName}' is not defined on window object`);
        } else {
            console.log(`[SAFETY CHECK] ✓ Function '${funcName}' is properly defined`);
        }
    });

    // Log success
    const definedCount = criticalFunctions.filter(f => typeof window[f] === 'function').length;
    console.log(`[SAFETY CHECK] ${definedCount}/${criticalFunctions.length} critical functions are properly defined`);
})();


</script>
    </body>
</html>
