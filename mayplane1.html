<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Music for Airplanes</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --dark-bg: #1a2f38;
            --panel-bg: rgba(25, 35, 45, 0.95);
            --text-color: #ecf0f1;
            --border-radius: 8px;
            --transition-speed: 0.3s;
            --cockpit-dark: #1a1e24;
            --cockpit-mid: #2a3038;
            --cockpit-light: #3a424d;
            --gauge-bg: #121518;
            --led-off: #444;
            --led-red: #e74c3c;
            --led-green: #2ecc71;
            --led-blue: #3498db;
            --led-yellow: #f39c12;
            --panel-border: #566573;
            --switch-off: #343d46;
            --switch-on: #516170;
        }

        /* Dark mode variables */
        .dark-mode {
            --dark-bg: #0f1922;
            --panel-bg: rgba(15, 22, 30, 0.95);
            --cockpit-dark: #0b0d10;
            --cockpit-mid: #151820;
            --cockpit-light: #1f2630;
            --gauge-bg: #080a0c;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
            background-color: var(--dark-bg);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            -webkit-text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.5s ease;
        }
        
        /* Container */
        .container {
            max-width: 1200px;
            width: 100%;
            padding: 0;
            margin: 0 auto;
            box-sizing: border-box;
        }
        
        h1 {
            text-align: center;
            margin: 10px 0;
            color: var(--primary-color);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            font-weight: 600;
            font-size: 1.6rem;
        }
        
        /* Integrated flight display with controls overlay */
        .flight-display {
            background-color: var(--cockpit-dark);
            padding: 0;
            border-radius: var(--border-radius);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            height: 75vh;
            min-height: 450px;
            position: relative;
            width: 100%;
            border: 2px solid #34495e;
            margin-bottom: 10px;
        }
        
        /* Make sure all canvases fill the entire display */
        #flightCanvas, 
        #noteVisualization, 
        #landscapeCanvas, 
        #starsCanvas,
        #trailCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            z-index: 1;
        }
        
        /* Sky gradient elements */
        #skyGradientTop, 
        #skyGradientBottom {
            position: absolute;
            left: 0;
            width: 100%;
            z-index: -1;
            transition: background-color 5s ease;
        }
        
        #skyGradientTop {
            top: 0;
            height: 50%;
            background: rgb(50, 90, 170);
        }
        
        #skyGradientBottom {
            bottom: 0;
            height: 50%;
            background: rgb(110, 160, 200);
        }

        /* Modern Airplane Design */
        .plane {
            position: absolute;
            width: 140px;
            height: 70px;
            z-index: 10;
            transform-origin: center;
            transition: transform 0.5s ease;
        }
        
        .plane-body {
            position: absolute;
            width: 110px;
            height: 18px;
            background-color: #ffffff;
            border: 1px solid #333;
            left: 15px;
            top: 26px;
            z-index: 2;
            border-radius: 20px 5px 5px 20px; /* Rounded nose */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .plane-wings {
            position: absolute;
            width: 80px;
            height: 14px;
            background-color: #ffffff;
            border: 1px solid #333;
            left: 30px;
            top: 23px;
            z-index: 1;
            transform: skewX(-15deg); /* Swept wings */
            border-radius: 3px;
            box-shadow: 0 2px 3px rgba(0,0,0,0.15);
        }
        
        .plane-tail {
            position: absolute;
            width: 18px;
            height: 28px;
            background-color: #ffffff;
            border: 1px solid #333;
            right: 15px;
            top: 5px;
            clip-path: polygon(0 100%, 100% 30%, 100% 0, 0 40%);
            z-index: 1;
        }
        
        .plane-windows {
            position: absolute;
            width: 50px;
            height: 4px;
            left: 35px;
            top: 29px;
            z-index: 3;
        }
        
        .plane-windows::before {
            content: "";
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background-color: var(--primary-color);
            left: 5px;
            top: 0;
        }
        
        .plane-windows::after {
            content: "";
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background-color: var(--primary-color);
            left: 15px;
            top: 0;
        }
        
        /* Modern jet engines */
        .plane-engine {
            position: absolute;
            width: 22px;
            height: 12px;
            background-color: #333;
            border-radius: 5px;
            z-index: 3;
        }
        
        .plane-engine.left {
            left: 35px;
            top: 41px;
        }
        
        .plane-engine.right {
            left: 35px;
            top: 17px;
        }
        
        /* Jet exhaust effect */
        .plane-exhaust {
            position: absolute;
            width: 30px;
            height: 6px;
            right: -20px;
            top: 32px;
            z-index: 0;
            animation: exhaust 0.3s infinite;
        }
        
        @keyframes exhaust {
            0% { 
                box-shadow: -10px 0 10px rgba(255, 140, 0, 0.7),
                           -20px 0 15px rgba(255, 69, 0, 0.5);
            }
            100% { 
                box-shadow: -15px 0 15px rgba(255, 140, 0, 0.5),
                           -25px 0 20px rgba(255, 69, 0, 0.3);
            }
        }
        
        .plane-trail {
            position: absolute;
            width: 150px;
            height: 2px;
            background: linear-gradient(to left, rgba(255,255,255,0.8), rgba(255,255,255,0));
            top: 30px;
            left: -150px; /* Trail behind the plane */
            z-index: 0;
        }

        /* Filter indicator */
        .filter-active-indicator {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 90%;
            border: 10px solid transparent;
            border-radius: 15px;
            pointer-events: none;
            z-index: 7;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        /* Show the filter indicator when active */
        .filter-active-indicator.active {
            opacity: 0.6;
            border-color: rgba(231, 76, 60, 0.2);
            box-shadow: inset 0 0 50px rgba(231, 76, 60, 0.3);
            animation: filterPulse 2s infinite ease-in-out;
        }
        
        @keyframes filterPulse {
            0% { box-shadow: inset 0 0 30px rgba(231, 76, 60, 0.2); }
            50% { box-shadow: inset 0 0 50px rgba(231, 76, 60, 0.3); }
            100% { box-shadow: inset 0 0 30px rgba(231, 76, 60, 0.2); }
        }
        
        /* City labels */
        .city-label {
            position: absolute;
            color: var(--text-color);
            font-size: 1em;
            z-index: 6;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.9), 0 0 15px rgba(0, 0, 0, 0.7);
            pointer-events: none;
            opacity: 0.9;
            transition: opacity 0.3s, transform 0.3s;
            font-weight: bold;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        
        .city-label::before {
            content: '‚Ä¢';
            margin-right: 4px;
            font-size: 1.2em;
        }
        
        .city-label.region-na::before { color: #2ecc71; } /* North America - Green */
        .city-label.region-sa::before { color: #e74c3c; } /* South America - Red */
        .city-label.region-eu::before { color: #3498db; } /* Europe - Blue */
        .city-label.region-as::before { color: #f39c12; } /* Asia - Orange */
        .city-label.region-af::before { color: #9b59b6; } /* Africa - Purple */
        .city-label.region-oc::before { color: #16a085; } /* Oceania - Teal */
        
        .city-label.region-na { color: #ceffe2; } 
        .city-label.region-sa { color: #ffcecf; }
        .city-label.region-eu { color: #d3e9ff; }
        .city-label.region-as { color: #ffecd3; }
        .city-label.region-af { color: #ecd3ff; }
        .city-label.region-oc { color: #d3ffee; }

        /* City flashing animation */
        .city-flash {
            animation: cityPulse 1s ease-out;
        }
        
        @keyframes cityPulse {
            0% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 255, 255, 0.8); }
            50% { transform: scale(1.5); text-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 30px rgba(255, 255, 255, 0.5); }
            100% { transform: scale(1); text-shadow: 0 0 8px rgba(0, 0, 0, 0.9), 0 0 15px rgba(0, 0, 0, 0.7); }
        }

        /* COCKPIT UI STYLING */
        .cockpit-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--cockpit-dark);
            border-top: 2px solid var(--panel-border);
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            z-index: 100;
            transition: height 0.5s ease;
            overflow: hidden;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.5);
        }

        .cockpit-container.collapsed {
            height: 30px;
        }

        .cockpit-container.expanded {
            height: 70%;
        }

        .cockpit-toggle {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--cockpit-mid);
            color: var(--text-color);
            border: none;
            border-radius: 0 0 15px 15px;
            padding: 2px 15px;
            font-size: 0.8rem;
            cursor: pointer;
            z-index: 101;
            outline: 1px solid var(--panel-border);
            transition: background-color 0.3s;
        }

        .cockpit-toggle:hover {
            background-color: var(--cockpit-light);
        }

        .cockpit-panels {
            display: flex;
            flex-wrap: wrap;
            padding: 35px 10px 10px 10px;
            overflow-y: auto;
            max-height: calc(100% - 35px);
        }

        .cockpit-panel {
            background-color: var(--cockpit-mid);
            border-radius: var(--border-radius);
            margin: 5px;
            padding: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--panel-border);
            flex: 1;
            min-width: 200px;
            position: relative;
        }

        .cockpit-panel-title {
            background-color: var(--cockpit-dark);
            color: var(--primary-color);
            padding: 5px 10px;
            margin: -10px -10px 10px -10px;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
            font-size: 0.9rem;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid var(--panel-border);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Flight Info Panel */
        .flight-info-panel {
            flex: 2;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }

        .flight-gauges {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin-bottom: 10px;
        }

        .gauge {
            width: 90px;
            height: 90px;
            background-color: var(--gauge-bg);
            border-radius: 50%;
            border: 2px solid var(--panel-border);
            position: relative;
            margin: 5px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .gauge-title {
            position: absolute;
            top: 15px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 0.6rem;
            color: var(--text-color);
            text-transform: uppercase;
        }

        .gauge-value {
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 0.7rem;
            color: var(--warning-color);
        }

        .gauge-needle {
            position: absolute;
            width: 2px;
            height: 35px;
            background-color: var(--danger-color);
            left: 50%;
            bottom: 50%;
            transform-origin: bottom;
            transform: translateX(-50%) rotate(0deg);
            transition: transform 0.5s ease;
        }

        .gauge-marker {
            position: absolute;
            width: 4px;
            height: 8px;
            background-color: var(--text-color);
            opacity: 0.7;
            top: 10px;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(0deg);
        }

        .gauge::after {
            content: "";
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--cockpit-light);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid var(--text-color);
        }

        /* Flight Status Display */
        .flight-status {
            background-color: var(--gauge-bg);
            border: 1px solid var(--panel-border);
            border-radius: var(--border-radius);
            padding: 8px;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: var(--secondary-color);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            line-height: 1.2;
            flex-grow: 1;
            max-height: 80px;
            overflow-y: auto;
        }

        /* Main Control Panel */
        .main-controls-panel {
            flex: 1;
            min-width: 180px;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .control-button {
            background-color: var(--cockpit-dark);
            color: var(--text-color);
            border: 1px solid var(--panel-border);
            border-radius: var(--border-radius);
            padding: 8px 5px;
            font-size: 0.8rem;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .control-button:hover {
            background-color: var(--cockpit-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .control-button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .control-button.primary {
            background-color: var(--primary-color);
            color: white;
        }

        .control-button.danger {
            background-color: var(--danger-color);
            color: white;
        }

        .control-button.full {
            grid-column: span 2;
        }

        /* Audio Control Panel */
        .audio-controls-panel {
            flex: 1.5;
            min-width: 220px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-label {
            display: block;
            margin-bottom: 4px;
            font-size: 0.8rem;
            color: var(--text-color);
        }

        /* Slider styling */
        .slider-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider {
            flex-grow: 1;
            height: 8px;
            background: var(--cockpit-dark);
            border-radius: 4px;
            outline: none;
            appearance: none;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border: none;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        .slider-value {
            width: 50px;
            font-size: 0.7rem;
            text-align: right;
            color: var(--warning-color);
        }

        /* Filter sliders */
        .slider.filter-slider::-webkit-slider-thumb {
            background: var(--danger-color);
        }

        .slider.filter-slider::-moz-range-thumb {
            background: var(--danger-color);
        }

        /* Compressor sliders */
        .slider.compressor-slider::-webkit-slider-thumb {
            background: var(--warning-color);
        }

        .slider.compressor-slider::-moz-range-thumb {
            background: var(--warning-color);
        }

        /* Audio meter */
        .audio-meter-container {
            width: 100%;
            height: 8px;
            background-color: var(--cockpit-dark);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .audio-meter {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #2ecc71, #f39c12, #e74c3c);
            transition: width 0.1s ease;
        }

        .audio-level-label {
            position: absolute;
            right: 5px;
            top: -1px;
            font-size: 0.6rem;
            color: white;
            mix-blend-mode: difference;
        }

        /* Toggle switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-switch {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--switch-off);
            transition: .4s;
            border-radius: 24px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .slider-switch:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: var(--text-color);
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider-switch {
            background-color: var(--switch-on);
        }

        input:checked + .slider-switch:before {
            transform: translateX(26px);
        }

        /* Effects Panel */
        .effects-panel {
            flex: 1.5;
            min-width: 220px;
        }

        .effect-switches {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .effect-switch {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .effect-label {
            font-size: 0.7rem;
            margin-top: 4px;
            text-align: center;
        }

        .led-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--led-off);
            display: inline-block;
            margin-left: 4px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .led-indicator.active {
            background-color: var(--led-green);
            box-shadow: 0 0 5px var(--led-green);
        }

        .led-indicator.filter {
            background-color: var(--led-red);
            box-shadow: 0 0 5px var(--led-red);
        }

        .led-indicator.compressor {
            background-color: var(--led-yellow);
            box-shadow: 0 0 5px var(--led-yellow);
        }

        /* Destination Selection */
        .destination-panel {
            flex: 1.5;
            min-width: 220px;
        }

        .destination-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .destination-button {
            background-color: var(--cockpit-dark);
            color: var(--text-color);
            border: 1px solid var(--panel-border);
            border-radius: var(--border-radius);
            padding: 6px 4px;
            font-size: 0.75rem;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .destination-button:hover {
            background-color: var(--cockpit-light);
        }

        .destination-button.selected {
            background-color: var(--secondary-color);
            color: white;
        }

        /* Artist Selection */
        .artist-panel {
            flex: 1.5;
            min-width: 220px;
        }

        .artist-selector {
            width: 100%;
            background-color: var(--cockpit-dark);
            color: var(--text-color);
            border: 1px solid var(--panel-border);
            border-radius: var(--border-radius);
            padding: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .artist-info {
            background-color: var(--cockpit-dark);
            padding: 8px;
            border-radius: var(--border-radius);
            font-size: 0.75rem;
            border: 1px solid var(--panel-border);
            margin-bottom: 10px;
            height: 60px;
            overflow-y: auto;
        }

        .artist-style {
            color: var(--warning-color);
            font-style: italic;
            margin-top: 5px;
        }

        /* Flight Announcements */
        #announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--panel-bg);
            padding: 15px 20px;
            border-radius: var(--border-radius);
            font-size: 1rem;
            max-width: 80%;
            z-index: 16;
            border-left: 5px solid var(--warning-color);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            font-style: italic;
            text-align: center;
            display: none;
            backdrop-filter: blur(8px);
            cursor: pointer;
            transition: opacity 0.7s ease;
        }

        #announcement strong {
            color: var(--warning-color);
            display: block;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        /* Settings Toggle */
        .settings-toggle, .help-toggle {
            position: absolute;
            top: 10px;
            background-color: transparent;
            border: none;
            color: var(--text-color);
            font-size: 1.2rem;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 102;
        }

        .settings-toggle {
            right: 10px;
        }

        .help-toggle {
            right: 50px;
        }

        .settings-toggle:hover, .help-toggle:hover {
            color: var(--primary-color);
        }

        /* Settings panel */
        #settingsPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--panel-bg);
            padding: 20px;
            border-radius: var(--border-radius);
            z-index: 1000;
            width: 80%;
            max-width: 400px;
            display: none;
            border-left: 5px solid #8e44ad;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }

        #settingsPanel h3 {
            text-align: center;
            margin-top: 0;
            color: #8e44ad;
            margin-bottom: 20px;
        }

        /* Emergency eject button */
        .emergency-eject {
            position: absolute;
            top: 10px;
            right: 50px;
            width: 40px;
            height: 40px;
            background-color: var(--danger-color);
            border: 2px solid #c0392b;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.6rem;
            cursor: pointer;
            z-index: 102;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            text-transform: uppercase;
        }

        .emergency-eject:hover {
            background-color: #c0392b;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
        }

        /* Mobile Responsiveness */
        @media screen and (max-width: 768px) {
            .cockpit-container.expanded {
                height: 80%;
            }

            .cockpit-panel {
                min-width: 150px;
            }

            .flight-gauges {
                justify-content: flex-start;
            }

            .gauge {
                width: 70px;
                height: 70px;
            }

            .control-button {
                font-size: 0.7rem;
                padding: 6px 4px;
            }

            h1 {
                font-size: 1.3rem;
                margin: 8px 0;
            }
        }

        @media screen and (max-width: 480px) {
            .cockpit-container.expanded {
                height: 85%;
            }

            .cockpit-panels {
                flex-direction: column;
            }

            .cockpit-panel {
                min-width: 100%;
            }

            .flight-gauges {
                justify-content: space-around;
            }

            .gauge {
                width: 60px;
                height: 60px;
            }

            .gauge-title, .gauge-value {
                font-size: 0.5rem;
            }

            .gauge-needle {
                height: 25px;
            }

            .emergency-eject {
                top: 5px;
                right: 45px;
                width: 35px;
                height: 35px;
                font-size: 0.5rem;
            }

            .settings-toggle {
                top: 5px;
                right: 5px;
            }

            /* Welcome content mobile adjustments */
            .welcome-content {
                max-width: 95vw;
                max-height: 90vh;
                padding: 20px;
                font-size: 0.9rem;
            }

            .welcome-content h2 {
                font-size: 1.3rem;
            }

            .welcome-content h3 {
                font-size: 1rem;
            }
        }

        /* Welcome Overlay */
        .welcome-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .welcome-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .welcome-content {
            background-color: var(--panel-bg);
            padding: 30px;
            border-radius: var(--border-radius);
            max-width: 750px;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid var(--primary-color);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            position: relative;
            z-index: 3001;
        }

        /* Custom scrollbar for welcome content */
        .welcome-content::-webkit-scrollbar {
            width: 10px;
        }

        .welcome-content::-webkit-scrollbar-track {
            background: var(--cockpit-dark);
            border-radius: 5px;
        }

        .welcome-content::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 5px;
        }

        .welcome-content::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-color);
        }

        .welcome-content h2 {
            color: var(--primary-color);
            margin-top: 0;
            text-align: center;
            font-size: 1.5rem;
        }

        .welcome-content h3 {
            font-size: 1.1rem;
            border-bottom: 1px solid rgba(52, 152, 219, 0.3);
            padding-bottom: 5px;
        }

        .welcome-content p {
            line-height: 1.6;
            margin: 15px 0;
        }

        .welcome-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .welcome-content li {
            margin: 8px 0;
        }

        .keyboard-shortcuts {
            background-color: var(--cockpit-dark);
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
        }

        .keyboard-shortcuts h3 {
            color: var(--secondary-color);
            margin-top: 0;
            font-size: 1rem;
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .shortcut kbd {
            background-color: var(--cockpit-light);
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid var(--panel-border);
            font-family: monospace;
            font-size: 0.85rem;
        }

        .welcome-start-btn {
            width: 100%;
            padding: 15px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1.1rem;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            pointer-events: auto;
            position: relative;
            z-index: 3002;
        }

        .welcome-start-btn:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .welcome-start-btn:active {
            transform: translateY(0);
        }

        /* Help Overlay */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .help-overlay.hidden {
            opacity: 0;
            pointer-events: none;
            display: none;
        }

        .help-content {
            background-color: var(--panel-bg);
            padding: 30px;
            border-radius: var(--border-radius);
            max-width: 800px;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid var(--secondary-color);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            position: relative;
        }

        .help-content::-webkit-scrollbar {
            width: 10px;
        }

        .help-content::-webkit-scrollbar-track {
            background: var(--cockpit-dark);
            border-radius: 5px;
        }

        .help-content::-webkit-scrollbar-thumb {
            background: var(--secondary-color);
            border-radius: 5px;
        }

        .help-content h2 {
            color: var(--secondary-color);
            margin-top: 0;
            text-align: center;
            font-size: 1.8rem;
        }

        .help-content h3 {
            color: var(--primary-color);
            font-size: 1.2rem;
            border-bottom: 1px solid rgba(46, 204, 113, 0.3);
            padding-bottom: 5px;
            margin-top: 20px;
        }

        .help-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--danger-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-close-btn:hover {
            background: #c0392b;
        }

        /* Landing Destination Overlay */
        .landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.92);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .landing-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .landing-panel {
            background-color: var(--panel-bg);
            padding: 40px;
            border-radius: var(--border-radius);
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            border: 2px solid var(--primary-color);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            position: relative;
            z-index: 2001;
        }

        .destinations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .destination-card {
            background-color: var(--cockpit-dark);
            padding: 20px;
            border-radius: var(--border-radius);
            border: 2px solid var(--panel-border);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            pointer-events: auto;
        }

        .destination-card:hover {
            border-color: var(--primary-color);
            background-color: var(--cockpit-mid);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .destination-card.selected {
            border-color: var(--secondary-color);
            background-color: var(--cockpit-light);
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.4);
        }

        .destination-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .destination-card h3 {
            color: var(--primary-color);
            margin: 10px 0;
            font-size: 1.1rem;
        }

        .destination-card p {
            color: var(--text-color);
            opacity: 0.8;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .atmosphere-select {
            width: 100%;
            padding: 8px;
            background-color: var(--cockpit-dark);
            color: var(--text-color);
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .atmosphere-select:hover {
            border-color: var(--primary-color);
        }

        /* Flight Log Overlay */
        .flight-log-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2500;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .flight-log-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .flight-log-panel {
            background: linear-gradient(to bottom, #1a2f38 0%, #2c3e50 100%);
            padding: 30px;
            border-radius: var(--border-radius);
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            border: 3px solid var(--primary-color);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            pointer-events: auto;
            position: relative;
            z-index: 2501;
            font-family: 'Courier New', monospace;
        }

        .flight-log-header {
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .flight-log-header h2 {
            color: var(--secondary-color);
            margin: 0;
            font-size: 1.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .flight-log-number {
            color: var(--primary-color);
            font-size: 1.2rem;
            margin-top: 5px;
        }

        .log-section {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid var(--primary-color);
            border-radius: 4px;
        }

        .log-section h3 {
            color: var(--secondary-color);
            margin: 0 0 10px 0;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .log-entry {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 15px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(52, 152, 219, 0.2);
            font-size: 0.9rem;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-label {
            color: var(--primary-color);
            font-weight: bold;
        }

        .log-value {
            color: var(--text-color);
        }

        .log-timeline {
            margin: 10px 0;
        }

        .timeline-event {
            padding: 10px;
            margin: 8px 0;
            background-color: rgba(46, 204, 113, 0.1);
            border-left: 3px solid var(--secondary-color);
            font-size: 0.85rem;
        }

        .event-time {
            color: var(--primary-color);
            font-weight: bold;
            margin-right: 10px;
        }

        .event-description {
            color: var(--text-color);
        }

        .log-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-box {
            background-color: rgba(52, 152, 219, 0.2);
            padding: 12px;
            border-radius: 4px;
            text-align: center;
            border: 1px solid var(--primary-color);
        }

        .stat-value {
            font-size: 1.5rem;
            color: var(--secondary-color);
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-color);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .log-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .log-action-btn {
            padding: 12px 24px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .log-action-btn:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .log-action-btn.secondary {
            background-color: var(--danger-color);
        }

        .log-action-btn.secondary:hover {
            background-color: #c0392b;
        }

        /* Tooltip Styles */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-5px);
            background-color: rgba(0, 0, 0, 0.9);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 1000;
            border: 1px solid var(--panel-border);
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }

        /* Smooth transitions for control changes */
        .artist-selector,
        .destination-button {
            transition: all 0.3s ease;
        }

        .destination-button:active {
            transform: scale(0.95);
        }

        /* Status message improvements */
        #statusMessage {
            transition: opacity 0.3s ease;
        }

        .status-fade {
            animation: statusFade 0.5s ease;
        }

        @keyframes statusFade {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <!-- Welcome Overlay (Minimal) -->
    <div class="welcome-overlay" id="welcomeOverlay">
        <div class="welcome-content">
            <h2>‚úàÔ∏è Music for Airplanes</h2>
            <p style="font-size: 1.1rem; line-height: 1.7; margin: 20px 0; text-align: center;">An immersive generative ambient music experience inspired by Brian Eno's "Music for Airports".</p>

            <p style="font-size: 0.95rem; line-height: 1.6; margin: 15px 0; opacity: 0.9;">Your flight deck controls shape evolving soundscapes. Altitude affects cabin pressure (sound thinness), speed creates wind noise, engine hums beneath you. Each note nudges your plane, making music and flight one journey.</p>

            <div class="keyboard-shortcuts" style="margin-top: 25px;">
                <h3>Quick Start</h3>
                <div class="shortcut">
                    <span>Take Off / Land</span>
                    <kbd>SPACE</kbd>
                </div>
                <div class="shortcut">
                    <span>Show Full Help</span>
                    <kbd>H</kbd>
                </div>
                <div class="shortcut">
                    <span>Toggle Controls</span>
                    <kbd>C</kbd>
                </div>
                <div class="shortcut">
                    <span>Emergency Eject</span>
                    <kbd>ESC</kbd>
                </div>
            </div>

            <p style="margin-top: 20px; font-size: 0.95rem; text-align: center; opacity: 0.8;">Press <strong>H</strong> anytime for complete documentation and controls.</p>

            <button class="welcome-start-btn" id="welcomeStartBtn" onclick="console.log('Button onclick fired'); if(typeof hideWelcomeOverlay === 'function') hideWelcomeOverlay();">Begin Flight</button>
        </div>
    </div>

    <!-- Help Overlay (Comprehensive Documentation) -->
    <div class="help-overlay hidden" id="helpOverlay">
        <div class="help-content">
            <button class="help-close-btn" id="helpCloseBtn">√ó</button>
            <h2>üìñ Flight Manual</h2>

            <h3>üé≠ The Aviation Theme</h3>
            <p style="font-size: 0.95rem; line-height: 1.6; margin-bottom: 15px;">Everything is "in theme" - the cockpit controls aren't just UI, they're your flight deck. Altitude changes the sound's thinness (cabin pressure), speed creates wind noise, the engine hums beneath you. When you land, you arrive at real spaces with unique acoustics. Flight becomes a journey through sound itself.</p>

            <h3>üéµ How The Music Works</h3>
            <div style="font-size: 0.9rem; line-height: 1.7; margin-bottom: 15px;">
                <p style="margin-bottom: 10px;"><strong>Dual Sequencers:</strong> Two independent generative sequencers create interlocking melodic patterns. They select notes from scales and play them through sine wave oscillators, creating pure, ethereal tones.</p>

                <p style="margin-bottom: 10px;"><strong>Scale Systems:</strong> Choose from 8 flight routes (World Tour, Asia, Europe, Africa, Oceania, Americas, Impressionist, Minimalist), each with authentic musical scales - Japanese pentatonic, Arabic maqam, Indian raga, and more.</p>

                <p style="margin-bottom: 10px;"><strong>Artist Influences:</strong> 12 compositional styles from ambient pioneers (Eno, Satie, Reich, Glass, Basinski, Budd, Sakamoto, etc.) subtly shape tempo, note patterns, and spatial character.</p>

                <p style="margin-bottom: 10px;"><strong>Plane as Instrument:</strong> Your plane's movement isn't just visual - each note played actually nudges the plane in a direction, creating a feedback loop where music influences flight and flight influences music.</p>
            </div>

            <h3>üéõÔ∏è Audio Effects Explained</h3>
            <div style="font-size: 0.9rem; line-height: 1.7; margin-bottom: 15px;">
                <p style="margin-bottom: 8px;"><strong>Reverb:</strong> Convolver-based reverb simulates acoustic space. Higher settings create cathedral-like expansiveness, lower settings feel intimate.</p>

                <p style="margin-bottom: 8px;"><strong>Filter (Lowpass):</strong> Sculpts brightness by removing high frequencies. The LFO can modulate this automatically for swirling, evolving textures.</p>

                <p style="margin-bottom: 8px;"><strong>Compressor:</strong> Smooths dynamics and adds subtle "glue" to the mix, creating cohesive sonic character.</p>

                <p style="margin-bottom: 8px;"><strong>Engine Hum:</strong> A low sawtooth drone (55Hz) that pitch-shifts with your velocity - faster flight = higher pitch. Pure immersion.</p>

                <p style="margin-bottom: 8px;"><strong>Wind Noise:</strong> Bandpass-filtered white noise that intensifies with speed, creating realistic flight atmosphere.</p>

                <p style="margin-bottom: 8px;"><strong>Cabin Pressure (Altitude Filter):</strong> As you climb higher, a lowpass filter gradually dampens high frequencies (22kHz ‚Üí 800Hz), simulating thinning air and muffled sound in the upper atmosphere.</p>

                <p style="margin-bottom: 8px;"><strong>Rain Ambience:</strong> Filtered pink noise through reverb creates soothing rainfall sounds. Perfect for peaceful, meditative flights through gentle weather.</p>

                <p style="margin-bottom: 8px;"><strong>Distant Thunder:</strong> Low-frequency rumbles with dynamic filtering simulate thunder in the distance. Periodic rolls add drama and atmosphere, occurring every 15-45 seconds when enabled.</p>
            </div>

            <h3>‚ú® Visual Systems</h3>
            <div style="font-size: 0.9rem; line-height: 1.7; margin-bottom: 15px;">
                <p style="margin-bottom: 8px;"><strong>Note Circles:</strong> Expanding rings visualize each note played, with size and color responding to pitch and velocity.</p>

                <p style="margin-bottom: 8px;"><strong>Shooting Stars:</strong> Rare meteors streak across the sky when flying above 70% altitude - look for them!</p>

                <p style="margin-bottom: 8px;"><strong>Contrails:</strong> Your plane leaves a particle trail that expands and fades, mapping your journey through the soundscape.</p>

                <p style="margin-bottom: 8px;"><strong>Atmospheric Glow:</strong> A dynamic radial gradient around your plane that intensifies with speed and altitude.</p>

                <p style="margin-bottom: 8px;"><strong>Drifting Clouds:</strong> Procedural cloud particles add depth and movement to the scene.</p>
            </div>

            <h3>üèõÔ∏è Landing Destinations</h3>
            <p style="font-size: 0.95rem; line-height: 1.6; margin-bottom: 10px;">When you land, choose from 6 unique spaces, each with distinct acoustic properties:</p>
            <div style="font-size: 0.85rem; line-height: 1.7; margin-bottom: 15px; padding-left: 15px;">
                <p style="margin-bottom: 6px;"><strong>üèõÔ∏è Museum Gallery:</strong> Minimalist white space (Reverb 0.7, slower tempo) - spacious, contemplative</p>
                <p style="margin-bottom: 6px;"><strong>üèØ Traditional Machiya:</strong> Japanese townhouse (Reverb 0.3, calm tempo) - intimate, meditative</p>
                <p style="margin-bottom: 6px;"><strong>üè¢ Corporate Lobby:</strong> Modern glass/steel (Reverb 0.5, energetic tempo) - professional, bright</p>
                <p style="margin-bottom: 6px;"><strong>üöâ Train Station:</strong> Quiet platform (Reverb 0.8, steady tempo) - expansive, patient</p>
                <p style="margin-bottom: 6px;"><strong>üéì University Building:</strong> Concrete/wood (Reverb 0.6, focused tempo) - academic, clear</p>
                <p style="margin-bottom: 6px;"><strong>üåä Waterside Pavilion:</strong> Natural wood/water (Reverb 0.4, tranquil tempo) - open, serene</p>
            </div>

            <h3>üå§Ô∏è Atmospheric Settings</h3>
            <p style="font-size: 0.9rem; line-height: 1.6; margin-bottom: 10px;">Customize your landing atmosphere:</p>
            <div style="font-size: 0.85rem; line-height: 1.7; margin-bottom: 15px; padding-left: 15px;">
                <p style="margin-bottom: 6px;"><strong>Time of Day:</strong> Dawn/Morning/Afternoon/Evening/Night - affects lighting color and tempo modifiers</p>
                <p style="margin-bottom: 6px;"><strong>Weather:</strong> Clear/Rain/Mist - adds animated particles and audio filtering</p>
                <p style="margin-bottom: 6px;"><strong>Season:</strong> Spring (blossoms) / Summer (dust) / Autumn (leaves) / Winter (snow) - unique particle types</p>
            </div>

            <div class="keyboard-shortcuts" style="margin-top: 25px;">
                <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
                <div class="shortcut">
                    <span>Take Off / Land</span>
                    <kbd>SPACE</kbd>
                </div>
                <div class="shortcut">
                    <span>Toggle Flight Controls</span>
                    <kbd>C</kbd>
                </div>
                <div class="shortcut">
                    <span>Toggle UI</span>
                    <kbd>U</kbd>
                </div>
                <div class="shortcut">
                    <span>Full Screen</span>
                    <kbd>F</kbd>
                </div>
                <div class="shortcut">
                    <span>Randomize All</span>
                    <kbd>R</kbd>
                </div>
                <div class="shortcut">
                    <span>Clear Trail</span>
                    <kbd>T</kbd>
                </div>
                <div class="shortcut">
                    <span>View Flight Log</span>
                    <kbd>L</kbd>
                </div>
                <div class="shortcut">
                    <span>Emergency Eject</span>
                    <kbd>ESC</kbd>
                </div>
                <div class="shortcut">
                    <span>Toggle Help</span>
                    <kbd>H</kbd>
                </div>
            </div>

            <p style="margin-top: 25px; font-size: 0.9rem; opacity: 0.8; text-align: center;">Press H or ESC to close this help screen.</p>
        </div>
    </div>

    <!-- Landing Destination Selector -->
    <div class="landing-overlay hidden" id="landingOverlay">
        <div class="landing-panel">
            <h2 style="margin-bottom: 20px; font-size: 1.8rem; text-align: center;">Choose Your Destination</h2>
            <p style="opacity: 0.8; margin-bottom: 30px; text-align: center;">Where would you like to land?</p>

            <div class="destinations-grid">
                <div class="destination-card" data-space="museum">
                    <div class="destination-icon">üèõÔ∏è</div>
                    <h3>Museum Gallery</h3>
                    <p>Minimalist white space with filtered light</p>
                </div>
                <div class="destination-card" data-space="machiya">
                    <div class="destination-icon">üèØ</div>
                    <h3>Traditional Machiya</h3>
                    <p>Japanese townhouse with paper screens</p>
                </div>
                <div class="destination-card" data-space="lobby">
                    <div class="destination-icon">üè¢</div>
                    <h3>Corporate Lobby</h3>
                    <p>Modern glass and steel architecture</p>
                </div>
                <div class="destination-card" data-space="station">
                    <div class="destination-icon">üöâ</div>
                    <h3>Train Station</h3>
                    <p>Quiet platform with distant sounds</p>
                </div>
                <div class="destination-card" data-space="university">
                    <div class="destination-icon">üéì</div>
                    <h3>University Building</h3>
                    <p>Modernist concrete and wood</p>
                </div>
                <div class="destination-card" data-space="pavilion">
                    <div class="destination-icon">üåä</div>
                    <h3>Waterside Pavilion</h3>
                    <p>Natural wood beside tranquil water</p>
                </div>
            </div>

            <div class="atmosphere-controls" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                <h3 style="margin-bottom: 15px; font-size: 1.2rem;">Atmosphere</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Time</label>
                        <select id="timeSelect" class="atmosphere-select">
                            <option value="dawn">Dawn</option>
                            <option value="morning">Morning</option>
                            <option value="afternoon" selected>Afternoon</option>
                            <option value="evening">Evening</option>
                            <option value="night">Night</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Weather</label>
                        <select id="weatherSelect" class="atmosphere-select">
                            <option value="clear" selected>Clear</option>
                            <option value="rain">Rain</option>
                            <option value="mist">Mist</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Season</label>
                        <select id="seasonSelect" class="atmosphere-select">
                            <option value="spring" selected>Spring</option>
                            <option value="summer">Summer</option>
                            <option value="autumn">Autumn</option>
                            <option value="winter">Winter</option>
                        </select>
                    </div>
                </div>
            </div>

            <button class="welcome-start-btn" id="cancelLandingBtn" style="margin-top: 20px; background-color: var(--danger-color);">
                Cancel Landing
            </button>
        </div>
    </div>

    <!-- Flight Log Overlay -->
    <div class="flight-log-overlay hidden" id="flightLogOverlay">
        <div class="flight-log-panel" id="flightLogPanel">
            <!-- Content will be dynamically generated -->
        </div>
    </div>

    <div class="container">
        <h1>Music for Airplanes</h1>

        <div class="flight-display" id="flightContainer">
            <!-- Sky Gradient Elements -->
            <div id="skyGradientTop"></div>
            <div id="skyGradientBottom"></div>
            
            <!-- Filter active indicator -->
            <div class="filter-active-indicator" id="filterIndicator"></div>
            
            <!-- Canvas Layers -->
            <canvas id="starsCanvas"></canvas>
            <canvas id="landscapeCanvas"></canvas>
            <canvas id="trailCanvas"></canvas>
            <canvas id="flightCanvas"></canvas>
            <canvas id="noteVisualization"></canvas>
            
            <!-- Updated Modern Airplane Element -->
            <div class="plane" id="plane">
                <div class="plane-body"></div>
                <div class="plane-wings"></div>
                <div class="plane-tail"></div>
                <div class="plane-windows"></div>
                <div class="plane-engine left"></div>
                <div class="plane-engine right"></div>
                <div class="plane-exhaust"></div>
                <div class="plane-trail"></div>
            </div>
            
            <!-- City Labels Container -->
            <div id="cityLabels"></div>
            
            <!-- Announcement Panel -->
            <div id="announcement" class="announcement">
                <strong>Cabin Announcement</strong>
                <span id="announcementText"></span>
            </div>
            
            <!-- Emergency Eject Button -->
            <button class="emergency-eject" id="emergencyEject" title="Immediately stop all audio and reset system">Eject</button>

            <!-- Help Toggle -->
            <button class="help-toggle" id="helpButton" title="Show Help (H)">?</button>

            <!-- Settings Toggle -->
            <button class="settings-toggle" id="settingsButton" title="Open Settings">‚öôÔ∏è</button>
            
            <!-- Cockpit Control UI -->
            <div class="cockpit-container collapsed" id="cockpitContainer">
                <button class="cockpit-toggle" id="cockpitToggle">Flight Controls</button>
                
                <div class="cockpit-panels">
                    <!-- Flight Info Panel -->
                    <div class="cockpit-panel flight-info-panel">
                        <div class="cockpit-panel-title">Flight Information</div>
                        
                        <div class="flight-gauges">
                            <!-- Flight Time Gauge -->
                            <div class="gauge">
                                <div class="gauge-title">Flight Time</div>
                                <div class="gauge-needle" id="timeNeedle"></div>
                                <div class="gauge-value" id="flightTime">00:00:00</div>
                                <!-- Markers -->
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(0deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(45deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(90deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(135deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(180deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(225deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(270deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(315deg);"></div>
                            </div>
                            
                            <!-- Altitude Gauge -->
                            <div class="gauge">
                                <div class="gauge-title">Altitude</div>
                                <div class="gauge-needle" id="altitudeNeedle"></div>
                                <div class="gauge-value" id="flightAltitude">25,000 ft</div>
                                <!-- Markers -->
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(0deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(45deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(90deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(135deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(180deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(225deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(270deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(315deg);"></div>
                            </div>
                            
                            <!-- Tempo Gauge -->
                            <div class="gauge">
                                <div class="gauge-title">Tempo</div>
                                <div class="gauge-needle" id="tempoNeedle"></div>
                                <div class="gauge-value" id="tempoBPM">90 BPM</div>
                                <!-- Markers -->
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(0deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(45deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(90deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(135deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(180deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(225deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(270deg);"></div>
                                <div class="gauge-marker" style="transform: translateX(-50%) rotate(315deg);"></div>
                            </div>
                        </div>
                        
                        <div class="flight-status" id="statusPanel">
                            <div id="statusMessage">Welcome to Music for Airplanes. Click "Take Off" to begin your musical journey.</div>
                        </div>
                        
                        <div class="control-group">
                            <div class="control-label">Current destination: <span id="currentDestination">World Tour</span></div>
                            <div class="control-label">Cabin music: <span id="currentArtist">Various Artists</span></div>
                        </div>
                    </div>
                    
                    <!-- Main Controls Panel -->
                    <div class="cockpit-panel main-controls-panel">
                        <div class="cockpit-panel-title">Flight Deck</div>
                        
                        <div class="control-buttons">
                            <button id="takeoff" class="control-button primary" data-tooltip="Start audio engine and begin flight (SPACE)">Take Off</button>
                            <button id="land" class="control-button danger" data-tooltip="Stop all audio and land plane (SPACE)">Land</button>
                            <button id="testAudio" class="control-button" data-tooltip="Play a test tone to check audio">Test Audio</button>
                            <button id="fullscreenBtn" class="control-button" data-tooltip="Toggle fullscreen mode (F)">Full Screen</button>
                            <button id="randomizeAll" class="control-button full" data-tooltip="Randomize destination and artist (R)">Randomize All</button>
                            <button id="toggleUI" class="control-button" data-tooltip="Hide/show plane and UI elements (U)">Hide UI</button>
                            <button id="clearTrail" class="control-button danger" data-tooltip="Clear the visual trail (T)">Clear Trail</button>
                            <button id="flightLogBtn" class="control-button" data-tooltip="View flight log and session details (L)">Flight Log</button>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Weather Persistence:</label>
                            <div class="slider-container">
                                <input type="range" id="persistence" class="slider" min="0" max="1" step="0.01" value="0.5">
                                <span id="persistenceValue" class="slider-value">50%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Trail Intensity:</label>
                            <div class="slider-container">
                                <input type="range" id="trailIntensity" class="slider" min="0.1" max="5" step="0.1" value="1">
                                <span id="trailIntensityValue" class="slider-value">1.0</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Audio Controls Panel -->
                    <div class="cockpit-panel audio-controls-panel">
                        <div class="cockpit-panel-title">Cabin Audio</div>
                        
                        <div class="control-group">
                            <label class="control-label">Cabin Volume:</label>
                            <div class="slider-container">
                                <input type="range" id="volume" class="slider" min="0" max="0.3" step="0.01" value="0.15">
                                <span id="volumeValue" class="slider-value">0.15</span>
                            </div>
                            <div class="audio-meter-container">
                                <div class="audio-meter" id="audioMeter"></div>
                                <div class="audio-level-label" id="audioLevelLabel">-‚àû dB</div>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Cabin Atmosphere:</label>
                            <div class="slider-container">
                                <input type="range" id="reverb" class="slider" min="0" max="1" step="0.05" value="0.3">
                                <span id="reverbValue" class="slider-value">30%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Note Decay:</label>
                            <div class="slider-container">
                                <input type="range" id="decay" class="slider" min="0.1" max="10" step="0.1" value="5">
                                <span id="decayValue" class="slider-value">5s</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Bass Level:</label>
                            <div class="slider-container">
                                <input type="range" id="bassLevel" class="slider" min="0" max="1" step="0.05" value="0.7">
                                <span id="bassLevelValue" class="slider-value">70%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Flight Speed (BPM):</label>
                            <div class="slider-container">
                                <input type="range" id="tempo" class="slider" min="40" max="200" step="1" value="90">
                                <span id="tempoValue" class="slider-value">90</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Flight Altitude:</label>
                            <div class="slider-container">
                                <input type="range" id="altitude" class="slider" min="0.5" max="2" step="0.05" value="1">
                                <span id="altitudeValue" class="slider-value">Cruising</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Effects Panel -->
                    <div class="cockpit-panel effects-panel">
                        <div class="cockpit-panel-title">Audio Effects</div>
                        
                        <div class="effect-switches">
                            <div class="effect-switch">
                                <label class="switch">
                                    <input type="checkbox" id="filterToggle">
                                    <span class="slider-switch"></span>
                                </label>
                                <div class="effect-label">Air Filter <span class="led-indicator" id="filterLed"></span></div>
                            </div>
                            
                            <div class="effect-switch">
                                <label class="switch">
                                    <input type="checkbox" id="lfoToggle">
                                    <span class="slider-switch"></span>
                                </label>
                                <div class="effect-label">Turbulence <span class="led-indicator" id="lfoLed"></span></div>
                            </div>
                            
                            <div class="effect-switch">
                                <label class="switch">
                                    <input type="checkbox" id="compressorToggle">
                                    <span class="slider-switch"></span>
                                </label>
                                <div class="effect-label">Cabin Pressure <span class="led-indicator" id="compressorLed"></span></div>
                            </div>

                            <div class="effect-switch">
                                <label class="switch">
                                    <input type="checkbox" id="engineToggle" checked>
                                    <span class="slider-switch"></span>
                                </label>
                                <div class="effect-label">Engine Hum <span class="led-indicator led-on" id="engineLed"></span></div>
                            </div>

                            <div class="effect-switch">
                                <label class="switch">
                                    <input type="checkbox" id="windToggle" checked>
                                    <span class="slider-switch"></span>
                                </label>
                                <div class="effect-label">Wind Noise <span class="led-indicator led-on" id="windLed"></span></div>
                            </div>

                            <div class="effect-switch">
                                <label class="switch">
                                    <input type="checkbox" id="altitudeFilterToggle" checked>
                                    <span class="slider-switch"></span>
                                </label>
                                <div class="effect-label">Altitude Filter <span class="led-indicator led-on" id="altitudeFilterLed"></span></div>
                            </div>

                            <div class="effect-switch">
                                <label class="switch">
                                    <input type="checkbox" id="rainToggle">
                                    <span class="slider-switch"></span>
                                </label>
                                <div class="effect-label">Rain Ambience <span class="led-indicator" id="rainLed"></span></div>
                            </div>

                            <div class="effect-switch">
                                <label class="switch">
                                    <input type="checkbox" id="thunderToggle">
                                    <span class="slider-switch"></span>
                                </label>
                                <div class="effect-label">Distant Thunder <span class="led-indicator" id="thunderLed"></span></div>
                            </div>
                        </div>

                        <!-- Filter Controls -->
                        <div id="filterControlsPanel">
                            <div class="control-group">
                                <label class="control-label">Filter Cutoff:</label>
                                <div class="slider-container">
                                    <input type="range" id="filterCutoff" class="slider filter-slider" min="20" max="20000" step="1" value="20000">
                                    <span id="filterCutoffValue" class="slider-value">20000 Hz</span>
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">LFO Rate:</label>
                                <div class="slider-container">
                                    <input type="range" id="lfoRate" class="slider filter-slider" min="0" max="7" step="1" value="2">
                                    <span id="lfoRateValue" class="slider-value">1/4 Note</span>
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">LFO Amount:</label>
                                <div class="slider-container">
                                    <input type="range" id="lfoAmount" class="slider filter-slider" min="0" max="100" step="1" value="50">
                                    <span id="lfoAmountValue" class="slider-value">50%</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Compressor Controls -->
                        <div id="compressorControlsPanel">
                            <div class="control-group">
                                <label class="control-label">Threshold:</label>
                                <div class="slider-container">
                                    <input type="range" id="compThreshold" class="slider compressor-slider" min="-60" max="0" step="1" value="-24">
                                    <span id="compThresholdValue" class="slider-value">-24 dB</span>
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">Ratio:</label>
                                <div class="slider-container">
                                    <input type="range" id="compRatio" class="slider compressor-slider" min="1" max="20" step="0.5" value="4">
                                    <span id="compRatioValue" class="slider-value">4:1</span>
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">Attack:</label>
                                <div class="slider-container">
                                    <input type="range" id="compAttack" class="slider compressor-slider" min="0" max="1" step="0.01" value="0.1">
                                    <span id="compAttackValue" class="slider-value">0.1s</span>
                                </div>
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">Release:</label>
                                <div class="slider-container">
                                    <input type="range" id="compRelease" class="slider compressor-slider" min="0" max="1" step="0.01" value="0.25">
                                    <span id="compReleaseValue" class="slider-value">0.25s</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Destination Panel -->
                    <div class="cockpit-panel destination-panel">
                        <div class="cockpit-panel-title">Flight Routes</div>
                        
                        <div class="destination-buttons">
                            <button id="destWorldTour" class="destination-button selected">World Tour</button>
                            <button id="destAsia" class="destination-button">Asia</button>
                            <button id="destEurope" class="destination-button">Europe</button>
                            <button id="destAfrica" class="destination-button">Africa</button>
                            <button id="destOceania" class="destination-button">Oceania</button>
                            <button id="destAmericas" class="destination-button">Americas</button>
                            <button id="destImpressionist" class="destination-button">Impressionist</button>
                            <button id="destMinimalist" class="destination-button">Minimalist</button>
                        </div>
                    </div>
                    
                    <!-- Artist Panel -->
                    <div class="cockpit-panel artist-panel">
                        <div class="cockpit-panel-title">Cabin Music</div>
                        
                        <select id="artistSelector" class="artist-selector">
                            <option value="various">Various Artists</option>
                            <option value="brianeno">Brian Eno</option>
                            <option value="eriksatie">Erik Satie</option>
                            <option value="haroldbudd">Harold Budd</option>
                            <option value="starsofthelid">Stars of the Lid</option>
                            <option value="boardsofcanada">Boards of Canada</option>
                            <option value="williambasinski">William Basinski</option>
                            <option value="stevereich">Steve Reich</option>
                            <option value="timhecker">Tim Hecker</option>
                            <option value="ryuichisakamoto">Ryuichi Sakamoto</option>
                            <option value="aphextwin">Aphex Twin</option>
                            <option value="jonhopkins">Jon Hopkins</option>
                        </select>
                        
                        <div class="artist-info" id="artistInfo">
                            <div>Various Artists</div>
                            <div class="artist-style">Mixed Inspiration</div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Filter Presets:</label>
                            <select id="filterPresets" class="artist-selector">
                                <option value="">Select Filter Preset</option>
                                <option value="clearSky">Clear Sky</option>
                                <option value="highAltitude">High Altitude</option>
                                <option value="cloudCover">Cloud Cover</option>
                                <option value="nightFlight">Night Flight</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Compressor Presets:</label>
                            <select id="compressorPresets" class="artist-selector">
                                <option value="">Select Compressor Preset</option>
                                <option value="safetyMode">Safety Mode</option>
                                <option value="smoothLanding">Smooth Landing</option>
                                <option value="turbulenceControl">Turbulence Control</option>
                                <option value="nightMode">Night Mode</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Settings Panel -->
            <div id="settingsPanel" class="settings-panel">
                <h3>Application Settings</h3>
                
                <div class="control-group">
                    <div class="effect-switches">
                        <div class="effect-switch">
                            <label class="control-label">Dark Mode</label>
                            <label class="switch">
                                <input type="checkbox" id="darkModeToggle">
                                <span class="slider-switch"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="safeLowFreq" class="control-label">Safe Low Frequency Cutoff (Hz)</label>
                    <div class="slider-container">
                        <input type="range" id="safeLowFreq" class="slider" min="20" max="80" step="1" value="20">
                        <span id="safeLowFreqValue" class="slider-value">20 Hz</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="limiterThreshold" class="control-label">Output Limiter Threshold</label>
                    <div class="slider-container">
                        <input type="range" id="limiterThreshold" class="slider" min="-20" max="-0.1" step="0.1" value="-3.0">
                        <span id="limiterThresholdValue" class="slider-value">-3.0 dB</span>
                    </div>
                </div>
                
                <div class="control-buttons">
                    <button id="saveSettings" class="control-button primary">Save Settings</button>
                    <button id="closeSettings" class="control-button">Cancel</button>
                </div>
            </div>
        </div>
    </div>

<script>
    // Audio context and nodes
    let audioContext = null;
    let masterGainNode = null;
    let highPassFilter = null; // Added high-pass filter for safety
    let limiterNode = null;    // Added limiter for safety
    let reverbNode = null;
    let convolverBuffer = null;
    let dryGainNode = null;
    let wetGainNode = null;
    let bassEQNode = null;     // Added bass EQ node
    let planePosition = { x: 50, y: 50 }; // Start in the middle of screen (percentages)
    let planeDirection = { x: 0.02, y: 0.01 }; // Slower initial direction values
    let isFlying = false;
    let activeOscillators = [];
    let lastNoteData = { frequency: 0, time: 0 };
    let currentNoteData = { frequency: 0, time: 0 };
    let announcementTimer = null;
    let flightStartTime = null;
    let uiVisible = true;
    let debugMode = false;
    let isFirstVisit = true;
    let trailPermaMode = true;
    let trailIntensity = 1.0;
    let audioMeter = null;
    let audioAnalyser = null;
    let audioUpdateInterval = null;
    let safeLowFreq = 20; // Low frequency cutoff
    let limiterThreshold = -3.0; // Limiter threshold
    
    // Filter and LFO nodes
    let filterNode = null;
    let lfoOscillator = null;
    let lfoGain = null;
    let isFilterEnabled = false;
    let isLfoEnabled = false;
    let currentLfoRate = 2;
    let currentLfoAmount = 50;
    
    // Compressor node
    let compressorNode = null;
    let isCompressorEnabled = false;

    // Immersive audio features
    let engineOscillator = null;
    let engineGain = null;
    let windNoiseNode = null;
    let windNoiseGain = null;
    let windNoiseFilter = null;
    let cabinPressureFilter = null;
    let turbulenceTimeout = null;
    let lastVelocity = { x: 0, y: 0 };
    let rainNoiseNode = null;
    let rainFilter = null;
    let rainGain = null;
    let rainReverb = null;
    let rainReverbGain = null;
    let thunderNoiseNode = null;
    let thunderFilter = null;
    let thunderGain = null;
    let thunderReverb = null;
    let thunderReverbGain = null;
    let thunderLFO = null;
    let thunderInterval = null;
    let isEngineEnabled = true;
    let isWindEnabled = true;
    let isCabinPressureEnabled = true;
    let isRainEnabled = false;
    let isThunderEnabled = false;

    // LFO rate divisions (relative to BPM)
    const lfoDivisions = [
        { name: "1/16 Note", value: 4 },
        { name: "1/8 Note", value: 2 },
        { name: "1/4 Note", value: 1 },
        { name: "1/2 Note", value: 0.5 },
        { name: "1 Bar", value: 0.25 },
        { name: "2 Bars", value: 0.125 },
        { name: "4 Bars", value: 0.0625 },
        { name: "8 Bars", value: 0.03125 }
    ];
    
    // Initialize sequencer variables
    let sequencer1 = null;
    let sequencer2 = null;

    // Current artist selection
    let currentArtist = 'various';

    // Landing destination system
    let currentLandingSpace = null;
    let currentTime = 'afternoon';
    let currentWeather = 'clear';
    let currentSeason = 'spring';
    let isLanded = false;
    let landingParticles = [];

    // Flight log tracking system
    let flightLog = {
        flightNumber: null,
        departureTime: null,
        arrivalTime: null,
        totalFlightTime: 0,
        events: [],
        destinations: [],
        artists: [],
        effectsUsed: [],
        notesPlayed: 0,
        citiesVisited: new Set(),
        altitudeRange: { min: 1.0, max: 1.0 },
        currentSegmentStart: null,
        currentDestination: null,
        currentArtistName: null
    };
    let flightSessionActive = false;
    let logCounter = 1;

    // Destination spaces data
    const destinationSpaces = {
        museum: {
            name: "Museum Gallery",
            description: "A minimalist white gallery space with high ceilings and filtered natural light",
            reverb: 0.7,
            tempoModifier: 0.9,
            colors: {
                walls: "#f5f5f5",
                floor: "#e5e5e5",
                ceiling: "#ffffff",
                accent: "#d0d0d0"
            },
            ambience: ["quiet_footsteps", "distant_voices", "soft_echoes"]
        },
        machiya: {
            name: "Traditional Machiya",
            description: "A traditional Japanese townhouse with wooden structure and paper screens",
            reverb: 0.3,
            tempoModifier: 0.8,
            colors: {
                walls: "#8c7a6b",
                floor: "#73614e",
                ceiling: "#5e4e3f",
                accent: "#c7beb5"
            },
            ambience: ["wooden_creaks", "wind_chimes", "paper_rustle"]
        },
        lobby: {
            name: "Corporate Lobby",
            description: "A modern corporate space with glass, steel and geometric forms",
            reverb: 0.5,
            tempoModifier: 1.1,
            colors: {
                walls: "#d9d9d9",
                floor: "#f0f0f0",
                ceiling: "#ffffff",
                accent: "#a0a0a0"
            },
            ambience: ["air_flow", "distant_elevator", "marble_steps"]
        },
        station: {
            name: "Train Station",
            description: "A quiet Japanese train station with distant sounds and clean architecture",
            reverb: 0.8,
            tempoModifier: 1.0,
            colors: {
                walls: "#e0e0e0",
                floor: "#c0c0c0",
                ceiling: "#f2f2f2",
                accent: "#a9a9a9"
            },
            ambience: ["distant_announcement", "train_approach", "quiet_platform"]
        },
        university: {
            name: "University Building",
            description: "A modernist university space with concrete and wood elements",
            reverb: 0.6,
            tempoModifier: 1.0,
            colors: {
                walls: "#d6d6d6",
                floor: "#a8a8a8",
                ceiling: "#f5f5f5",
                accent: "#b3b3b3"
            },
            ambience: ["distant_voices", "page_turning", "chair_movement"]
        },
        pavilion: {
            name: "Waterside Pavilion",
            description: "A minimalist pavilion beside water with natural wood and openness",
            reverb: 0.4,
            tempoModifier: 0.7,
            colors: {
                walls: "#c9b18f",
                floor: "#8c7a6b",
                ceiling: "#d8c9b6",
                accent: "#e6dfd3"
            },
            ambience: ["water_lapping", "distant_birds", "gentle_breeze"]
        }
    };

    const timeSettings = {
        dawn: { name: "Dawn", lightColor: "#e8c9a9", lightIntensity: 0.4, tempoModifier: 0.8 },
        morning: { name: "Morning", lightColor: "#f2e6d8", lightIntensity: 0.7, tempoModifier: 1.0 },
        afternoon: { name: "Afternoon", lightColor: "#ffffff", lightIntensity: 1.0, tempoModifier: 1.1 },
        evening: { name: "Evening", lightColor: "#ffc38a", lightIntensity: 0.5, tempoModifier: 0.9 },
        night: { name: "Night", lightColor: "#a8c0ff", lightIntensity: 0.2, tempoModifier: 0.7 }
    };

    const weatherSettings = {
        clear: { name: "Clear", particleCount: 0, soundModifier: 1.0 },
        rain: { name: "Rain", particleCount: 200, soundModifier: 0.9 },
        mist: { name: "Mist", particleCount: 50, soundModifier: 0.8 }
    };

    const seasonSettings = {
        spring: { name: "Spring", particleType: "blossom", soundModifier: 1.1 },
        summer: { name: "Summer", particleType: "dust", soundModifier: 1.0 },
        autumn: { name: "Autumn", particleType: "leaf", soundModifier: 0.9 },
        winter: { name: "Winter", particleType: "snow", soundModifier: 0.8 }
    };
    let currentArtistName = 'Various Artists';
    
    // Current destination variables
    let currentDestination = 'worldTour';
    let currentDestinationName = 'World Tour';
    
    // Day/Night cycle variables
    let timeOfDay = 0; // 0 = dawn, 0.5 = noon, 1 = dusk, 1.5 = night
    
    // Filter presets
    const filterPresets = {
        clearSky: {
            cutoff: 20000,
            lfoRate: 0,
            lfoAmount: 0,
            enableLfo: false,
            name: "Clear Sky"
        },
        highAltitude: {
            cutoff: 15000,
            lfoRate: 5,
            lfoAmount: 20,
            enableLfo: true,
            name: "High Altitude"
        },
        cloudCover: {
            cutoff: 8000,
            lfoRate: 2,
            lfoAmount: 40,
            enableLfo: true,
            name: "Cloud Cover"
        },
        nightFlight: {
            cutoff: 3000,
            lfoRate: 6,
            lfoAmount: 60,
            enableLfo: true,
            name: "Night Flight"
        }
    };
    
    // Compressor presets for safety
    const compressorPresets = {
        safetyMode: {
            threshold: -20,
            ratio: 4,
            attack: 0.005,
            release: 0.1,
            name: "Safety Mode"
        },
        smoothLanding: {
            threshold: -30,
            ratio: 8,
            attack: 0.02,
            release: 0.3,
            name: "Smooth Landing"
        },
        turbulenceControl: {
            threshold: -15,
            ratio: 12,
            attack: 0.001,
            release: 0.05,
            name: "Turbulence Control"
        },
        nightMode: {
            threshold: -40,
            ratio: 6,
            attack: 0.05, 
            release: 0.5,
            name: "Night Mode"
        }
    };
    
    // Canvas elements
    const flightCanvas = document.getElementById('flightCanvas');
    const flightCtx = flightCanvas.getContext('2d');
    const noteCanvas = document.getElementById('noteVisualization');
    const noteCtx = noteCanvas.getContext('2d');
    const landscapeCanvas = document.getElementById('landscapeCanvas');
    const landscapeCtx = landscapeCanvas.getContext('2d');
    const starsCanvas = document.getElementById('starsCanvas');
    const starsCtx = starsCanvas.getContext('2d');
    const trailCanvas = document.getElementById('trailCanvas');
    const trailCtx = trailCanvas.getContext('2d', { alpha: true });
    const plane = document.getElementById('plane');
    const flightContainer = document.getElementById('flightContainer');
    const statusPanel = document.getElementById('statusPanel');
    const filterIndicator = document.getElementById('filterIndicator');
    
    // Cockpit UI Elements
    const cockpitContainer = document.getElementById('cockpitContainer');
    const cockpitToggle = document.getElementById('cockpitToggle');
    
    // Gauges
    const timeNeedle = document.getElementById('timeNeedle');
    const altitudeNeedle = document.getElementById('altitudeNeedle');
    const tempoNeedle = document.getElementById('tempoNeedle');
    
    // LED indicators
    const filterLed = document.getElementById('filterLed');
    const lfoLed = document.getElementById('lfoLed');
    const compressorLed = document.getElementById('compressorLed');
    
    // Main buttons
    const takeoffButton = document.getElementById('takeoff');
    const landButton = document.getElementById('land');
    const testAudioButton = document.getElementById('testAudio');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const randomizeAllButton = document.getElementById('randomizeAll');
    const toggleUIButton = document.getElementById('toggleUI');
    const clearTrailButton = document.getElementById('clearTrail');
    const flightLogBtn = document.getElementById('flightLogBtn');
    
    // Flight controls
    const altitudeControl = document.getElementById('altitude');
    const tempoControl = document.getElementById('tempo');
    const persistenceControl = document.getElementById('persistence');
    const trailIntensityControl = document.getElementById('trailIntensity');
    
    // Audio controls
    const volumeControl = document.getElementById('volume');
    const reverbControl = document.getElementById('reverb');
    const decayControl = document.getElementById('decay');
    const bassLevelControl = document.getElementById('bassLevel');
    
    // Effect toggles
    const filterToggle = document.getElementById('filterToggle');
    const lfoToggle = document.getElementById('lfoToggle');
    const compressorToggle = document.getElementById('compressorToggle');
    const engineToggle = document.getElementById('engineToggle');
    const windToggle = document.getElementById('windToggle');
    const altitudeFilterToggle = document.getElementById('altitudeFilterToggle');
    const rainToggle = document.getElementById('rainToggle');
    const thunderToggle = document.getElementById('thunderToggle');
    
    // Filter controls
    const filterCutoffControl = document.getElementById('filterCutoff');
    const lfoRateControl = document.getElementById('lfoRate');
    const lfoAmountControl = document.getElementById('lfoAmount');
    
    // Compressor controls
    const compThresholdControl = document.getElementById('compThreshold');
    const compRatioControl = document.getElementById('compRatio');
    const compAttackControl = document.getElementById('compAttack');
    const compReleaseControl = document.getElementById('compRelease');
    
    // Presets
    const filterPresetsSelect = document.getElementById('filterPresets');
    const compressorPresetsSelect = document.getElementById('compressorPresets');
    
    // Artist selector
    const artistSelector = document.getElementById('artistSelector');
    const artistInfo = document.getElementById('artistInfo');
    
    // Destination buttons
    const destinationButtons = document.querySelectorAll('.destination-button');
    
    // Settings panel
    const settingsButton = document.getElementById('settingsButton');
    const settingsPanel = document.getElementById('settingsPanel');
    const saveSettingsBtn = document.getElementById('saveSettings');
    const closeSettingsBtn = document.getElementById('closeSettings');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const safeLowFreqControl = document.getElementById('safeLowFreq');
    const limiterThresholdControl = document.getElementById('limiterThreshold');

    // Help overlay
    const helpButton = document.getElementById('helpButton');
    const helpOverlay = document.getElementById('helpOverlay');
    const helpCloseBtn = document.getElementById('helpCloseBtn');

    // Emergency eject button
    const emergencyEjectBtn = document.getElementById('emergencyEject');
    
    // Audio meter
    const audioMeterElement = document.getElementById('audioMeter');
    const audioLevelLabel = document.getElementById('audioLevelLabel');
    
    // Landscape elements
    let mountains = [];
    let clouds = [];
    let flightPaths = [];
    let noteCircles = [];
    let stars = [];
    let cities = [];
    let planeTrail = [];
    let smoothedTrail = [];
    let MAX_TRAIL_POINTS = 200;
    let MAX_SMOOTHED_POINTS = 1000;

    // New visual effects
    let shootingStars = [];
    let cloudParticles = [];
    let contrailParticles = [];
    let atmosphericGlow = { opacity: 0, radius: 0 };
    let elementPersistence = 0.5;
    let lastAnnouncementTime = 0;
    let cityLabelsVisible = true;
    let lastCityFlashTime = 0;
    let noteCounter = 0;
    let cityDisplayInterval = 8;
    let activeCities = [];
    let cityMovementSpeed = 0.3;
    let planeMovementSpeed = 0.002;
    
    // Predefined flight paths
    let movieFlightPaths = [
        { start: { x: 10, y: 50 }, end: { x: 90, y: 50 }, duration: 30000 }, // Straight path (visible)
        { start: { x: 10, y: 30 }, end: { x: 90, y: 70 }, duration: 35000 }, // Diagonal path
        { start: { x: 10, y: 70 }, end: { x: 90, y: 30 }, duration: 35000 }, // Reverse diagonal
        { start: { x: 10, y: 60 }, end: { x: 50, y: 40 }, next: { x: 90, y: 60 }, duration: 40000 } // Path with turn
    ];
    
    // Movie-style flight path animation variables
    let currentPath = 0;
    let pathProgress = 0;
    let pathStartTime = null;
    let cameraX = 0;
    let cameraY = 0;

    // Color palette for visualization
    const colors = {
        mountains: [
            '#34495e', '#2c3e50', '#283747', '#212f3d', '#1b2631',
            '#2e4053', '#273746', '#212f3c', '#1a2530', '#1c2833',
            '#2a3132', '#1d2731', '#243640', '#2b303a', '#1e2a39',
            '#2d3b4f', '#233342', '#26394d', '#1f2c3d', '#1e3446'
        ],
        notes: [
            '#2ecc71', '#3498db', '#9b59b6', '#f1c40f', '#e67e22',
            '#1abc9c', '#16a085', '#27ae60', '#2980b9', '#8e44ad',
            '#e74c3c', '#d35400', '#f39c12', '#1f618d', '#7d3c98',
            '#2874a6', '#148f77', '#117a65', '#138d75', '#76448a'
        ],
        clouds: [
            'rgba(236, 240, 241, 0.15)', 'rgba(245, 245, 245, 0.12)', 
            'rgba(250, 250, 250, 0.08)', 'rgba(240, 240, 240, 0.10)', 
            'rgba(235, 235, 235, 0.14)', 'rgba(248, 248, 248, 0.09)',
            'rgba(230, 235, 240, 0.11)', 'rgba(242, 245, 248, 0.13)'
        ],
        flightPaths: 'rgba(236, 240, 241, 0.08)',
        plane: '#2ecc71',
        stars: ['#f5f5f5', '#e3e3e3', '#d4d4d4', '#f0f0f0', '#e8e8e8', '#f8f8f8', '#ededed', '#f2f2f2']
    };
    
    // Musical scales for different destinations
    const musicalScales = {
        worldTour: {
            harmonicNotes: [
                [261.63, 329.63, 392.44, 523.25],   // C Major
                [220.00, 277.18, 329.63, 440.00],   // A Minor
                [146.83, 220.00, 261.63, 329.63],   // D Minor
                [195.99, 246.94, 293.66, 391.99],   // G Minor
                [293.66, 349.23, 392.00, 493.88],   // D Major
                [174.61, 220.00, 261.63, 349.23],   // F Major
                [164.81, 196.00, 246.94, 329.63],   // E Minor
                [207.65, 246.94, 311.13, 392.00]    // G# Minor
            ],
            planeNotes: [
                [0, 4, 7, 12],              // Major triad with octave
                [4, 7, 11, 16],             // Major 7th chord
                [-3, 0, 4, 7],              // Minor triad with -3
                [-3, 0, 5, 9],              // Minor 6th chord
                [-5, 0, 4, 7, 11],          // Major 9th chord
                [0, 3, 7, 10, 14],          // Minor 9th chord
                [-2, 0, 3, 7, 10],          // Minor 7th with -2
                [2, 5, 9, 12, 16]           // Sus4 with extensions
            ]
        },
        asia: {
            // Pentatonic and Eastern-inspired scales
            harmonicNotes: [
                [261.63, 293.66, 349.23, 392.00, 440.00],     // C Major Pentatonic
                [261.63, 293.66, 311.13, 392.00, 440.00],     // C Japanese Hirajoshi
                [261.63, 277.18, 349.23, 392.00, 440.00],     // C Chinese scale
                [261.63, 293.66, 329.63, 349.23, 415.30],     // C Pelog (approx, gamelan-inspired)
                [261.63, 293.66, 311.13, 392.00, 415.30],     // C modified Japanese
                [261.63, 277.18, 329.63, 392.00, 457.69],     // C Ryukyu scale
                [261.63, 293.66, 311.13, 369.99, 392.00],     // C Indian raga inspired
                [261.63, 293.66, 327.03, 392.00, 436.04]      // C Persian inspired
            ],
            planeNotes: [
                [0, 2, 7, 9],               // Pentatonic fragments
                [0, 1, 5, 7, 8],            // Japanese mode intervals
                [0, 2, 4, 7, 9],            // Major pentatonic
                [0, 3, 5, 7, 10],           // Minor pentatonic
                [0, 1, 4, 8, 9],            // Eastern intervals
                [0, 1, 5, 7, 10],           // Balinese gamelan fragment
                [0, 2, 5, 7, 9, 12],        // Chinese scale intervals
                [0, 1, 3, 7, 8]             // South Asian inspired intervals
            ]
        },
        europe: {
            // Classical and European folk-inspired scales
            harmonicNotes: [
                [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88],   // C Major (complete)
                [220.00, 246.94, 261.63, 293.66, 329.63, 349.23, 392.00],   // A minor (complete)
                [246.94, 277.18, 293.66, 329.63, 369.99, 415.30, 440.00],   // B Dorian
                [164.81, 196.00, 220.00, 246.94, 261.63, 293.66, 329.63],   // E Phrygian
                [174.61, 196.00, 220.00, 246.94, 261.63, 293.66, 329.63],   // F Lydian
                [196.00, 220.00, 246.94, 261.63, 293.66, 329.63, 349.23],   // G Mixolydian
                [246.94, 261.63, 293.66, 329.63, 349.23, 392.00, 415.30],   // B Locrian
                [220.00, 246.94, 277.18, 293.66, 329.63, 369.99, 415.30]    // A Harmonic minor
            ],
            planeNotes: [
                [0, 2, 4, 5, 7, 9, 11],     // Major scale
                [0, 2, 3, 5, 7, 8, 10],     // Natural minor
                [0, 2, 3, 5, 7, 9, 10],     // Harmonic minor
                [0, 2, 3, 5, 7, 9, 11],     // Melodic minor
                [0, 2, 4, 6, 7, 9, 11],     // Lydian
                [0, 2, 4, 5, 7, 9, 10],     // Mixolydian
                [0, 2, 3, 5, 7, 8, 11],     // Dorian
                [0, 1, 3, 5, 7, 8, 10]      // Phrygian
            ]
        },
        africa: {
            // African and jazz-influenced scales
            harmonicNotes: [
                [261.63, 311.13, 349.23, 392.00, 466.16],     // C Mixolydian pentatonic (blues)
                [220.00, 261.63, 293.66, 349.23, 392.00],     // African pentatonic approximation
                [246.94, 293.66, 349.23, 392.00, 466.16],     // African rhythm-based scale
                [220.00, 233.08, 293.66, 349.23, 392.00],     // Blues with neutral 3rd (approx)
                [261.63, 293.66, 329.63, 349.23, 392.00, 440.00], // African 6-note scale
                [261.63, 293.66, 349.23, 415.30, 440.00],     // West African pentatonic
                [261.63, 277.18, 329.63, 392.00, 440.00],     // East African inspired
                [246.94, 293.66, 329.63, 392.00, 466.16]      // North African maqam inspired
            ],
            planeNotes: [
                [0, 3, 5, 6, 7, 10],        // Blues scale
                [0, 2, 5, 7, 10],           // African pentatonic
                [0, 2, 3, 7, 9],            // African-inspired
                [0, 3, 5, 7, 10],           // Minor pentatonic (blues based)
                [0, 2, 5, 7, 9, 12],        // African 6-note pattern
                [0, 2, 4, 7, 9],            // Safari-inspired pentatonic
                [0, 2, 3, 6, 7, 10],        // Saharan desert scale
                [0, 2, 3, 6, 9, 10]         // North African maqam-inspired
            ]
        },
        oceania: {
            // Oceanic and pacific-inspired scales
            harmonicNotes: [
                [261.63, 293.66, 329.63, 392.00, 440.00],     // C Major anhemitonic pentatonic
                [220.00, 246.94, 293.66, 349.23, 392.00],     // Aboriginal-inspired pentatonic
                [261.63, 277.18, 329.63, 392.00, 415.30],     // Polynesian-inspired scale
                [233.08, 261.63, 329.63, 392.00, 440.00],     // Oceanic modal scale
                [246.94, 277.18, 329.63, 369.99, 415.30],     // Island-inspired scale
                [261.63, 293.66, 349.23, 392.00, 440.00, 523.25], // Balinese pelog-inspired
                [277.18, 311.13, 349.23, 392.00, 440.00],     // Micronesian-inspired
                [293.66, 311.13, 349.23, 392.00, 466.16]      // Maori-inspired scale
            ],
            planeNotes: [
                [0, 2, 4, 7, 9],            // Major pentatonic
                [0, 2, 5, 7, 9],            // Pacific pentatonic
                [0, 1, 4, 7, 8],            // Oceanic mode
                [0, 3, 5, 7, 10],           // Indigenous-inspired scale
                [0, 3, 5, 10, 12],          // Polynesian-inspired intervals
                [0, 2, 4, 7, 11],           // Islander mode
                [0, 1, 5, 8, 10],           // Coral reef inspired
                [0, 2, 3, 7, 10]            // Tribal drums inspired
            ]
        },
        americas: {
            // North & South American indigenous and folk scales
            harmonicNotes: [
                [261.63, 293.66, 329.63, 349.23, 392.00],     // C Native American pentatonic approx
                [220.00, 246.94, 261.63, 329.63, 392.00],     // A Minor pentatonic (widespread in American folk)
                [261.63, 293.66, 311.13, 392.00, 440.00],     // Andean-inspired scale
                [246.94, 277.18, 311.13, 349.23, 392.00],     // Amazonian-inspired scale
                [233.08, 261.63, 311.13, 349.23, 415.30],     // Latin American modal scale
                [261.63, 293.66, 329.63, 392.00, 440.00, 493.88], // Bluegrass/Appalachian scale
                [220.00, 246.94, 277.18, 329.63, 369.99],     // Inuit-inspired scale
                [246.94, 277.18, 311.13, 349.23, 415.30]      // Mayan/Aztec inspired scale
            ],
            planeNotes: [
                [0, 3, 5, 7, 10],           // Minor pentatonic (blues/folk)
                [0, 2, 4, 7, 9],            // Major pentatonic
                [0, 2, 3, 7, 9],            // Native American-inspired
                [0, 1, 5, 7, 12],           // Andean-inspired
                [0, 3, 7, 10, 12],          // Latin folk-inspired
                [0, 4, 5, 7, 11],           // Prairie winds scale
                [0, 2, 5, 7, 10, 12],       // Canyon echoes scale
                [0, 1, 3, 5, 8, 10]         // Rainforest scale
            ]
        },
        // Impressionist scales (Satie, Debussy, Ravel inspired)
        impressionist: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 392.00, 440.00, 523.25],  // C Major with no 4th or 7th
                [220.00, 261.63, 329.63, 349.23, 392.00, 440.00],  // A minor 9th voiced openly
                [261.63, 311.13, 349.23, 392.00, 466.16],          // C Lydian pentatonic
                [233.08, 293.66, 349.23, 392.00, 466.16],          // Whole tone scale fragment
                [246.94, 293.66, 329.63, 392.00, 440.00],          // Impressionist fragment
                [261.63, 293.66, 349.23, 415.30, 440.00],          // Modal with augmented 4th
                [261.63, 293.66, 329.63, 392.00, 493.88],          // Extended tertian harmony
                [277.18, 311.13, 369.99, 415.30, 466.16]           // Whole tone scale fragment 2
            ],
            planeNotes: [
                [0, 2, 4, 7, 9, 12],        // Pentatonic with octave
                [0, 2, 5, 7, 11],           // Satie-like voicing
                [0, 4, 6, 10],              // Augmented triad with extension
                [0, 2, 4, 6, 8, 10],        // Whole tone scale
                [0, 2, 3, 7, 9],            // Impressionist mode
                [0, 3, 7, 10, 14],          // Minor 9th (Gymnop√©die)
                [0, 2, 5, 9],               // Quartal harmony
                [0, 5, 7, 11]               // Suspended open harmony
            ]
        },
        // Minimalist scales (Reich, Glass, Riley inspired)
        minimalist: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 349.23, 392.00],       // C Phrygian dominant fragment
                [261.63, 293.66, 329.63, 392.00, 440.00],       // Simple diatonic fragment
                [220.00, 261.63, 293.66, 329.63, 349.23],       // Repeating cell
                [261.63, 311.13, 329.63, 349.23, 392.00],       // Additive process
                [293.66, 329.63, 349.23, 392.00, 440.00],       // Shifting cell 1
                [261.63, 293.66, 311.13, 349.23, 392.00],       // Shifting cell 2
                [233.08, 261.63, 293.66, 311.13, 349.23],       // Phase shifting pattern
                [261.63, 293.66, 349.23, 392.00, 440.00]        // Interlocking pattern
            ],
            planeNotes: [
                [0, 2, 4, 5, 7],            // Reich's Piano Phase fragment
                [0, 4, 7, 12],              // Simple repeated chord
                [0, 2, 3, 7],               // Phasing pattern 1
                [0, 2, 7, 9],               // Phasing pattern 2
                [0, 2, 4, 7, 9],            // Glass's "Music in 12 Parts" fragment
                [0, 3, 7, 10],              // Riley's "In C" fragment
                [0, 5, 7, 12],              // Process music element
                [0, 2, 7, 12]               // Additive pattern
            ]
        }
    };

    // Artist-inspired scales and settings
    const artistStyles = {
        // Brian Eno - ambient pioneer
        brianeno: {
            harmonicNotes: [
                [261.63, 329.63, 392.00, 493.88],        // Spacious chord voicing
                [246.94, 293.66, 392.00, 493.88],        // Another spacious chord
                [233.08, 293.66, 349.23, 466.16],        // "Thursday Afternoon" inspired
                [261.63, 311.13, 392.00, 466.16],        // "Ambient 1" inspired
                [246.94, 277.18, 349.23, 415.30],        // "Discreet Music" inspired
                [220.00, 277.18, 329.63, 392.00],        // Sustained texture
                [196.00, 261.63, 329.63, 392.00],        // Low register ambient
                [261.63, 293.66, 349.23, 415.30]         // "Neroli" inspired
            ],
            planeNotes: [
                [0, 4, 7, 11, 14],          // Extended ambient voicing
                [0, 2, 7, 9, 14],           // Open ambient voicing
                [0, 4, 7, 12],              // Simple triad with octave
                [0, 5, 7, 12],              // Suspended with octave
                [0, 2, 7, 12],              // Open fifth with octave
                [-7, 0, 4, 7],              // Low root extension
                [0, 4, 11, 16],             // "Music for Airports" voicing
                [0, 2, 7, 16]               // Very open voicing with double octave
            ],
            tempo: 60,                       // Slow BPM
            decay: 8,                        // Long decay
            reverb: 0.6,                     // High reverb
            noteInterval: 4000,              // Long time between notes
            noteColor: "#3498db",            // Light blue
            description: "Ambient Pioneer"
        },
        
        // Erik Satie - French impressionist
        eriksatie: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 392.00, 440.00],      // Gymnop√©die No.1 fragment
                [246.94, 293.66, 329.63, 392.00, 415.30],      // Gymnop√©die No.2 fragment
                [233.08, 277.18, 329.63, 349.23, 415.30],      // Gymnop√©die No.3 fragment
                [261.63, 293.66, 349.23, 392.00, 493.88],      // Gnossiennes fragment
                [220.00, 277.18, 329.63, 392.00, 440.00],      // Je te veux fragment
                [233.08, 293.66, 349.23, 392.00, 466.16],      // Sparse voicing
                [261.63, 329.63, 392.00, 440.00, 523.25],      // Simple diatonic
                [220.00, 261.63, 329.63, 392.00, 440.00]       // Open minor voicing
            ],
            planeNotes: [
                [0, 2, 5, 9, 12],           // Gymnop√©die voicing
                [0, 3, 7, 10, 14],          // Minor 9th chord (Satie favorite)
                [0, 4, 7, 9, 14],           // Major 6/9 chord
                [0, 4, 10, 14, 17],         // Dominant 9th with sharp 11th
                [0, 3, 7, 14],              // Minor chord with added 9th
                [0, 2, 7, 10],              // Quartal harmony
                [0, 4, 8, 9],               // Major with augmented 5th and 6th
                [0, 5, 9, 12]               // Suspended 4th with 6th
            ],
            tempo: 55,                      // Very slow BPM
            decay: 7,                       // Long decay
            reverb: 0.4,                    // Medium reverb
            noteInterval: 3500,             // Long time between notes
            noteColor: "#9b59b6",           // Purple
            description: "Impressionist"
        },
        
        // Harold Budd - ambient pianist
        haroldbudd: {
            harmonicNotes: [
                [261.63, 329.63, 349.23, 392.00, 493.88],      // The Pearl fragment
                [246.94, 293.66, 349.23, 392.00, 493.88],      // Reverb-soaked piano
                [220.00, 277.18, 329.63, 392.00, 440.00],      // Simple progression
                [196.00, 261.63, 329.63, 392.00, 466.16],      // Pavilion of Dreams fragment
                [233.08, 293.66, 349.23, 392.00, 466.16],      // Ambient Piano melody
                [220.00, 261.63, 329.63, 349.23, 440.00],      // The White Arcades fragment
                [196.00, 246.94, 293.66, 392.00, 493.88],      // The Room fragment
                [220.00, 277.18, 329.63, 415.30, 493.88]       // By The Dawn's Early Light fragment
            ],
            planeNotes: [
                [0, 4, 5, 7, 12],           // Major with added 4th
                [0, 3, 7, 10, 14],          // Minor 9th chord
                [0, 5, 9, 12, 17],          // Suspended 4th with major 7th
                [0, 2, 6, 9, 16],           // Nondiatonic cluster
                [0, 4, 7, 11, 16],          // Major 7th with octave
                [0, 3, 7, 8, 15],           // Minor 6th with octave
                [0, 4, 6, 9, 12],           // Major with augmented 4th
                [0, 1, 5, 8, 12]            // Cluster with perfect 5th
            ],
            tempo: 50,                      // Very slow BPM
            decay: 8,                       // Very long decay
            reverb: 0.8,                    // High reverb
            noteInterval: 3000,             // Long time between notes
            noteColor: "#3498db",           // Blue
            description: "Reverb-soaked Piano"
        },
        
        // Stars of the Lid - drone
        starsofthelid: {
            harmonicNotes: [
                [130.81, 196.00, 261.63, 329.63],       // Low drone chord
                [146.83, 220.00, 261.63, 329.63],       // Another drone chord
                [164.81, 196.00, 261.63, 329.63],       // Shifting slow chord
                [174.61, 220.00, 261.63, 349.23],       // Droning F major
                [130.81,174.61, 220.00, 261.63, 349.23],       // Droning F major
                [130.81, 174.61, 261.63, 349.23],       // Open voicing
                [146.83, 196.00, 246.94, 349.23],       // Tired Sounds fragment
                [138.59, 185.00, 246.94, 329.63],       // And Their Refinement fragment
                [155.56, 196.00, 246.94, 293.66]        // Refinement of the Decline fragment
            ],
            planeNotes: [
                [-12, -5, 0, 7],            // Very low extension
                [-12, -8, 0, 4],            // Minor low voicing
                [-12, -7, 0, 7],            // Perfect 5th with low octave
                [-12, -5, 0, 5],            // Perfect 4th with low octave
                [-12, -9, -5, 0],           // Stacked 4ths down
                [-12, -7, -3, 0],           // Minor chord inverted
                [-12, -8, -5, 0],           // Cluster in low register
                [-7, -3, 0, 4]              // Drone-like cluster
            ],
            tempo: 40,                      // Extremely slow BPM
            decay: 10,                      // Maximum decay
            reverb: 0.9,                    // Maximum reverb
            noteInterval: 5000,             // Very long time between notes
            noteColor: "#2c3e50",           // Dark blue
            description: "Orchestral Drones"
        },
        
        // Boards of Canada - nostalgic synths
        boardsofcanada: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 392.00, 440.00],      // Music Has The Right fragment
                [246.94, 277.18, 329.63, 392.00, 440.00],      // Geogaddi fragment
                [233.08, 261.63, 329.63, 349.23, 392.00],      // Campfire Headphase fragment
                [220.00, 246.94, 293.66, 349.23, 415.30],      // Tomorrow's Harvest fragment
                [196.00, 233.08, 277.18, 349.23, 392.00],      // Slightly detuned melody
                [185.00, 220.00, 261.63, 329.63, 369.99],      // Nostalgic synth tones
                [207.65, 233.08, 277.18, 329.63, 415.30],      // Warped tape sound
                [220.00, 246.94, 277.18, 329.63, 392.00]       // Degraded sample
            ],
            planeNotes: [
                [0, 2, 4, 7, 9],            // Major pentatonic
                [0, 3, 5, 7, 10],           // Minor pentatonic
                [0, 4, 7, 10, 14],          // Major 7th with 6th
                [0, 3, 7, 10, 14],          // Minor 9th
                [0, 1, 4, 7, 10],           // Detuned minor 7th
                [0, 2, 7, 9, 15],           // Ambient loop fragment
                [0, 3, 6, 10, 15],          // Half-diminished with octave
                [0, 4, 7, 11, 18]           // Extended maj7 voicing
            ],
            tempo: 70,                      // Medium-slow BPM
            decay: 6,                       // Medium-long decay
            reverb: 0.5,                    // Medium reverb
            noteInterval: 2000,             // Medium time between notes
            noteColor: "#f39c12",           // Orange/amber
            description: "Nostalgic Synths"
        },
        
       // William Basinski - decaying loops
       williambasinski: {
            harmonicNotes: [
                [220.00, 261.63, 293.66, 349.23],      // Disintegration Loop 1.1 fragment
                [196.00, 233.08, 277.18, 329.63],      // Disintegration Loop 2.1 fragment
                [174.61, 220.00, 261.63, 311.13],      // Melancholia fragment 
                [164.81, 196.00, 246.94, 293.66],      // The River fragment
                [146.83, 185.00, 220.00, 277.18],      // Watermusic fragment
                [130.81, 174.61, 207.65, 261.63],      // Variations for Piano fragment
                [123.47, 164.81, 196.00, 246.94],      // A Shadow in Time fragment
                [138.59, 174.61, 220.00, 261.63]       // 92982 fragment
            ],
            planeNotes: [
                [0, 3, 7, 12],              // Simple minor with octave
                [-12, -5, 0, 7],            // Low extension with fifth
                [-7, 0, 4, 7],              // Low extension with major
                [-12, -8, -3, 0],           // Descending minor
                [-7, -3, 0, 4],             // Close position minor
                [-5, 0, 4, 7],              // Close position major
                [-12, -7, -3, 0],           // Low register minor
                [-12, -9, -5, 0]            // Descending fourths
            ],
            tempo: 45,                      // Very slow BPM
            decay: 9,                       // Very long decay 
            reverb: 0.85,                   // High reverb
            noteInterval: 5500,             // Very long time between notes
            noteColor: "#7f8c8d",           // Grey/muted
            description: "Decaying Loops"
        },
        
        // Steve Reich - minimalist phasing
        stevereich: {
            harmonicNotes: [
                [261.63, 293.66, 329.63, 349.23, 392.00],      // Piano Phase fragment
                [293.66, 329.63, 349.23, 392.00, 440.00],      // Different Trains fragment
                [220.00, 261.63, 293.66, 329.63, 349.23],      // Music for 18 Musicians fragment
                [246.94, 293.66, 329.63, 349.23, 392.00],      // Six Pianos fragment
                [233.08, 261.63, 293.66, 329.63, 392.00],      // Drumming fragment
                [261.63, 293.66, 311.13, 349.23, 392.00],      // Clapping Music fragment
                [277.18, 329.63, 349.23, 392.00, 440.00],      // Electric Counterpoint fragment
                [246.94, 261.63, 293.66, 329.63, 369.99]       // Music for Mallet Instruments fragment
            ],
            planeNotes: [
                [0, 2, 4, 5, 7],            // Reich's Piano Phase fragment
                [0, 4, 7, 11, 12],          // Electric Counterpoint fragment
                [0, 2, 3, 7, 9],            // Phasing pattern 1
                [0, 2, 4, 7, 9],            // Phasing pattern 2
                [0, 1, 4, 5, 7],            // Six Marimbas fragment
                [0, 3, 5, 9, 11],           // Tehillim fragment
                [0, 2, 5, 7, 9],            // Different Trains fragment
                [0, 3, 5, 7, 10]            // Desert Music fragment
            ],
            tempo: 105,                     // Medium-fast BPM
            decay: 3,                       // Short decay
            reverb: 0.25,                   // Low reverb
            noteInterval: 800,              // Short time between notes
            noteColor: "#e74c3c",           // Red
            description: "Phasing Patterns"
        },
        
        // Tim Hecker - digital textures
        timhecker: {
            harmonicNotes: [
                [130.81, 196.00, 261.63, 311.13, 369.99],      // Ravedeath fragment
                [146.83, 174.61, 233.08, 293.66, 349.23],      // Virgins fragment
                [123.47, 164.81, 207.65, 277.18, 329.63],      // Harmony in Ultraviolet fragment
                [138.59, 185.00, 246.94, 293.66, 369.99],      // Radio Amor fragment
                [110.00, 146.83, 196.00, 246.94, 311.13],      // Haunt Me fragment
                [130.81, 174.61, 220.00, 261.63, 329.63],      // Konoyo fragment
                [116.54, 155.56, 196.00, 233.08, 293.66],      // Anoyo fragment
                [146.83, 185.00, 220.00, 277.18, 349.23]       // Love Streams fragment
            ],
            planeNotes: [
                [-12, -5, 0, 4, 8],         // Extended cluster in low register
                [-12, -8, -5, 0, 4],        // Dense voicing 
                [-12, -7, -3, 0, 5],        // Dissonant voicing
                [-12, -9, -2, 0, 4],        // Complex cluster
                [-24, -12, -5, 0, 7],       // Very low extension
                [-12, -8, -1, 0, 3],        // Noise-like cluster
                [-12, -7, -2, 0, 7],        // Distorted harmony
                [-7, -3, 0, 4, 7]           // Compressed harmony
            ],
            tempo: 65,                      // Medium-slow BPM
            decay: 7,                       // Long decay
            reverb: 0.7,                    // High reverb
            noteInterval: 2500,             // Medium-long time between notes
            noteColor: "#8e44ad",           // Purple
            description: "Digital Textures"
        },
        
        // Ryuichi Sakamoto - minimal piano
        ryuichisakamoto: {
            harmonicNotes: [
                [261.63, 293.66, 349.23, 392.00, 440.00],      // Async fragment 
                [246.94, 293.66, 349.23, 392.00, 493.88],      // BTTB fragment
                [220.00, 277.18, 329.63, 392.00, 440.00],      // 1996 fragment
                [196.00, 246.94, 293.66, 349.23, 392.00],      // Neo Geo fragment
                [233.08, 261.63, 329.63, 392.00, 493.88],      // Merry Christmas Mr. Lawrence fragment
                [220.00, 261.63, 311.13, 392.00, 466.16],      // The Revenant fragment
                [246.94, 293.66, 329.63, 392.00, 440.00],      // Playing the Piano fragment
                [233.08, 277.18, 349.23, 392.00, 466.16]       // Solitude fragment
            ],
            planeNotes: [
                [0, 2, 5, 7, 9],            // Sakamoto pentatonic
                [0, 4, 7, 11, 14],          // Major 9th
                [0, 3, 7, 10, 14],          // Minor 9th
                [0, 4, 7, 12, 16],          // Major with double octave
                [0, 5, 7, 12, 17],          // Suspended with major 7th
                [0, 4, 7, 9, 11],           // Major 6th with added 7th
                [0, 2, 5, 9, 12],           // Japanese-influenced scale
                [0, 3, 7, 12, 15]           // Minor with octave and 10th
            ],
            tempo: 60,                      // Slow BPM
            decay: 6,                       // Medium-long decay
            reverb: 0.5,                    // Medium reverb
            noteInterval: 2200,             // Medium time between notes
            noteColor: "#16a085",           // Teal
            description: "Minimal Piano"
        },
        
        // Aphex Twin - selected ambient works
        aphextwin: {
            harmonicNotes: [
                [246.94, 277.18, 349.23, 392.00, 440.00],      // SAW 85-92 fragment
                [220.00, 261.63, 329.63, 392.00, 493.88],      // SAW Vol 2 fragment
                [196.00, 233.08, 293.66, 349.23, 466.16],      // Drukqs ambient fragment
                [174.61, 220.00, 277.18, 329.63, 415.30],      // Syro ambient fragment
                [261.63, 311.13, 349.23, 392.00, 466.16],      // Analogue Bubblebath fragment
                [233.08, 261.63, 311.13, 349.23, 440.00],      // Melodies From Mars fragment
                [246.94, 293.66, 349.23, 415.30, 493.88],      // Cheetah EP fragment
                [220.00, 261.63, 293.66, 349.23, 415.30]       // Collapse EP fragment
            ],
            planeNotes: [
                [0, 2, 7, 9, 12],           // Pentatonic with octave
                [0, 4, 7, 11, 16],          // Major 7th with 9th 
                [0, 3, 7, 10, 14],          // Minor 9th
                [0, 1, 5, 8, 12],           // Cluster with octave
                [0, 5, 7, 12, 17],          // Perfect 5th and suspensions
                [0, 4, 6, 10, 13],          // Lydian-influenced scale
                [0, 3, 7, 8, 15],           // Minor 6th with octave
                [0, 2, 4, 7, 11]            // Major 7th with 9th
            ],
            tempo: 85,                      // Medium BPM
            decay: 5,                       // Medium decay
            reverb: 0.4,                    // Medium reverb
            noteInterval: 1800,             // Medium time between notes
            noteColor: "#e74c3c",           // Red
            description: "Selected Ambient"
        },
        
        // Jon Hopkins - electronic ambient
        jonhopkins: {
            harmonicNotes: [
                [261.63, 329.63, 392.00, 440.00, 523.25],      // Immunity fragment
                [246.94, 293.66, 369.99, 440.00, 493.88],      // Singularity fragment
                [233.08, 277.18, 349.23, 415.30, 466.16],      // Opalescent fragment
                [220.00, 277.18, 329.63, 392.00, 466.16],      // Insides fragment
                [196.00, 261.63, 329.63, 392.00, 440.00],      // Asleep Versions fragment
                [220.00, 261.63, 329.63, 392.00, 493.88],      // Light Through The Veins fragment
                [246.94, 293.66, 349.23, 415.30, 523.25],      // Music For Psychedelic Therapy fragment
                [261.63, 293.66, 349.23, 440.00, 523.25]       // Piano Versions fragment
            ],
            planeNotes: [
                [0, 5, 9, 12, 17],          // Suspended with major 7th
                [0, 4, 7, 11, 16],          // Major 9th
                [0, 3, 7, 10, 14],          // Minor 9th
                [0, 2, 7, 11, 14],          // Quintal harmony with extensions
                [0, 4, 7, 9, 14],           // 6/9 chord
                [0, 5, 7, 12, 16],          // Suspended 4th with major 9th
                [0, 3, 7, 12, 15],          // Minor with octave and 10th
                [0, 2, 5, 9, 14]            // Cluster with wide intervals
            ],
            tempo: 90,                      // Medium-fast BPM
            decay: 5,                       // Medium decay
            reverb: 0.6,                    // Medium-high reverb
            noteInterval: 1500,             // Short-medium time between notes
            noteColor: "#3498db",           // Blue
            description: "Electronic Ambient"
        },
        
        // Various Artists - mixed inspiration (default)
        various: {
            harmonicNotes: [
                // Mix of scales from all artists
                [261.63, 329.63, 392.00, 493.88],              // Eno-inspired
                [246.94, 293.66, 329.63, 392.00, 415.30],      // Satie-inspired
                [220.00, 277.18, 329.63, 392.00, 440.00],      // Budd-inspired
                [130.81, 196.00, 261.63, 329.63],              // Stars of the Lid-inspired
                [261.63, 293.66, 329.63, 392.00, 440.00],      // Boards of Canada-inspired
                [196.00, 246.94, 293.66, 349.23, 392.00],      // Sakamoto-inspired
                [261.63, 293.66, 329.63, 349.23, 392.00],      // Reich-inspired
                [246.94, 293.66, 369.99, 440.00, 493.88]       // Hopkins-inspired
            ],
            planeNotes: [
                // Mix of intervals from all artists
                [0, 4, 7, 12],              // Major triad with octave
                [0, 3, 7, 10, 14],          // Minor 9th (Satie favorite)
                [0, 5, 9, 12, 17],          // Suspended with major 7th (Budd)
                [-12, -5, 0, 7],            // Very low extension (Stars of the Lid)
                [0, 2, 4, 7, 9],            // Major pentatonic (Boards of Canada)
                [0, 2, 5, 7, 9],            // Sakamoto pentatonic
                [0, 2, 4, 5, 7],            // Reich's Piano Phase fragment
                [0, 4, 7, 11, 16]           // Major 9th (Hopkins)
            ],
            tempo: 70,                      // Medium BPM
            decay: 5,                       // Medium decay
            reverb: 0.5,                    // Medium reverb
            noteInterval: 2500,             // Medium time between notes
            noteColor: "#2ecc71",           // Green
            description: "Mixed Inspiration"
        }
    };
    
    // Current active scales
    let harmonicNotes = musicalScales.worldTour.harmonicNotes;
    let planeNotes = musicalScales.worldTour.planeNotes;

    // Enhanced terrain types
    const terrainTypes = [
        // Natural landscapes
        "mountain ranges", "coastal regions", "desert landscapes", "forest canopies", "glacial fields",
        "river valleys", "tropical rainforests", "vast savannas", "arctic tundra", "volcanic regions",
        "dense jungles", "rolling hills", "majestic canyons", "expansive plateaus", "serene lakeshores",
        "scenic fjords", "rugged badlands", "misty marshlands", "lush wetlands", "ancient redwood forests",
        
        // Water bodies
        "coral reefs", "deep ocean waters", "island archipelagos", "misty lakes", "winding rivers",
        "azure lagoons", "pristine coastlines", "tidal estuaries", "tranquil bays", "secluded inlets",
        "turquoise shoals", "meandering deltas", "crystalline streams", "boundless oceans", "shimmering seas",
        
        // Weather phenomena
        "thunderstorm systems", "foggy valleys", "clear skies", "aurora displays", "sunset gradients",
        "monsoon clouds", "morning mists", "evening hazes", "passing showers", "gathering storm fronts",
        "sun-dappled clearings", "rainbow arches", "cumulus formations", "starlit horizons", "moonlit panoramas",
        
        // Regional specific
        "alpine meadows", "bamboo forests", "terraced fields", "ancient valleys", "pristine beaches",
        "rugged highlands", "remote plateaus", "flowering meadows", "pine forests", "autumn woodlands",
        "cherry blossom groves", "olive orchards", "lavender fields", "rice paddies", "desert oases",
        "mangrove swamps", "eucalyptus woods", "palm-lined shores", "snow-capped summits", "mossy glens"
    ];
    
    // View descriptions
    const viewTypes = [
        "golden sunset", "cloud formations", "mountain ranges", "ocean vistas", "city lights",
        "morning mist", "starlit horizon", "aurora borealis", "desert mirage", "rolling hills",
        "snow-capped peaks", "tropical islands", "canyon depths", "forest canopy", "coastal shores",
        "twilight shadows", "crystalline lakes", "lush valleys", "autumn foliage", "spring blossoms",
        "emerald fjords", "coral gardens", "volcanic craters", "windswept prairies", "arctic icescapes",
        "ancient ruins", "cascading waterfalls", "winding riverbeds", "jagged cliffs", "sapphire seas",
        "crimson sunrises", "monsoon clouds", "terraced landscapes", "midnight blues", "gilded horizons",
        "towering redwoods", "meandering coastlines", "bamboo thickets", "shimmering mirages", "moonlit peaks"
    ];
    
    // Weather descriptions
    const weatherTypes = [
        "calm", "clear", "slightly turbulent", "calm", "clear", "slightly turbulent", "overcast", "partly cloudy",
        "misty", "breezy", "tranquil", "serene", "mild",
        "stable", "gentle", "favorable", "pleasant", "harmonious",
        "smooth", "bright", "glowing", "subtle", "refreshing",
        "crisp", "balmy", "temperate", "placid", "radiant",
        "moderate", "fair", "steady", "consistent", "agreeable",
        "peaceful", "luminous", "mild", "soothing", "benign",
        "pristine", "idyllic", "delightful", "invigorating", "splendid"
    ];
    
    // Atmosphere descriptions
    const atmosphereTypes = [
        "smooth", "turbulent", "cool", "warm", "high pressure",
        "gentle", "refreshing", "dense", "thin", "clear",
        "serene", "placid", "crisp", "enveloping", "textured",
        "harmonious", "flowing", "balanced", "resonant", "tranquil",
        "buoyant", "dynamic", "crystalline", "rarefied", "stratified",
        "ethereal", "layered", "vibrant", "translucent", "pristine",
        "meditative", "contemplative", "shimmering", "breathable", "revitalizing",
        "luminous", "ambient", "undulating", "suspended", "delicate"
    ];
    
    // Obstacle types
    const obstacleTypes = [
        "storm clouds", "air traffic", "weather systems", "high altitude turbulence",
        "thermal layers", "pressure gradients", "wind currents", "atmospheric disturbances",
        "dense cloud banks", "shifting weather fronts", "temperature inversions",
        "migration patterns", "dynamic air masses", "moisture pockets", "thermal updrafts",
        "jetstream flows", "convection cells", "condensation zones", "cyclonic patterns",
        "stratospheric waves", "cumulus buildups", "convergence zones", "shear boundaries",
        "electrical storms", "radiation belts", "solar wind effects", "mesospheric ripples",
        "aurora curtains", "cosmic radiation", "meteorological anomalies", "dust clouds",
        "navigation beacons", "communication signals", "satellite trajectories", "ionospheric fluctuations"
    ];
    
    // Flight announcements templates with Oblique Strategies influences
    const announcements = [
        "Ladies and gentlemen, we're currently flying at {altitude} feet above sea level. Outside temperature is {temp}¬∞C.",
        "This is your flight attendant speaking. We're experiencing some {turbulence} turbulence as we fly over {terrain}.",
        "Cabin crew, prepare for {phase}. We expect to reach our cruising altitude shortly.",
        "Passengers, please note the beautiful {view} you can see below us as we pass over {terrain}.",
        "We're currently experiencing a slight {change} in our flight path to navigate around {obstacle}.",
        "This is your captain speaking. We're expecting {weather} conditions for the remainder of our journey.",
        "Ladies and gentlemen, we're beginning our {phase} phase. Please remain seated with your seatbelts fastened.",
        "We're pleased to inform you that we're making excellent {progress} and expect to arrive on schedule.",
        "Cabin crew, prepare the cabin for {phase}. We'll be reaching our destination in approximately {time} minutes.",
        "This is your co-pilot speaking. We're currently flying through a {atmosphere} air current at {altitude} feet.",
        // Oblique Strategies inspired announcements
        "Ladies and gentlemen, we invite you to honor your errors as hidden intentions as we fly over {terrain} at {altitude} feet.",
        "This is your captain speaking. We've discovered a new perspective at {altitude} feet, where we can observe {terrain} from an entirely different angle.",
        "Cabin announcement: We're taking a moment to appreciate the edges of this {atmosphere} atmosphere as we cross into {terrain}.",
        "Passengers, as we travel at {altitude} feet, remember that repetition is a form of change. We'll be flying over {terrain} for the next {time} minutes.",
        "This is your flight crew inviting you to look at the {view} from a different perspective as we consider the quiet needs of our journey over {terrain}.",
        "Ladies and gentlemen, as we traverse these {terrain}, consider how different this landscape would be if approached from another direction.",
        "Cabin announcement: We're embracing the quality of simplicity as we navigate through this {atmosphere} atmosphere at {altitude} feet.",
        "This is your captain speaking. Rather than solving the problem of altitude adjustments, we're changing the problem as we approach these {obstacle}.",
        "Passengers, as we observe the {view} below, remember that not all places need to be filled with something - the beauty sometimes lies in the spaces between.",
        "This is your captain inviting you to consider the remarkable {terrain} below as a landscape of pure possibility and transformation.",
        "Ladies and gentlemen, consider this flight as a metaphor‚Äîwe are moving through {atmosphere} conditions while being perfectly still within our vessel.",
        "Cabin crew has noted that the {weather} conditions outside create a perfect balance of opposites as we pass over {terrain}.",
        "This is your co-pilot speaking. We invite you to trust in the increasing simplicity of this journey as we follow invisible currents over {terrain}.",
        "Passengers, we're currently experiencing what we might call 'the most easily forgotten thing' as we witness this {view} from {altitude} feet.",
        "Your flight attendants suggest taking a moment to look away from the {view} and then look back, to see it with fresh eyes as we continue our journey.",
        "Ladies and gentlemen, we are deliberately flying through this {atmosphere} atmosphere to remind ourselves of the value of the overlooked."
    ];
    
    // Artist-specific announcements
    const artistAnnouncements = {
        // Brian Eno announcements
        brianeno: [
            "Ladies and gentlemen, we're creating an ambient environment at {altitude} feet as we fly over {terrain}.",
            "This is your captain speaking. We're entering a space where process takes precedence over product.",
            "Cabin announcement: As we fly over {terrain}, remember that ambient music must be as ignorable as it is interesting.",
            "Passengers, we're now following one of the Oblique Strategies: '{view} over {terrain}'.",
            "We invite you to appreciate how the landscape below provides us with discreet music at {altitude} feet.",
            "This is your co-pilot speaking. We're currently in a space between melody and texture, flying through {atmosphere} air currents."
        ],
        
        // Erik Satie announcements
        eriksatie: [
            "Ladies and gentlemen, we've entered what Satie would call 'furniture music' as we drift over {terrain}.",
            "This is your captain speaking. We're approaching Gymnop√©die airspace at {altitude} feet.",
            "Cabin announcement: Please note the beautiful {view} below, inspiring our slow, atmospheric descent.",
            "Passengers, prepare for a gentle entrance of the Gnossiennes as we navigate around {obstacle}.",
            "We're experiencing what Satie called a 'necessary pause' as we fly through {atmosphere} conditions above {terrain}.",
            "This is your co-pilot speaking. We're maintaining a gentle tempo of {time} beats per minute above the {terrain}."
        ],
        
        // Harold Budd announcements
        haroldbudd: [
            "Ladies and gentlemen, we're floating through reverb-soaked atmosphere at {altitude} feet above {terrain}.",
            "This is your captain speaking. We're encountering sustained piano tones as we pass over {terrain}.",
            "Cabin announcement: The {view} below is reflected in our soft pedal navigation through {atmosphere} air.",
            "Passengers, note how the reverb extends our flight path as we navigate around {obstacle}.",
            "We're experiencing the spacious echoes of our journey over {terrain}, continuing for the next {time} minutes.",
            "This is your co-pilot speaking. We're in a state of suspended motion over {terrain}, drifting like sustained piano notes."
        ]
    };
    
    // Helper function to adjust opacity of a color
    function adjustOpacity(color, opacity) {
        if (color.startsWith('rgba')) {
            const parts = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/);
            if (parts) {
                return `rgba(${parts[1]}, ${parts[2]}, ${parts[3]}, ${opacity})`;
            }
        } else if (color.startsWith('#')) {
            // Convert hex to rgba
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }
        return color;
    }
    
    // Welcome overlay functions
    function hideWelcomeOverlay() {
        console.log('Hiding welcome overlay...');
        const welcomeOverlay = document.getElementById('welcomeOverlay');
        if (welcomeOverlay) {
            welcomeOverlay.classList.add('hidden');
            setTimeout(() => {
                welcomeOverlay.style.display = 'none';
            }, 500);

            // Initialize audio when welcome is dismissed
            if (!audioContext || audioContext.state === 'closed') {
                console.log('Initializing audio from welcome overlay...');
                initializeAudio();
            }

            showStatus('Welcome aboard! Ready for takeoff.');
        } else {
            console.error('Welcome overlay element not found!');
        }
    }

    function showWelcomeOverlay() {
        const welcomeOverlay = document.getElementById('welcomeOverlay');
        if (welcomeOverlay) {
            welcomeOverlay.style.display = 'flex';
            setTimeout(() => {
                welcomeOverlay.classList.remove('hidden');
            }, 10);
        }
    }

    // Help overlay functions
    function showHelpOverlay() {
        if (helpOverlay) {
            helpOverlay.classList.remove('hidden');
        }
    }

    function hideHelpOverlay() {
        if (helpOverlay) {
            helpOverlay.classList.add('hidden');
        }
    }

    function toggleHelpOverlay() {
        if (helpOverlay) {
            if (helpOverlay.classList.contains('hidden')) {
                showHelpOverlay();
            } else {
                hideHelpOverlay();
            }
        }
    }

    // Initialize the application
    function init() {
        // Load user settings
        loadSettings();
        
        // Set up canvas to ensure proper sizing
        resetAllCanvases();
        
        // Set up event listeners
        setupEventListeners();
        
        // Hide cockpit initially (expanded when user clicks)
        cockpitContainer.classList.add('collapsed');
        
        // Update UI with default values
        updateUIState();

        // Initially hide plane
        plane.style.display = 'none';

        // Set initial UI state for effect panels
        document.getElementById('filterControlsPanel').style.display = 'none';
        document.getElementById('compressorControlsPanel').style.display = 'none';
        
        // Initially disable land button
        if (landButton) landButton.disabled = true;
        
        // Show welcome message
        showStatus('Welcome aboard! Click "Take Off" to begin your musical journey.');
        
        console.log("Application initialized successfully");
    }
    
    // Load user settings from localStorage
    function loadSettings() {
        if (localStorage.getItem('musicAirplaneSettings')) {
            try {
                const settings = JSON.parse(localStorage.getItem('musicAirplaneSettings'));
                
                // Apply dark mode if saved
                if (settings.darkMode) {
                    document.body.classList.add('dark-mode');
                    darkModeToggle.checked = true;
                }
                
                // Load safety settings
                if (settings.safeLowFreq) {
                    safeLowFreq = settings.safeLowFreq;
                    safeLowFreqControl.value = safeLowFreq;
                    document.getElementById('safeLowFreqValue').textContent = safeLowFreq + ' Hz';
                }
                
                if (settings.limiterThreshold) {
                    limiterThreshold = settings.limiterThreshold;
                    limiterThresholdControl.value = limiterThreshold;
                    document.getElementById('limiterThresholdValue').textContent = limiterThreshold + ' dB';
                }
                
                console.log('Settings loaded:', settings);
            } catch (e) {
                console.error('Error loading settings:', e);
            }
        }
    }
    
    // Save user settings to localStorage
    function saveSettings() {
        const settings = {
            darkMode: darkModeToggle.checked,
            safeLowFreq: parseInt(safeLowFreqControl.value),
            limiterThreshold: parseFloat(limiterThresholdControl.value)
        };
        
        localStorage.setItem('musicAirplaneSettings', JSON.stringify(settings));
        console.log('Settings saved:', settings);
        
        // Apply the settings immediately
        if (darkModeToggle.checked) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }
        
        safeLowFreq = parseInt(safeLowFreqControl.value);
        limiterThreshold = parseFloat(limiterThresholdControl.value);
        
        // Update audio nodes if they exist
        updateAudioSafetySettings();
        
        // Hide the settings panel
        settingsPanel.style.display = 'none';
        
        // Show a confirmation message
        showStatus('Settings saved successfully');
    }
    
    // Setup event listeners
    function setupEventListeners() {
        // Cockpit toggle
        cockpitToggle.addEventListener('click', toggleCockpit);
        
        // Basic flight controls
        takeoffButton.addEventListener('click', takeOff);
        landButton.addEventListener('click', land);
        testAudioButton.addEventListener('click', testAudio);
        fullscreenBtn.addEventListener('click', toggleFullScreen);
        randomizeAllButton.addEventListener('click', randomizeAll);
        toggleUIButton.addEventListener('click', toggleUI);
        clearTrailButton.addEventListener('click', clearTrail);
        flightLogBtn.addEventListener('click', showFlightLog);
        
        // Flight control sliders
        altitudeControl.addEventListener('input', updateAltitude);
        tempoControl.addEventListener('input', updateTempo);
        persistenceControl.addEventListener('input', updatePersistence);
        trailIntensityControl.addEventListener('input', updateTrailIntensity);
        
        // Audio control sliders
        volumeControl.addEventListener('input', updateVolume);
        reverbControl.addEventListener('input', updateReverb);
        decayControl.addEventListener('input', updateDecay);
        bassLevelControl.addEventListener('input', updateBassLevel);
        
        // Effect toggles
        filterToggle.addEventListener('change', toggleFilter);
        lfoToggle.addEventListener('change', toggleLFO);
        compressorToggle.addEventListener('change', toggleCompressor);
        engineToggle.addEventListener('change', toggleEngine);
        windToggle.addEventListener('change', toggleWind);
        altitudeFilterToggle.addEventListener('change', toggleAltitudeFilter);
        rainToggle.addEventListener('change', toggleRain);
        thunderToggle.addEventListener('change', toggleThunder);

        // Filter controls
        filterCutoffControl.addEventListener('input', updateFilterCutoff);
        lfoRateControl.addEventListener('input', updateLfoRate);
        lfoAmountControl.addEventListener('input', updateLfoAmount);
        
        // Compressor controls
        compThresholdControl.addEventListener('input', updateCompressorThreshold);
        compRatioControl.addEventListener('input', updateCompressorRatio);
        compAttackControl.addEventListener('input', updateCompressorAttack);
        compReleaseControl.addEventListener('input', updateCompressorRelease);
        
        // Preset selectors
        filterPresetsSelect.addEventListener('change', applyFilterPreset);
        compressorPresetsSelect.addEventListener('change', applyCompressorPreset);
        
        // Artist selector
        artistSelector.addEventListener('change', function() {
            selectArtist(this.value);
        });
        
        // Destination buttons
        destinationButtons.forEach(button => {
            button.addEventListener('click', function() {
                const destId = this.id.replace('dest', '').toLowerCase();
                changeDestination(destId);
            });
        });
        
        // Settings panel
        settingsButton.addEventListener('click', openSettings);
        saveSettingsBtn.addEventListener('click', saveSettings);
        closeSettingsBtn.addEventListener('click', closeSettings);

        // Help overlay
        helpButton.addEventListener('click', showHelpOverlay);
        helpCloseBtn.addEventListener('click', hideHelpOverlay);
        helpOverlay.addEventListener('click', function(e) {
            if (e.target === helpOverlay) {
                hideHelpOverlay();
            }
        });

        // Dark mode toggle
        darkModeToggle.addEventListener('change', function() {
            if (this.checked) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        });
        
        // Safe low frequency control
        safeLowFreqControl.addEventListener('input', function() {
            const value = parseInt(this.value);
            document.getElementById('safeLowFreqValue').textContent = value + ' Hz';
        });
        
        // Limiter threshold control
        limiterThresholdControl.addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('limiterThresholdValue').textContent = value.toFixed(1) + ' dB';
        });
        
        // Emergency eject button
        emergencyEjectBtn.addEventListener('click', emergencyEject);
        
        // Announcement panel click dismissal
        document.getElementById('announcement').addEventListener('click', fadeOutAnnouncement);
        
        // Window resize handler
        window.addEventListener('resize', function() {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(function() {
                resizeCanvases();
            }, 250);
        });

        // Welcome overlay
        const welcomeStartBtn = document.getElementById('welcomeStartBtn');
        if (welcomeStartBtn) {
            console.log('Welcome button found, attaching listener');
            welcomeStartBtn.addEventListener('click', function(e) {
                console.log('Welcome button clicked!');
                e.preventDefault();
                e.stopPropagation();
                hideWelcomeOverlay();
            });
        } else {
            console.error('Welcome button NOT found!');
        }

        // Landing destination system
        const destinationCards = document.querySelectorAll('.destination-card');
        destinationCards.forEach(card => {
            card.addEventListener('click', function() {
                // Remove selected class from all cards
                destinationCards.forEach(c => c.classList.remove('selected'));

                // Add selected class to clicked card
                this.classList.add('selected');

                // Get the space key
                const spaceKey = this.getAttribute('data-space');

                // Complete landing at this destination
                completeLanding(spaceKey);
            });
        });

        // Cancel landing button
        const cancelLandingBtn = document.getElementById('cancelLandingBtn');
        if (cancelLandingBtn) {
            cancelLandingBtn.addEventListener('click', hideLandingSelector);
        }

        // Atmosphere selectors
        const timeSelect = document.getElementById('timeSelect');
        if (timeSelect) {
            timeSelect.addEventListener('change', function() {
                currentTime = this.value;
            });
        }

        const weatherSelect = document.getElementById('weatherSelect');
        if (weatherSelect) {
            weatherSelect.addEventListener('change', function() {
                currentWeather = this.value;
            });
        }

        const seasonSelect = document.getElementById('seasonSelect');
        if (seasonSelect) {
            seasonSelect.addEventListener('change', function() {
                currentSeason = this.value;
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Prevent shortcuts when typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    if (isFlying) {
                        land();
                    } else {
                        takeOff();
                    }
                    break;
                case 'c':
                    e.preventDefault();
                    toggleCockpit();
                    break;
                case 'u':
                    e.preventDefault();
                    toggleUI();
                    break;
                case 'f':
                    e.preventDefault();
                    toggleFullScreen();
                    break;
                case 'r':
                    e.preventDefault();
                    randomizeAll();
                    break;
                case 't':
                    e.preventDefault();
                    clearTrail();
                    break;
                case 'l':
                    e.preventDefault();
                    showFlightLog();
                    break;
                case 'h':
                    e.preventDefault();
                    toggleHelpOverlay();
                    break;
                case 'escape':
                    e.preventDefault();
                    // Close help overlay if it's open, otherwise emergency eject
                    if (helpOverlay && !helpOverlay.classList.contains('hidden')) {
                        hideHelpOverlay();
                    } else {
                        emergencyEject();
                    }
                    break;
            }
        });
    }
    
    // Toggle cockpit display
    function toggleCockpit() {
        const isCollapsed = cockpitContainer.classList.contains('collapsed');
        
        if (isCollapsed) {
            cockpitContainer.classList.remove('collapsed');
            cockpitContainer.classList.add('expanded');
            cockpitToggle.textContent = 'Hide Controls';
        } else {
            cockpitContainer.classList.remove('expanded');
            cockpitContainer.classList.add('collapsed');
            cockpitToggle.textContent = 'Flight Controls';
        }
    }
    
    // Toggle UI visibility
    function toggleUI() {
        uiVisible = !uiVisible;
        
        if (uiVisible) {
            flightContainer.classList.remove('hide-ui');
            toggleUIButton.textContent = 'Hide UI';
        } else {
            flightContainer.classList.add('hide-ui');
            toggleUIButton.textContent = 'Show UI';
        }
    }
    
    // Update UI state based on current settings
    function updateUIState() {
        // Update volume value
        document.getElementById('volumeValue').textContent = parseFloat(volumeControl.value).toFixed(2);
        
        // Update reverb value
        document.getElementById('reverbValue').textContent = Math.floor(parseFloat(reverbControl.value) * 100) + '%';
        
        // Update decay value
        document.getElementById('decayValue').textContent = parseFloat(decayControl.value).toFixed(1) + 's';
        
        // Update bass level value
        document.getElementById('bassLevelValue').textContent = Math.floor(parseFloat(bassLevelControl.value) * 100) + '%';
        
        // Update altitude slider text
        const altitudeValue = parseFloat(altitudeControl.value);
        let altitudeText = "Cruising";
        if (altitudeValue < 0.8) altitudeText = "Low Altitude";
        else if (altitudeValue > 1.2) altitudeText = "High Altitude";
        document.getElementById('altitudeValue').textContent = altitudeText;
        
        // Update tempo value
        document.getElementById('tempoValue').textContent = parseInt(tempoControl.value);
        document.getElementById('tempoBPM').textContent = parseInt(tempoControl.value) + ' BPM';
        
        // Update persistence value
        document.getElementById('persistenceValue').textContent = Math.floor(parseFloat(persistenceControl.value) * 100) + '%';
        
        // Update trail intensity value
        document.getElementById('trailIntensityValue').textContent = parseFloat(trailIntensityControl.value).toFixed(1);
        
        // Update filter controls
        document.getElementById('filterCutoffValue').textContent = parseInt(filterCutoffControl.value) + ' Hz';
        document.getElementById('lfoRateValue').textContent = lfoDivisions[parseInt(lfoRateControl.value)].name;
        document.getElementById('lfoAmountValue').textContent = parseInt(lfoAmountControl.value) + '%';
        
        // Update compressor controls
        document.getElementById('compThresholdValue').textContent = parseInt(compThresholdControl.value) + ' dB';
        document.getElementById('compRatioValue').textContent = parseFloat(compRatioControl.value).toFixed(1) + ':1';
        document.getElementById('compAttackValue').textContent = parseFloat(compAttackControl.value).toFixed(2) + 's';
        document.getElementById('compReleaseValue').textContent = parseFloat(compReleaseControl.value).toFixed(2) + 's';
        
        // Update LED indicators
        updateLEDIndicators();
        
        // Update artist info
        updateArtistInfo();
        
        // Update gauges
        updateGauges();
    }
    
    // Update LED indicators
    function updateLEDIndicators() {
        // Filter LED
        if (isFilterEnabled) {
            filterLed.classList.add('active');
            filterLed.classList.add('filter');
        } else {
            filterLed.classList.remove('active');
            filterLed.classList.remove('filter');
        }
        
        // LFO LED
        if (isLfoEnabled) {
            lfoLed.classList.add('active');
        } else {
            lfoLed.classList.remove('active');
        }
        
        // Compressor LED
        if (isCompressorEnabled) {
            compressorLed.classList.add('active');
            compressorLed.classList.add('compressor');
        } else {
            compressorLed.classList.remove('active');
            compressorLed.classList.remove('compressor');
        }
    }
    
    // Update artist info in UI
    function updateArtistInfo() {
        // Get the artist style info
        const artist = artistStyles[currentArtist];
        
        if (artist) {
            artistInfo.innerHTML = `
                <div>${currentArtistName}</div>
                <div class="artist-style">${artist.description}</div>
            `;
        } else {
            artistInfo.innerHTML = `
                <div>Various Artists</div>
                <div class="artist-style">Mixed Inspiration</div>
            `;
        }
    }
    
    // Update gauges
    function updateGauges() {
        // Update flight time needle (rotates based on elapsed time - full circle after 1 hour)
        if (flightStartTime) {
            const elapsedMs = Date.now() - flightStartTime;
            const hourProgress = (elapsedMs / (60 * 60 * 1000)) % 1; // Progress through an hour (0-1)
            const degrees = hourProgress * 360;
            timeNeedle.style.transform = `translateX(-50%) rotate(${degrees}deg)`;
        } else {
            timeNeedle.style.transform = 'translateX(-50%) rotate(0deg)';
        }
        
        // Update altitude needle (rotates based on altitude control)
        const altValue = parseFloat(altitudeControl.value);
        const altDegrees = ((altValue - 0.5) / 1.5) * 360; // Map 0.5-2.0 to 0-360
        altitudeNeedle.style.transform = `translateX(-50%) rotate(${altDegrees}deg)`;
        
        // Update altitude display
        const altitudeFeet = Math.floor(altValue * 25000);
        document.getElementById('flightAltitude').textContent = altitudeFeet.toLocaleString() + ' ft';
        
        // Update tempo needle (rotates based on tempo control)
        const tempoValue = parseInt(tempoControl.value);
        const tempoDegrees = ((tempoValue - 40) / 160) * 360; // Map 40-200 to 0-360
        tempoNeedle.style.transform = `translateX(-50%) rotate(${tempoDegrees}deg)`;
    }
    
    // Open settings panel
    function openSettings() {
        settingsPanel.style.display = 'block';
    }
    
    // Close settings panel
    function closeSettings() {
        settingsPanel.style.display = 'none';
    }
    
    // Toggle fullscreen
    function toggleFullScreen() {
        const doc = window.document;
        const docEl = doc.documentElement;
      
        const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen ||
                              docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen ||
                             doc.webkitExitFullscreen || doc.msExitFullscreen;
      
        if (!doc.fullscreenElement && !doc.mozFullScreenElement &&
            !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            requestFullScreen.call(docEl);
            fullscreenBtn.textContent = "Exit Full";
        } else {
            cancelFullScreen.call(doc);
            fullscreenBtn.textContent = "Full Screen";
        }
    }
    
    // Set canvas sizes
    function resizeCanvases() {
        const container = document.querySelector('.flight-display');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        setCanvasDimensions(width, height);
        
        // Force redraw if flying
        if (isFlying) {
            drawLandscape();
            drawStars();
            drawNoteVisualization();
            if (trailPermaMode && smoothedTrail.length > 0) {
                drawPermanentTrail();
            }
        }
    }
    
    // Helper function to set canvas dimensions
    function setCanvasDimensions(width, height) {
        // Make sure we have valid dimensions
        if (width <= 0 || height <= 0) {
            width = window.innerWidth;
            height = window.innerHeight * 0.7; // 70vh
        }
        
        [flightCanvas, noteCanvas, landscapeCanvas, starsCanvas, trailCanvas].forEach(canvas => {
            if (canvas) {
                // Set the actual drawing buffer size
                canvas.width = width;
                canvas.height = height;
                
                // Ensure CSS dimensions match
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
            }
        });
    }
    
    // Add this function to force a full reset of all canvases
    function resetAllCanvases() {
        // Force a resize of all canvases
        resizeCanvases();
        
        // Clear all canvases
        if (flightCtx) flightCtx.clearRect(0, 0, flightCanvas.width, flightCanvas.height);
        if (noteCtx) noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
        if (landscapeCtx) landscapeCtx.clearRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);
        if (starsCtx) starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
        if (trailCtx) trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
        
        // Add a timeout to force another resize after a brief delay
        // This helps in some browsers where the initial size might not be correct
        setTimeout(resizeCanvases, 100);
    }
    
    // Initialize audio context with safety features
    function initializeAudio() {
        try {
            // Check if AudioContext is supported
            if (!window.AudioContext && !window.webkitAudioContext) {
                throw new Error('Web Audio API is not supported in this browser');
            }
            
            // Only create a new AudioContext if it doesn't exist or is closed
            if (!audioContext || audioContext.state === 'closed') {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Created new AudioContext');
            }
            
            // Resume context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully');
                    showStatus('Cabin audio system resumed successfully!');
                }).catch(err => {
                    console.warn('Could not resume AudioContext automatically:', err);
                });
            }
            
            // Create master gain node
            masterGainNode = audioContext.createGain();
            masterGainNode.gain.setValueAtTime(parseFloat(volumeControl.value), audioContext.currentTime);
            
            // Create high-pass filter (ALWAYS ACTIVE - prevents frequencies below 20Hz)
            highPassFilter = audioContext.createBiquadFilter();
            highPassFilter.type = 'highpass';
            highPassFilter.frequency.setValueAtTime(safeLowFreq, audioContext.currentTime);
            highPassFilter.Q.value = 0.7; // Moderate Q for a gentle slope
            
            // Create bass EQ filter (low-shelf type)
            bassEQNode = audioContext.createBiquadFilter();
            bassEQNode.type = 'lowshelf';
            bassEQNode.frequency.setValueAtTime(250, audioContext.currentTime); // 250Hz is a good point for bass control
            
            // Set initial bass level from control
            const bassLevel = parseFloat(bassLevelControl.value);
            const scaledGain = bassLevel * 6 - 3; // Range from -3dB to +3dB
            bassEQNode.gain.setValueAtTime(scaledGain, audioContext.currentTime);
            
            // Create safety limiter (ALWAYS ACTIVE)
            limiterNode = audioContext.createDynamicsCompressor();
            limiterNode.threshold.setValueAtTime(limiterThreshold, audioContext.currentTime);
            limiterNode.ratio.setValueAtTime(20, audioContext.currentTime); // Hard limiting
            limiterNode.attack.setValueAtTime(0.001, audioContext.currentTime); // Fast attack
            limiterNode.release.setValueAtTime(0.1, audioContext.currentTime); // Quick release
            limiterNode.knee.setValueAtTime(0, audioContext.currentTime); // Hard knee for true limiting
            
            // Create reverb setup
            setupReverb();
            
            // Create filter (but don't enable unless toggled)
            setupFilter();
            
            // Create compressor (but don't enable unless toggled)
            setupCompressor();
            
            // Set up the complete audio chain
            setupAudioChain();
            
            // Set up audio meter
            setupAudioMeter();
            
            showStatus('Cabin audio system initialized! Click Take Off to start.');
            
            if (takeoffButton) {
                takeoffButton.disabled = false;
            }
            
            return true;
        } catch (error) {
            console.error('Audio Initialization Error:', error);
            showStatus('Cabin audio system error: ' + error.message + '. Try a different browser.');
            return false;
        }
    }
    
    // Update audio safety settings
    function updateAudioSafetySettings() {
        if (audioContext) {
            // Update high pass filter
            if (highPassFilter) {
                highPassFilter.frequency.setValueAtTime(safeLowFreq, audioContext.currentTime);
                console.log('Updated high-pass filter frequency to', safeLowFreq, 'Hz');
            }
            
            // Update limiter
            if (limiterNode) {
                limiterNode.threshold.setValueAtTime(limiterThreshold, audioContext.currentTime);
                console.log('Updated limiter threshold to', limiterThreshold, 'dB');
            }
        }
    }
    
    // Set up audio chain
    function setupAudioChain() {
        if (!audioContext || !masterGainNode) return false;
        
        try {
            // First disconnect all nodes to rebuild the chain
            try {
                masterGainNode.disconnect();
                if (highPassFilter) highPassFilter.disconnect();
                if (bassEQNode) bassEQNode.disconnect();
                if (filterNode) filterNode.disconnect();
                if (compressorNode) compressorNode.disconnect();
                if (limiterNode) limiterNode.disconnect();
                if (reverbNode) reverbNode.disconnect();
                if (dryGainNode) dryGainNode.disconnect();
                if (wetGainNode) wetGainNode.disconnect();
            } catch (e) {
                console.warn("Error disconnecting nodes:", e);
            }
            
            // Build the audio chain based on which effects are enabled
            let lastNode = masterGainNode;
            
            // ALWAYS include high-pass filter first for safety (prevent <20Hz content)
            if (highPassFilter) {
                lastNode.connect(highPassFilter);
                lastNode = highPassFilter;
            }
            
            // Next include bass EQ if available
            if (bassEQNode) {
                lastNode.connect(bassEQNode);
                lastNode = bassEQNode;
            }

            // Connect cabin pressure filter if enabled (altitude-based)
            if (cabinPressureFilter && isCabinPressureEnabled) {
                lastNode.connect(cabinPressureFilter);
                lastNode = cabinPressureFilter;
            }

            // Connect filter if enabled
            if (filterNode && isFilterEnabled) {
                lastNode.connect(filterNode);
                lastNode = filterNode;
            }
            
            // Connect compressor if enabled
            if (compressorNode && isCompressorEnabled) {
                lastNode.connect(compressorNode);
                lastNode = compressorNode;
            }
            
            // ALWAYS include limiter for safety
            if (limiterNode) {
                lastNode.connect(limiterNode);
                lastNode = limiterNode;
            }
            
            // Connect reverb if available
            if (reverbNode && wetGainNode && dryGainNode) {
                // Split signal for wet/dry mix
                lastNode.connect(dryGainNode);
                lastNode.connect(reverbNode);
                reverbNode.connect(wetGainNode);
                
                // Both wet and dry paths go to destination
                dryGainNode.connect(audioContext.destination);
                wetGainNode.connect(audioContext.destination);
            } else {
                // Direct to destination if no reverb
                lastNode.connect(audioContext.destination);
            }
            
            console.log("Audio chain established successfully");
            return true;
        } catch (error) {
            console.error("Error setting up audio chain:", error);
            return false;
        }
    }
    
    // Setup reverb
    function setupReverb() {
        try {
            // Create a convolver node for reverb
            reverbNode = audioContext.createConvolver();
            
            // Create wet/dry gain nodes for mixing
            wetGainNode = audioContext.createGain();
            dryGainNode = audioContext.createGain();
            
            // Set initial reverb level
            const reverbLevel = parseFloat(document.getElementById('reverb').value);
            wetGainNode.gain.setValueAtTime(reverbLevel, audioContext.currentTime);
            dryGainNode.gain.setValueAtTime(1 - reverbLevel, audioContext.currentTime);
            
            // Create impulse response buffer
            createReverbImpulse(2); // 2 second reverb
            
            // The actual connections will be made in setupAudioChain()
            
            console.log('Cabin atmosphere reverb setup successful');
            return true;
        } catch (error) {
            console.error('Reverb Setup Error:', error);
            showStatus('Cabin atmosphere setup error: ' + error.message);
            return false;
        }
    }
    
    // Create impulse response for reverb
    function createReverbImpulse(duration) {
        try {
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);
            
            // Create a simple exponential decay
            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                // Exponential decay
                const amplitude = Math.random() * Math.exp(-t * 4);
                left[i] = amplitude * (Math.random() * 2 - 1);
                right[i] = amplitude * (Math.random() * 2 - 1);
            }
            
            reverbNode.buffer = impulse;
            convolverBuffer = impulse;
            
            console.log('Created cabin atmosphere impulse response');
            return true;
        } catch (error) {
            console.error('Error creating reverb impulse:', error);
            return false;
        }
    }
    
    // Update reverb settings
    function updateReverb() {
        const value = parseFloat(reverbControl.value);
        document.getElementById('reverbValue').textContent = Math.floor(value * 100) + '%';
        
        if (!wetGainNode || !dryGainNode) return;
        
        wetGainNode.gain.setValueAtTime(value, audioContext.currentTime);
        
        // At 100% reverb, use only wet signal (pure reverb)
        // Between 95-100%, gradually fade out the dry signal
        let dryValue;
        if (value >= 0.95) {
            // Scale 0.95-1.0 to 0.2-0.0 for smooth transition to pure reverb
            dryValue = 0.2 * (1 - ((value - 0.95) / 0.05));
        } else {
            dryValue = 1 - value;
        }
        
        dryGainNode.gain.setValueAtTime(dryValue, audioContext.currentTime);
        
        // Update trail properties based on reverb level
        updateTrailProperties(value);
    }
    
    // Update trail properties based on reverb level
    function updateTrailProperties(reverbValue) {
        // Adjust trail length based on reverb
        // Higher reverb = longer trail
        MAX_TRAIL_POINTS = 100 + Math.floor(reverbValue * 400); // 100 to 500 points
    }
    
    // Setup audio meter
    function setupAudioMeter() {
        if (!audioContext || !masterGainNode) return;
        
        try {
            // Create analyzer node
            audioAnalyser = audioContext.createAnalyser();
            audioAnalyser.fftSize = 1024;
            audioAnalyser.smoothingTimeConstant = 0.85;
            
            // Connect analyzer after the master gain but before the limiter
            // This allows us to monitor levels before they're limited
            masterGainNode.connect(audioAnalyser);
            
            // Start updating the meter
            const bufferLength = audioAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            audioUpdateInterval = setInterval(() => {
                if (audioContext && audioAnalyser && audioMeterElement) {
                    audioAnalyser.getByteTimeDomainData(dataArray);
                    
                    // Calculate RMS value
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        const amplitude = (dataArray[i] - 128) / 128;
                        sum += amplitude * amplitude;
                    }
                    const rms = Math.sqrt(sum / bufferLength);
                    
                    // Convert to dB (avoid -Infinity for silence)
                    const db = rms > 0 ? 20 * Math.log10(rms) : -100;
                    
                    // Map to percentage for meter (from -60dB to 0dB)
                    const percentage = Math.max(0, Math.min(100, (db + 60) * (100 / 60)));
                    
                    // Update meter
                    audioMeterElement.style.width = percentage + '%';
                    
                    // Color meter based on level
                    if (percentage > 90) {
                        audioMeterElement.style.backgroundColor = '#e74c3c'; // Red for high levels
                    } else if (percentage > 70) {
                        audioMeterElement.style.backgroundColor = '#f39c12'; // Orange for medium-high levels
                    } else {
                        audioMeterElement.style.backgroundColor = '#2ecc71'; // Green for safe levels
                    }
                    
                    // Update text label (format to 1 decimal place, show infinity for very low levels)
                    let dbText = db < -60 ? '-‚àû' : db.toFixed(1);
                    audioLevelLabel.textContent = dbText + ' dB';
                }
            }, 100);
            
            console.log('Audio meter initialized');
        } catch (error) {
            console.error('Error setting up audio meter:', error);
        }
    }
    
    // Setup filter
    function setupFilter() {
        try {
            if (!audioContext) return false;
            
            // Create low-pass filter
            filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'lowpass';
            filterNode.Q.value = 1.0; // Resonance (1.0 is neutral)
            
            // Set initial cutoff frequency from control
            const cutoffValue = filterCutoffControl ? parseInt(filterCutoffControl.value) : 20000;
            filterNode.frequency.setValueAtTime(cutoffValue, audioContext.currentTime);
            
            // Setup filter in audio chain
            setupAudioChain();
            
            console.log(`Low-pass filter initialized at ${cutoffValue}Hz`);
            
            return true;
        } catch (error) {
            console.error('Error setting up filter:', error);
            showStatus('Air Filter setup error: ' + error.message);
            return false;
        }
    }
    
    // Setup compressor
    function setupCompressor() {
        try {
            if (!audioContext) return false;
            
            // Create compressor node
            compressorNode = audioContext.createDynamicsCompressor();
            
            // Set initial parameters from controls
            const threshold = parseInt(compThresholdControl.value);
            const ratio = parseFloat(compRatioControl.value);
            const attack = parseFloat(compAttackControl.value);
            const release = parseFloat(compReleaseControl.value);
            
            compressorNode.threshold.setValueAtTime(threshold, audioContext.currentTime);
            compressorNode.ratio.setValueAtTime(ratio, audioContext.currentTime);
            compressorNode.attack.setValueAtTime(attack, audioContext.currentTime);
            compressorNode.release.setValueAtTime(release, audioContext.currentTime);
            compressorNode.knee.setValueAtTime(1, audioContext.currentTime); // Soft knee
            
            // Setup compressor in audio chain
            setupAudioChain();
            
            console.log(`Compressor initialized with threshold: ${threshold}dB, ratio: ${ratio}:1, attack: ${attack}s, release: ${release}s`);
            
            return true;
        } catch (error) {
            console.error('Error setting up compressor:', error);
            showStatus('Cabin Pressure System error: ' + error.message);
            return false;
        }
    }

    // Setup engine hum
    function setupEngineHum() {
        try {
            if (!audioContext) return false;

            // Create oscillator for engine drone
            engineOscillator = audioContext.createOscillator();
            engineOscillator.type = 'sawtooth';
            engineOscillator.frequency.setValueAtTime(55, audioContext.currentTime); // Low A note

            // Create gain node for engine volume
            engineGain = audioContext.createGain();
            engineGain.gain.setValueAtTime(0.15, audioContext.currentTime);

            // Create lowpass filter to make it more drone-like
            const engineFilter = audioContext.createBiquadFilter();
            engineFilter.type = 'lowpass';
            engineFilter.frequency.setValueAtTime(200, audioContext.currentTime);
            engineFilter.Q.setValueAtTime(1, audioContext.currentTime);

            // Connect: oscillator -> filter -> gain -> master
            engineOscillator.connect(engineFilter);
            engineFilter.connect(engineGain);
            engineGain.connect(masterGainNode);

            // Start the oscillator
            engineOscillator.start();

            console.log('Engine hum initialized');
            return true;
        } catch (error) {
            console.error('Error setting up engine hum:', error);
            return false;
        }
    }

    // Setup wind noise
    function setupWindNoise() {
        try {
            if (!audioContext) return false;

            // Create buffer for white noise
            const bufferSize = audioContext.sampleRate * 2;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            // Create buffer source
            windNoiseNode = audioContext.createBufferSource();
            windNoiseNode.buffer = noiseBuffer;
            windNoiseNode.loop = true;

            // Create bandpass filter for wind character
            windNoiseFilter = audioContext.createBiquadFilter();
            windNoiseFilter.type = 'bandpass';
            windNoiseFilter.frequency.setValueAtTime(800, audioContext.currentTime);
            windNoiseFilter.Q.setValueAtTime(0.5, audioContext.currentTime);

            // Create gain node for wind volume
            windNoiseGain = audioContext.createGain();
            windNoiseGain.gain.setValueAtTime(0, audioContext.currentTime); // Start at 0, increase with velocity

            // Connect: noise -> filter -> gain -> master
            windNoiseNode.connect(windNoiseFilter);
            windNoiseFilter.connect(windNoiseGain);
            windNoiseGain.connect(masterGainNode);

            // Start the noise
            windNoiseNode.start();

            console.log('Wind noise initialized');
            return true;
        } catch (error) {
            console.error('Error setting up wind noise:', error);
            return false;
        }
    }

    // Setup rain ambience (inspired by pink noise + reverb)
    function setupRainAmbience() {
        try {
            if (!audioContext) return false;

            // Create buffer for pink-ish noise (filtered white noise)
            const bufferSize = audioContext.sampleRate * 2;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            // Generate white noise
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            // Create buffer source
            rainNoiseNode = audioContext.createBufferSource();
            rainNoiseNode.buffer = noiseBuffer;
            rainNoiseNode.loop = true;

            // HPF at 400Hz (remove deep rumble)
            const rainHPF = audioContext.createBiquadFilter();
            rainHPF.type = 'highpass';
            rainHPF.frequency.setValueAtTime(400, audioContext.currentTime);
            rainHPF.Q.setValueAtTime(0.5, audioContext.currentTime);

            // LPF for rain character (variable drops)
            rainFilter = audioContext.createBiquadFilter();
            rainFilter.type = 'lowpass';
            rainFilter.frequency.setValueAtTime(7000, audioContext.currentTime);
            rainFilter.Q.setValueAtTime(1.0, audioContext.currentTime);

            // Create reverb for spaciousness
            rainReverb = audioContext.createConvolver();
            createSimpleReverb(rainReverb, 2.5, 0.5); // 2.5s reverb, 0.5 decay

            // Gain nodes
            rainReverbGain = audioContext.createGain();
            rainReverbGain.gain.setValueAtTime(0.7, audioContext.currentTime);

            rainGain = audioContext.createGain();
            rainGain.gain.setValueAtTime(0, audioContext.currentTime); // Start at 0

            // Connect: noise -> HPF -> LPF -> reverb -> gain -> master
            rainNoiseNode.connect(rainHPF);
            rainHPF.connect(rainFilter);
            rainFilter.connect(rainReverb);
            rainReverb.connect(rainReverbGain);
            rainReverbGain.connect(rainGain);
            rainGain.connect(masterGainNode);

            // Start the noise
            rainNoiseNode.start();

            // Slowly fade in rain over 10 seconds
            rainGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 10);

            console.log('Rain ambience initialized');
            return true;
        } catch (error) {
            console.error('Error setting up rain:', error);
            return false;
        }
    }

    // Setup distant thunder
    function setupThunder() {
        try {
            if (!audioContext) return false;

            // Create buffer for pink-ish noise
            const bufferSize = audioContext.sampleRate * 2;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            // Generate white noise
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            // Create buffer source
            thunderNoiseNode = audioContext.createBufferSource();
            thunderNoiseNode.buffer = noiseBuffer;
            thunderNoiseNode.loop = true;

            // HPF at 20Hz (keep the rumble)
            const thunderHPF = audioContext.createBiquadFilter();
            thunderHPF.type = 'highpass';
            thunderHPF.frequency.setValueAtTime(20, audioContext.currentTime);
            thunderHPF.Q.setValueAtTime(0.7, audioContext.currentTime);

            // LPF with modulation for thunder character
            thunderFilter = audioContext.createBiquadFilter();
            thunderFilter.type = 'lowpass';
            thunderFilter.frequency.setValueAtTime(1500, audioContext.currentTime);
            thunderFilter.Q.setValueAtTime(3.0, audioContext.currentTime);

            // LFO for filter modulation
            thunderLFO = audioContext.createOscillator();
            thunderLFO.type = 'sine';
            thunderLFO.frequency.setValueAtTime(1, audioContext.currentTime); // 1Hz modulation

            const thunderLFOGain = audioContext.createGain();
            thunderLFOGain.gain.setValueAtTime(1000, audioContext.currentTime); // Modulation depth

            thunderLFO.connect(thunderLFOGain);
            thunderLFOGain.connect(thunderFilter.frequency);

            // Create reverb for spacious thunder
            thunderReverb = audioContext.createConvolver();
            createSimpleReverb(thunderReverb, 4.0, 0.7); // 4s reverb, 0.7 decay

            // Gain nodes
            thunderReverbGain = audioContext.createGain();
            thunderReverbGain.gain.setValueAtTime(0.8, audioContext.currentTime);

            thunderGain = audioContext.createGain();
            thunderGain.gain.setValueAtTime(0, audioContext.currentTime); // Start at 0

            // Connect chain
            thunderNoiseNode.connect(thunderHPF);
            thunderHPF.connect(thunderFilter);
            thunderFilter.connect(thunderReverb);
            thunderReverb.connect(thunderReverbGain);
            thunderReverbGain.connect(thunderGain);
            thunderGain.connect(masterGainNode);

            // Start nodes
            thunderNoiseNode.start();
            thunderLFO.start();

            // Trigger thunder rumbles periodically (every 15-45 seconds)
            startThunderRumbles();

            console.log('Thunder initialized');
            return true;
        } catch (error) {
            console.error('Error setting up thunder:', error);
            return false;
        }
    }

    // Create a simple reverb impulse response
    function createSimpleReverb(convolverNode, duration, decay) {
        const sampleRate = audioContext.sampleRate;
        const length = sampleRate * duration;
        const impulse = audioContext.createBuffer(2, length, sampleRate);
        const left = impulse.getChannelData(0);
        const right = impulse.getChannelData(1);

        for (let i = 0; i < length; i++) {
            const n = length - i;
            left[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
        }

        convolverNode.buffer = impulse;
    }

    // Trigger thunder rumbles at random intervals
    function startThunderRumbles() {
        if (thunderInterval) {
            clearInterval(thunderInterval);
        }

        const triggerThunder = () => {
            if (!isThunderEnabled || !isFlying || !thunderGain) return;

            // Random thunder intensity
            const intensity = 0.05 + Math.random() * 0.15; // 0.05 to 0.2
            const duration = 3 + Math.random() * 4; // 3-7 seconds

            // Fade in
            thunderGain.gain.cancelScheduledValues(audioContext.currentTime);
            thunderGain.gain.setValueAtTime(thunderGain.gain.value, audioContext.currentTime);
            thunderGain.gain.linearRampToValueAtTime(intensity, audioContext.currentTime + 1);

            // Fade out
            thunderGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

            console.log(`Thunder rumble: intensity ${intensity.toFixed(2)}, duration ${duration.toFixed(1)}s`);

            // Schedule next thunder (15-45 seconds later)
            const nextDelay = 15000 + Math.random() * 30000;
            thunderInterval = setTimeout(triggerThunder, nextDelay);
        };

        // Trigger first thunder after 5-15 seconds
        const initialDelay = 5000 + Math.random() * 10000;
        thunderInterval = setTimeout(triggerThunder, initialDelay);
    }

    // Stop thunder rumbles
    function stopThunderRumbles() {
        if (thunderInterval) {
            clearTimeout(thunderInterval);
            thunderInterval = null;
        }

        if (thunderGain && audioContext) {
            thunderGain.gain.cancelScheduledValues(audioContext.currentTime);
            thunderGain.gain.setValueAtTime(0, audioContext.currentTime);
        }
    }

    // Setup cabin pressure filter (altitude-based)
    function setupCabinPressureFilter() {
        try {
            if (!audioContext) return false;

            // Create lowpass filter that will be controlled by altitude
            cabinPressureFilter = audioContext.createBiquadFilter();
            cabinPressureFilter.type = 'lowpass';
            cabinPressureFilter.frequency.setValueAtTime(22050, audioContext.currentTime); // Start fully open
            cabinPressureFilter.Q.setValueAtTime(0.7, audioContext.currentTime);

            // This filter will be inserted in the audio chain
            setupAudioChain();

            console.log('Cabin pressure filter initialized');
            return true;
        } catch (error) {
            console.error('Error setting up cabin pressure filter:', error);
            return false;
        }
    }

    // Setup LFO
    function setupLFO() {
        try {
            if (!audioContext) return false;
            
            // Ensure we have a filter before setting up LFO
            if (!filterNode || !isFilterEnabled) {
                setupFilter();
            }
            
            // Clean up existing LFO if it exists
            if (lfoOscillator) {
                try {
                    lfoOscillator.stop();
                    lfoOscillator.disconnect();
                } catch (e) {
                    console.warn("Error cleaning up existing LFO:", e);
                }
            }
            
            // Create LFO oscillator
            lfoOscillator = audioContext.createOscillator();
            lfoOscillator.type = 'sine';
            
            // Create gain node to control LFO amount
            lfoGain = audioContext.createGain();
            
            // Calculate frequency based on current BPM
            const bpm = parseFloat(tempoControl.value) || 90;
            const lfoRateIndex = parseInt(lfoRateControl.value);
            const divisionInfo = lfoDivisions[lfoRateIndex] || lfoDivisions[2]; // Default to 1/4 note
            const frequency = (bpm / 60) * divisionInfo.value;
            
            lfoOscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            // Get the current filter cutoff
            const cutoffValue = parseInt(filterCutoffControl.value);
            
            // Connect LFO through gain to filter frequency
            lfoOscillator.connect(lfoGain);
            lfoGain.connect(filterNode.frequency);
            
            // Set LFO amount - crucial fix here
            const lfoAmountValue = parseInt(lfoAmountControl.value);
            
            // Scale amount to get a reasonable modulation depth
            // This is the key fix - we calculate the LFO modulation amount
            // relative to the current cutoff frequency
            const modDepth = (lfoAmountValue / 100) * (cutoffValue * 0.8);
            lfoGain.gain.setValueAtTime(modDepth, audioContext.currentTime);
            
            // Start the oscillator
            lfoOscillator.start();
            
            console.log(`LFO initialized at ${frequency}Hz with amount ${lfoAmountValue}% (modDepth: ${modDepth}Hz)`);
            
            // Update LED
            lfoLed.classList.add('active');
            
            return true;
        } catch (error) {
            console.error('Error setting up LFO:', error);
            showStatus('Turbulence setup error: ' + error.message);
            return false;
        }
    }
    
    // Update slider controls
    function updateVolume() {
        const volumeValue = parseFloat(volumeControl.value);
        document.getElementById('volumeValue').textContent = volumeValue.toFixed(2);
        
        // Adjust master gain
        if (masterGainNode) {
            masterGainNode.gain.setValueAtTime(volumeValue, audioContext.currentTime);
        }
    }
    
    function updateDecay() {
        const decayValue = parseFloat(decayControl.value);
        document.getElementById('decayValue').textContent = decayValue.toFixed(1) + 's';
        
        // Update max trail points based on decay
        MAX_TRAIL_POINTS = 100 + Math.floor(decayValue * 40);
    }
    
    function updateTempo() {
        const tempoValue = parseInt(tempoControl.value);
        document.getElementById('tempoValue').textContent = tempoValue;
        document.getElementById('tempoBPM').textContent = tempoValue + ' BPM';
        
        // Update tempo needle in gauge
        const tempoDegrees = ((tempoValue - 40) / 160) * 360; // Map 40-200 to 0-360
        tempoNeedle.style.transform = `translateX(-50%) rotate(${tempoDegrees}deg)`;
        
        // Update LFO with tempo
        updateLfoFrequencyWithTempo();
    }
    
    function updateAltitude() {
        const altitudeValue = parseFloat(altitudeControl.value);
        let altitudeText = "Cruising";

        if (altitudeValue < 0.8) altitudeText = "Low Altitude";
        else if (altitudeValue > 1.2) altitudeText = "High Altitude";

        document.getElementById('altitudeValue').textContent = altitudeText;

        // Track altitude in flight log
        trackAltitude(altitudeValue);
        
        // Update altitude needle in gauge
        const altDegrees = ((altitudeValue - 0.5) / 1.5) * 360; // Map 0.5-2.0 to 0-360
        altitudeNeedle.style.transform = `translateX(-50%) rotate(${altDegrees}deg)`;
        
        // Update altitude display
        const altitudeFeet = Math.floor(altitudeValue * 25000);
        document.getElementById('flightAltitude').textContent = altitudeFeet.toLocaleString() + ' ft';
    }
    
    function updatePersistence() {
        // Get new persistence value
        elementPersistence = parseFloat(persistenceControl.value);
        document.getElementById('persistenceValue').textContent = Math.floor(elementPersistence * 100) + '%';
        
        // Update permanent flag for all elements based on persistence
        mountains.forEach(mountain => {
            mountain.permanentElement = elementPersistence >= 0.7;
        });
        
        clouds.forEach(cloud => {
            cloud.permanentElement = elementPersistence >= 0.7;
        });
        
        cities.forEach(city => {
            city.permanentElement = elementPersistence >= 0.5;
        });
    }
    
    function updateTrailIntensity() {
        // Get new intensity value
        trailIntensity = parseFloat(trailIntensityControl.value);
        document.getElementById('trailIntensityValue').textContent = trailIntensity.toFixed(1);
        
        // Redraw trail with new intensity if permanent trail mode is on
        if (trailPermaMode && smoothedTrail.length > 0) {
            drawPermanentTrail();
        }
    }
    
    function updateBassLevel() {
        const bassLevel = parseFloat(bassLevelControl.value);
        document.getElementById('bassLevelValue').textContent = Math.floor(bassLevel * 100) + '%';
        
        // Update bass EQ if it exists
        if (bassEQNode && audioContext) {
            // Adjust gain (scaled to prevent excessive bass)
            const scaledGain = bassLevel * 6 - 3; // Range from -3dB to +3dB
            bassEQNode.gain.setTargetAtTime(scaledGain, audioContext.currentTime, 0.1);
            console.log(`Updated bass level: ${scaledGain}dB`);
        }
    }
    
    // Update filter cutoff
    function updateFilterCutoff() {
        const cutoffValue = parseInt(filterCutoffControl.value);
        document.getElementById('filterCutoffValue').textContent = cutoffValue + ' Hz';
        
        // Update filter if it exists and is enabled
        if (filterNode && isFilterEnabled) {
            // Set new cutoff value
            filterNode.frequency.setTargetAtTime(
                cutoffValue, 
                audioContext.currentTime, 
                0.1
            );
            
            // If LFO is enabled, we need to update the LFO amount 
            // based on the new cutoff frequency
            if (isLfoEnabled && lfoGain) {
                // Get the current LFO amount percentage
                const lfoAmountValue = parseInt(lfoAmountControl.value);
                
                // Recalculate modulation depth based on new cutoff
                const modDepth = (lfoAmountValue / 100) * (cutoffValue * 0.8);
                
                // Update LFO gain
                lfoGain.gain.setTargetAtTime(
                    modDepth,
                    audioContext.currentTime,
                    0.1
                );
                
                console.log(`Updated filter cutoff: ${cutoffValue}Hz with LFO modDepth: ${modDepth}Hz`);
            } else {
                console.log(`Updated filter cutoff: ${cutoffValue}Hz`);
            }
        }
    }
    
    // Update LFO rate
    function updateLfoRate() {
        const lfoRateIndex = parseInt(lfoRateControl.value);
        const divisionInfo = lfoDivisions[lfoRateIndex] || lfoDivisions[2]; // Default to 1/4 note
        document.getElementById('lfoRateValue').textContent = divisionInfo.name;
        
        currentLfoRate = lfoRateIndex;
        
        // Update LFO if it exists and is enabled
        if (lfoOscillator && isLfoEnabled) {
            // Calculate frequency based on current BPM
            const bpm = parseFloat(tempoControl.value) || 90;
            const frequency = (bpm / 60) * divisionInfo.value;
            
            lfoOscillator.frequency.setTargetAtTime(
                frequency,
                audioContext.currentTime,
                0.1
            );
            
            console.log(`Updated LFO rate: ${frequency}Hz (${divisionInfo.name} at ${bpm} BPM)`);
        }
    }
    
    // Update LFO amount
    function updateLfoAmount() {
        const lfoAmountValue = parseInt(lfoAmountControl.value);
        document.getElementById('lfoAmountValue').textContent = lfoAmountValue + '%';
        
        currentLfoAmount = lfoAmountValue;
        
        // Update LFO gain if it exists and is enabled
        if (lfoGain && isLfoEnabled && filterNode) {
            // Get current filter cutoff as reference point
            const cutoffValue = parseInt(filterCutoffControl.value);
            
            // Scale amount to get a reasonable modulation depth
            // relative to the current cutoff frequency
            const modDepth = (lfoAmountValue / 100) * (cutoffValue * 0.8);
            
            // Set LFO gain to control modulation depth
            lfoGain.gain.setTargetAtTime(
                modDepth,
                audioContext.currentTime,
                0.1
            );
            
            console.log(`Updated LFO amount: ${lfoAmountValue}% (modDepth: ${modDepth}Hz)`);
        }
    }
    
    // Update compressor threshold
    function updateCompressorThreshold() {
        const thresholdValue = parseInt(compThresholdControl.value);
        document.getElementById('compThresholdValue').textContent = thresholdValue + ' dB';
        
        // Update compressor if it exists and is enabled
        if (compressorNode && isCompressorEnabled) {
            compressorNode.threshold.setTargetAtTime(
                thresholdValue, 
                audioContext.currentTime, 
                0.01
            );
            console.log(`Updated compressor threshold: ${thresholdValue}dB`);
        }
    }
    
    // Update compressor ratio
    function updateCompressorRatio() {
        const ratioValue = parseFloat(compRatioControl.value);
        document.getElementById('compRatioValue').textContent = ratioValue.toFixed(1) + ':1';
        
        // Update compressor if it exists and is enabled
        if (compressorNode && isCompressorEnabled) {
            compressorNode.ratio.setTargetAtTime(
                ratioValue, 
                audioContext.currentTime, 
                0.01
            );
            console.log(`Updated compressor ratio: ${ratioValue}:1`);
        }
    }
    
    // Update compressor attack
    function updateCompressorAttack() {
        const attackValue = parseFloat(compAttackControl.value);
        document.getElementById('compAttackValue').textContent = attackValue.toFixed(2) + 's';
        
        // Update compressor if it exists and is enabled
        if (compressorNode && isCompressorEnabled) {
            compressorNode.attack.setTargetAtTime(
                attackValue, 
                audioContext.currentTime, 
                0.01
            );
            console.log(`Updated compressor attack: ${attackValue}s`);
        }
    }
    
    // Update compressor release
    function updateCompressorRelease() {
        const releaseValue = parseFloat(compReleaseControl.value);
        document.getElementById('compReleaseValue').textContent = releaseValue.toFixed(2) + 's';
        
        // Update compressor if it exists and is enabled
        if (compressorNode && isCompressorEnabled) {
            compressorNode.release.setTargetAtTime(
                releaseValue, 
                audioContext.currentTime, 
                0.01
            );
            console.log(`Updated compressor release: ${releaseValue}s`);
        }
    }
    
    // Update LFO frequency when tempo changes
    function updateLfoFrequencyWithTempo() {
        if (!lfoOscillator || !isLfoEnabled) return;
        
        const bpm = parseFloat(tempoControl.value) || 90;
        const lfoRateIndex = parseInt(lfoRateControl.value);
        const divisionInfo = lfoDivisions[lfoRateIndex] || lfoDivisions[2]; // Default to 1/4 note
        const frequency = (bpm / 60) * divisionInfo.value;
        
        lfoOscillator.frequency.setTargetAtTime(
            frequency,
            audioContext.currentTime,
            0.1
        );
        
        console.log(`LFO frequency updated to ${frequency}Hz (${divisionInfo.name} at ${bpm} BPM)`);
    }
    
    // Toggle filter
    function toggleFilter() {
        isFilterEnabled = filterToggle.checked;
        
        // Update visual filter indicator
        if (filterIndicator) {
            filterIndicator.classList.toggle('active', isFilterEnabled);
        }
        
        // Update LED indicator
        filterLed.classList.toggle('active', isFilterEnabled);
        filterLed.classList.toggle('filter', isFilterEnabled);
        
        if (isFilterEnabled) {
            // Enable filter if it exists
            if (filterNode && audioContext) {
                // Update filter cutoff from current control value
                const cutoffValue = parseInt(filterCutoffControl.value);
                filterNode.frequency.setValueAtTime(cutoffValue, audioContext.currentTime);
                
                // Make sure the filter is in the audio chain
                setupAudioChain();
                
                showStatus('Air Filter enabled');
            } else {
                // Create filter if it doesn't exist
                setupFilter();
            }
        } else {
            // Bypass filter by setting to maximum frequency
            if (filterNode && audioContext) {
                filterNode.frequency.setValueAtTime(20000, audioContext.currentTime);
                
                // Reconnect the audio chain
                setupAudioChain();
                
                showStatus('Air Filter disabled');
            }
            
            // Disable LFO if it's active
            if (isLfoEnabled) {
                lfoToggle.checked = false;
                toggleLFO();
            }
        }
    }
    
    // Toggle LFO
    function toggleLFO() {
        isLfoEnabled = lfoToggle.checked;
        
        // Update LED indicator
        lfoLed.classList.toggle('active', isLfoEnabled);
        
        if (isLfoEnabled) {
            // First ensure filter is enabled
            if (!isFilterEnabled) {
                isFilterEnabled = true;
                filterToggle.checked = true;
                filterLed.classList.add('active');
                filterLed.classList.add('filter');
                filterIndicator.classList.add('active');
                setupFilter();
            }
            
            // Enable LFO if it exists
            if (lfoOscillator && lfoGain && audioContext) {
                // Calculate frequency based on current BPM and LFO rate
                const bpm = parseFloat(tempoControl.value) || 90;
                const lfoRateIndex = parseInt(lfoRateControl.value);
                const divisionInfo = lfoDivisions[lfoRateIndex] || lfoDivisions[2]; // Default to 1/4 note
                const frequency = (bpm / 60) * divisionInfo.value;
                
                lfoOscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                
                // Set LFO amount based on current value
                updateLfoAmount();
                
                showStatus('Turbulence modulation enabled');
            } else {
                // Create LFO if it doesn't exist
                setupLFO();
            }
        } else {
            // Stop LFO if it exists
            if (lfoOscillator && audioContext) {
                try {
                    lfoOscillator.stop();
                    lfoOscillator.disconnect();
                    lfoOscillator = null;
                    
                    // Reset LFO gain
                    if (lfoGain) {
                        lfoGain.gain.setValueAtTime(0, audioContext.currentTime);
                    }
                } catch (error) {
                    console.error('Error stopping LFO:', error);
                }
            }
            
            showStatus('Turbulence modulation disabled');
        }
    }
    
    // Toggle compressor
    function toggleCompressor() {
        isCompressorEnabled = compressorToggle.checked;
        
        // Update LED indicator
        compressorLed.classList.toggle('active', isCompressorEnabled);
        compressorLed.classList.toggle('compressor', isCompressorEnabled);
        
        if (isCompressorEnabled) {
            // Enable compressor if it exists
            if (compressorNode && audioContext) {
                // Update compressor parameters from current control values
                updateCompressorThreshold();
                updateCompressorRatio();
                updateCompressorAttack();
                updateCompressorRelease();
                
                // Make sure the compressor is in the audio chain
                setupAudioChain();
                
                showStatus('Cabin Pressure System enabled');
            } else {
                // Create compressor if it doesn't exist
                setupCompressor();
            }
        } else {
            // Bypass compressor by disconnecting it
            if (compressorNode && audioContext) {
                // Reconnect the audio chain without the compressor
                setupAudioChain();
                
                showStatus('Cabin Pressure System disabled');
            }
        }
    }

    // Toggle engine hum
    function toggleEngine() {
        isEngineEnabled = engineToggle.checked;

        // Update LED indicator
        const engineLed = document.getElementById('engineLed');
        engineLed.classList.toggle('led-on', isEngineEnabled);

        if (isEngineEnabled) {
            if (!engineOscillator && audioContext) {
                setupEngineHum();
            } else if (engineGain && audioContext) {
                engineGain.gain.setValueAtTime(0.15, audioContext.currentTime);
            }
            showStatus('Engine hum enabled');
        } else {
            if (engineGain && audioContext) {
                engineGain.gain.setValueAtTime(0, audioContext.currentTime);
                showStatus('Engine hum disabled');
            }
        }
    }

    // Toggle wind noise
    function toggleWind() {
        isWindEnabled = windToggle.checked;

        // Update LED indicator
        const windLed = document.getElementById('windLed');
        windLed.classList.toggle('led-on', isWindEnabled);

        if (isWindEnabled) {
            if (!windNoiseNode && audioContext) {
                setupWindNoise();
            }
            showStatus('Wind noise enabled');
        } else {
            if (windNoiseGain && audioContext) {
                windNoiseGain.gain.setValueAtTime(0, audioContext.currentTime);
                showStatus('Wind noise disabled');
            }
        }
    }

    // Toggle altitude-based filter
    function toggleAltitudeFilter() {
        isCabinPressureEnabled = altitudeFilterToggle.checked;

        // Update LED indicator
        const altitudeFilterLed = document.getElementById('altitudeFilterLed');
        altitudeFilterLed.classList.toggle('led-on', isCabinPressureEnabled);

        if (isCabinPressureEnabled) {
            if (!cabinPressureFilter && audioContext) {
                setupCabinPressureFilter();
            } else if (audioContext) {
                // Rebuild audio chain to include the filter
                setupAudioChain();
            }
            showStatus('Altitude filter enabled - sound changes with height');
        } else {
            if (cabinPressureFilter && audioContext) {
                cabinPressureFilter.frequency.setValueAtTime(22050, audioContext.currentTime);
                // Rebuild audio chain to remove the filter
                setupAudioChain();
                showStatus('Altitude filter disabled');
            }
        }
    }

    // Toggle rain ambience
    function toggleRain() {
        isRainEnabled = rainToggle.checked;

        // Update LED indicator
        const rainLed = document.getElementById('rainLed');
        rainLed.classList.toggle('led-on', isRainEnabled);

        if (isRainEnabled) {
            if (!rainNoiseNode && audioContext) {
                setupRainAmbience();
            }
            showStatus('Rain ambience enabled - soothing rainfall');
        } else {
            if (rainGain && audioContext) {
                rainGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);
                showStatus('Rain ambience disabled');
            }
        }
    }

    // Toggle distant thunder
    function toggleThunder() {
        isThunderEnabled = thunderToggle.checked;

        // Update LED indicator
        const thunderLed = document.getElementById('thunderLed');
        thunderLed.classList.toggle('led-on', isThunderEnabled);

        if (isThunderEnabled) {
            if (!thunderNoiseNode && audioContext) {
                setupThunder();
            } else {
                // Restart thunder rumbles if already initialized
                startThunderRumbles();
            }
            showStatus('Distant thunder enabled - rumbles in the distance');
        } else {
            stopThunderRumbles();
            if (thunderGain && audioContext) {
                thunderGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);
                showStatus('Thunder disabled');
            }
        }
    }

    // Update immersive audio based on flight dynamics
    function updateImmersiveAudio() {
        if (!audioContext || !isFlying || !altitudeControl) return;

        // Get current altitude (0-1) from control
        const altitude = parseFloat(altitudeControl.value);

        // Calculate velocity based on plane direction
        const velocity = Math.sqrt(planeDirection.x * planeDirection.x + planeDirection.y * planeDirection.y);

        // Update engine hum based on velocity
        if (isEngineEnabled && engineOscillator && engineGain) {
            // Engine frequency increases with speed (55Hz to 85Hz)
            const engineFreq = 55 + velocity * 1500;
            engineOscillator.frequency.setValueAtTime(engineFreq, audioContext.currentTime);

            // Engine volume also increases slightly with speed
            const engineVol = 0.12 + velocity * 1.5;
            engineGain.gain.setValueAtTime(Math.min(engineVol, 0.25), audioContext.currentTime);
        }

        // Update wind noise based on velocity
        if (isWindEnabled && windNoiseGain && windNoiseFilter) {
            // Wind volume increases with speed
            const windVol = velocity * 0.8;
            windNoiseGain.gain.setValueAtTime(Math.min(windVol, 0.15), audioContext.currentTime);

            // Wind filter frequency also changes with speed
            const windFreq = 400 + velocity * 2000;
            windNoiseFilter.frequency.setValueAtTime(windFreq, audioContext.currentTime);
        }

        // Update cabin pressure filter based on altitude
        if (isCabinPressureEnabled && cabinPressureFilter) {
            // Higher altitude = lower filter cutoff (thinner air, muffled sound)
            // At altitude 0: full frequency (22050 Hz)
            // At altitude 1: reduced frequency (800 Hz)
            const filterFreq = 22050 - (altitude * 21250);
            cabinPressureFilter.frequency.setValueAtTime(filterFreq, audioContext.currentTime);
        }

        // Store last velocity for future use
        lastVelocity.x = planeDirection.x;
        lastVelocity.y = planeDirection.y;
    }

    // Apply filter preset
    function applyFilterPreset(e) {
        const presetName = e.target.value;
        if (!presetName || !filterPresets[presetName]) return;
        
        const preset = filterPresets[presetName];
        
        // Reset select to placeholder
        e.target.value = '';
        
        // Update UI controls to match preset
        filterCutoffControl.value = preset.cutoff;
        lfoRateControl.value = preset.lfoRate;
        lfoAmountControl.value = preset.lfoAmount;
        
        // Update labels
        document.getElementById('filterCutoffValue').textContent = `${preset.cutoff} Hz`;
        document.getElementById('lfoRateValue').textContent = `${lfoDivisions[preset.lfoRate].name}`;
        document.getElementById('lfoAmountValue').textContent = `${preset.lfoAmount}%`;
        
        // Enable filter if not enabled
        if (!isFilterEnabled) {
            filterToggle.checked = true;
            toggleFilter();
        }
        
        // Enable or disable LFO based on preset
        if (isLfoEnabled !== preset.enableLfo) {
            lfoToggle.checked = preset.enableLfo;
            toggleLFO();
        }
        
        // Apply filter settings
        updateFilterCutoff();
        updateLfoRate();
        updateLfoAmount();
        
        // Show announcement
        showStatus(`Applied ${preset.name} filter preset!`);
    }
    
    // Apply compressor preset
    function applyCompressorPreset(e) {
        const presetName = e.target.value;
        if (!presetName || !compressorPresets[presetName]) return;
        
        const preset = compressorPresets[presetName];
        
        // Reset select to placeholder
        e.target.value = '';
        
        // Update UI controls to match preset
        compThresholdControl.value = preset.threshold;
        compRatioControl.value = preset.ratio;
        compAttackControl.value = preset.attack;
        compReleaseControl.value = preset.release;
        
        // Update labels
        document.getElementById('compThresholdValue').textContent = `${preset.threshold} dB`;
        document.getElementById('compRatioValue').textContent = `${preset.ratio}:1`;
        document.getElementById('compAttackValue').textContent = `${preset.attack}s`;
        document.getElementById('compReleaseValue').textContent = `${preset.release}s`;
        
        // Enable compressor if not enabled
        if (!isCompressorEnabled) {
            compressorToggle.checked = true;
            toggleCompressor();
        }
        
        // Apply compressor settings
        updateCompressorThreshold();
        updateCompressorRatio();
        updateCompressorAttack();
        updateCompressorRelease();
        
        // Show announcement
        showStatus(`Applied ${preset.name} cabin pressure preset!`);
    }
    
    // Clear trail
    function clearTrail() {
        // Clear the permanent trail array
        smoothedTrail = [];
        
        // Clear the trail canvas
        if (trailCtx) trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
        
        // Show status message
        showStatus('Trail cleared!');
    }
    
    // Randomize all parameters
    function randomizeAll() {
        // Randomize audio parameters
        volumeControl.value = (0.05 + Math.random() * 0.2).toFixed(2); // Reduced maximum volume
        updateVolume();
        
        bassLevelControl.value = (0.4 + Math.random() * 0.6).toFixed(2); // Keep some bass but vary it
        updateBassLevel();
        
        decayControl.value = (1 + Math.random() * 9).toFixed(1);
        updateDecay();
        
        reverbControl.value = Math.random().toFixed(2);
        updateReverb();
        
        // Randomize flight parameters
        altitudeControl.value = (0.5 + Math.random() * 1.5).toFixed(2);
        updateAltitude();
        
        tempoControl.value = Math.floor(60 + Math.random() * 100); // More reasonable tempo range
        updateTempo();
        
        persistenceControl.value = Math.random().toFixed(2);
        updatePersistence();
        
        trailIntensityControl.value = (0.1 + Math.random() * 4.9).toFixed(1);
        updateTrailIntensity();
        
        // Randomize filter parameters
        filterCutoffControl.value = Math.floor(1000 + Math.random() * 19000);
        updateFilterCutoff();
        
        lfoRateControl.value = Math.floor(Math.random() * 8);
        updateLfoRate();
        
        lfoAmountControl.value = Math.floor(Math.random() * 100);
        updateLfoAmount();
        
        // Randomize compressor parameters
        compThresholdControl.value = Math.floor(-60 + Math.random() * 60);
        updateCompressorThreshold();
        
        compRatioControl.value = (1 + Math.random() * 19).toFixed(1);
        updateCompressorRatio();
        
        compAttackControl.value = Math.random().toFixed(2);
        updateCompressorAttack();
        
        compReleaseControl.value = Math.random().toFixed(2);
        updateCompressorRelease();
        
        // Randomly enable/disable effects
        const randomFilterEnabled = Math.random() > 0.5;
        filterToggle.checked = randomFilterEnabled;
        toggleFilter();
        
        if (randomFilterEnabled) {
            const randomLfoEnabled = Math.random() > 0.5;
            lfoToggle.checked = randomLfoEnabled;
            if (randomLfoEnabled) toggleLFO();
        }
        
        const randomCompEnabled = Math.random() > 0.5;
        compressorToggle.checked = randomCompEnabled;
        toggleCompressor();
        
        // Randomly select a destination
        const destinations = ['worldTour', 'asia', 'europe', 'africa', 'oceania', 'americas', 'impressionist', 'minimalist'];
        changeDestination(destinations[Math.floor(Math.random() * destinations.length)]);
        
        // Randomly select an artist
        const artists = ['brianeno', 'eriksatie', 'haroldbudd', 'starsofthelid', 'boardsofcanada', 
                         'williambasinski', 'stevereich', 'timhecker', 'ryuichisakamoto', 
                         'aphextwin', 'jonhopkins', 'various'];
        selectArtist(artists[Math.floor(Math.random() * artists.length)]);
        
        // Show announcement
        showStatus('All parameters randomized!');
    }
    
    // Select artist
    function selectArtist(artistId) {
        // Update artist name
        switch(artistId) {
            case 'brianeno':
                currentArtistName = 'Brian Eno';
                break;
            case 'eriksatie':
                currentArtistName = 'Erik Satie';
                break;
            case 'haroldbudd':
                currentArtistName = 'Harold Budd';
                break;
            case 'starsofthelid':
                currentArtistName = 'Stars of the Lid';
                break;
            case 'boardsofcanada':
                currentArtistName = 'Boards of Canada';
                break;
            case 'williambasinski':
                currentArtistName = 'William Basinski';
                break;
            case 'stevereich':
                currentArtistName = 'Steve Reich';
                break;
            case 'timhecker':
                currentArtistName = 'Tim Hecker';
                break;
            case 'ryuichisakamoto':
                currentArtistName = 'Ryuichi Sakamoto';
                break;
            case 'aphextwin':
                currentArtistName = 'Aphex Twin';
                break;
            case 'jonhopkins':
                currentArtistName = 'Jon Hopkins';
                break;
            case 'various':
            default:
                currentArtistName = 'Various Artists';
                artistId = 'various';
        }
        
        // Update UI
        document.getElementById('currentArtist').textContent = `Cabin music: ${currentArtistName}`;
        
        // Update artist info
        updateArtistInfo();
        
        // Update current artist
        currentArtist = artistId;
        
        // Update tempo and other parameters based on artist style
        if (artistStyles[artistId]) {
            // Update tempo if artist has specific tempo
    if (artistStyles[artistId].tempo && tempoControl) {
        tempoControl.value = artistStyles[artistId].tempo;
        updateTempo();
    }
    
    // Update decay if artist has specific decay
    if (artistStyles[artistId].decay && decayControl) {
        decayControl.value = artistStyles[artistId].decay;
        updateDecay();
    }
    
    // Update reverb if artist has specific reverb
    if (artistStyles[artistId].reverb && reverbControl) {
        reverbControl.value = artistStyles[artistId].reverb;
        updateReverb();
    }

    // Track artist change in flight log
    trackArtistChange(currentArtistName);

    // Show status message
    showStatus(`Now playing music inspired by ${currentArtistName}.`);
}

// Change destination
function changeDestination(destId) {
    // Update destination name
    switch(destId) {
        case 'worldTour':
            currentDestinationName = 'World Tour';
            break;
        case 'asia':
            currentDestinationName = 'Asia';
            break;
        case 'europe':
            currentDestinationName = 'Europe';
            break;
        case 'africa':
            currentDestinationName = 'Africa';
            break;
        case 'oceania':
            currentDestinationName = 'Oceania';
            break;
        case 'americas':
            currentDestinationName = 'Americas';
            break;
        case 'impressionist':
            currentDestinationName = 'Impressionist';
            break;
        case 'minimalist':
            currentDestinationName = 'Minimalist';
            break;
        default:
            currentDestinationName = 'World Tour';
            destId = 'worldTour';
    }
    
    // Update UI elements
    document.getElementById('currentDestination').textContent = `Destination: ${currentDestinationName}`;
    
    // Update button styling - remove selected class from all buttons
    destinationButtons.forEach(btn => {
        btn.classList.remove('selected');
    });
    
    // Find and add selected class to current destination button
    destinationButtons.forEach(btn => {
        if (btn.id.toLowerCase() === 'dest' + destId.toLowerCase()) {
            btn.classList.add('selected');
        }
    });
    
    // Update current destination
    currentDestination = destId;
    
    // Update musical scales based on destination
    if (musicalScales[destId]) {
        harmonicNotes = musicalScales[destId].harmonicNotes;
        planeNotes = musicalScales[destId].planeNotes;
        
        // Force sequencers to select new patterns
        if (sequencer1) sequencer1.selectPattern();
        if (sequencer2) sequencer2.selectPattern();
    }
    
    // Show announcement about the destination change
    const announcementElement = document.getElementById('announcement');
    const announcementText = document.getElementById('announcementText');
    if (announcementElement && announcementText) {
        announcementText.textContent = `We're now embarking on a journey to ${currentDestinationName}.`;
        announcementElement.style.display = 'block';
        announcementElement.style.opacity = '1';
        
        // Hide announcement after delay
        setTimeout(() => {
            fadeOutAnnouncement();
        }, 7000);
    }

    // Track destination change in flight log
    trackDestinationChange(currentDestinationName);

    // Show status message
    showStatus(`Flight route changed to ${currentDestinationName}.`);
}

// Emergency eject function
function emergencyEject() {
    try {
        console.log('‚ö†Ô∏è EMERGENCY EJECT activated ‚ö†Ô∏è');
        
        // First stop all audio
        if (audioContext) {
            // Clear all active oscillators
            if (activeOscillators && activeOscillators.length > 0) {
                activeOscillators.forEach(osc => {
                    try {
                        osc.stop();
                        osc.disconnect();
                    } catch (e) {
                        console.warn('Error stopping oscillator:', e);
                    }
                });
                activeOscillators = [];
            }
            
            // Stop LFO if it's active
            if (lfoOscillator) {
                try {
                    lfoOscillator.stop();
                    lfoOscillator.disconnect();
                    lfoOscillator = null;
                } catch (e) {
                    console.warn('Error stopping LFO:', e);
                }
            }
            
            // Disconnect and recreate master gain to cut all audio
            if (masterGainNode) {
                try {
                    masterGainNode.disconnect();
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    setupAudioChain(); // Reconnect with zero gain
                } catch (e) {
                    console.warn('Error recreating master gain:', e);
                }
            }
            
            // Suspend audio context
            audioContext.suspend().then(() => {
                console.log('AudioContext suspended by emergency eject');
            }).catch(e => {
                console.warn('Error suspending AudioContext:', e);
            });
        }
        
        // Stop flight
        isFlying = false;
        
        // Reset UI
        takeoffButton.disabled = false;
        landButton.disabled = true;
        
        // Clear sequencers
        if (sequencer1) {
            sequencer1.stop();
            sequencer1 = null;
        }
        
        if (sequencer2) {
            sequencer2.stop();
            sequencer2 = null;
        }
        
        // Stop timers
        if (flightTimerInterval) clearInterval(flightTimerInterval);
        if (audioUpdateInterval) clearInterval(audioUpdateInterval);
        
        showStatus('<strong>EMERGENCY EJECT ACTIVATED</strong><br>All audio systems shut down');
        
        // Show an announcement
        const announcementElement = document.getElementById('announcement');
        const announcementText = document.getElementById('announcementText');
        if (announcementElement && announcementText) {
            announcementText.innerHTML = '<strong>EMERGENCY EJECT ACTIVATED</strong><br>All audio systems have been shut down. Click "Take Off" to restart when ready.';
            announcementElement.style.display = 'block';
            announcementElement.style.opacity = '1';
            
            // Keep the announcement visible until clicked
            if (announcementTimer) clearTimeout(announcementTimer);
        }
    } catch (error) {
        console.error('Error in emergency eject:', error);
    }
}

// Test audio with a simple note
function testAudio() {
    try {
        // Initialize audio if not already done
        if (!audioContext) {
            initializeAudio();
        }
        
        // Resume audio context if suspended
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log('AudioContext resumed in testAudio');
                playTestTone();
            }).catch(err => {
                console.error('Failed to resume AudioContext in testAudio:', err);
                showStatus('Failed to resume cabin audio system. Try clicking the Take Off button.');
            });
        } else {
            playTestTone();
        }
    } catch (error) {
        console.error('Test audio error:', error);
        showStatus('Test audio error: ' + error.message);
    }
}

// Play a test tone
function playTestTone() {
    try {
        if (!audioContext || !masterGainNode) {
            showStatus('Cabin audio system not initialized');
            return;
        }
        
        // Create a simple test tone
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        // Alternate between sine and triangle
        oscillator.type = Math.random() < 0.5 ? 'sine' : 'triangle';
        
        // Use a pleasant frequency
        const testFreq = 440 + Math.random() * 220;
        oscillator.frequency.setValueAtTime(testFreq, audioContext.currentTime);
        
        // Use current volume control value
        const volume = parseFloat(volumeControl.value);
        
        // Create amplitude envelope with nice fade in/out
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.1);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);
        
        // Connect nodes to the master gain (which has all safety nodes in chain)
        oscillator.connect(gainNode);
        gainNode.connect(masterGainNode);
        
        // Start and stop oscillator
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 2);
        
        // Show indication that sound is playing
        const testFreqRounded = Math.round(testFreq);
        showStatus(`Cabin audio check: ${testFreqRounded} Hz`);
        
        // Create visual feedback
        if (flightCanvas && noteCtx) {
            const circle = {
                x: flightCanvas.width / 2,
                y: flightCanvas.height / 2,
                radius: 5,
                maxRadius: 80,
                color: '#2ecc71',
                opacity: 0.8,
                growRate: 1
            };
            
            noteCircles.push(circle);
            
            // Draw the visualization even if not flying
            const drawTestVisual = () => {
                if (circle.radius <= circle.maxRadius) {
                    noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
                    
                    circle.radius += circle.growRate;
                    circle.opacity -= 0.01;
                    
                    noteCtx.beginPath();
                    noteCtx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                    noteCtx.strokeStyle = adjustOpacity('#2ecc71', circle.opacity);
                    noteCtx.lineWidth = 2;
                    noteCtx.stroke();
                    
                    requestAnimationFrame(drawTestVisual);
                } else {
                    // Clear when done
                    noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
                }
            };
            
            drawTestVisual();
        }
    } catch (error) {
        console.error('Play test tone error:', error);
        showStatus('Cabin audio test error: ' + error.message);
    }
}

// Take off function
function takeOff() {
    try {
        // Initialize audio if not already done
        if (!audioContext) {
            initializeAudio();
        }
        
        // Resume audio context if suspended
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log('AudioContext resumed in takeOff');
                continueWithTakeoff();
            }).catch(err => {
                console.error('Failed to resume AudioContext in takeOff:', err);
                // Try anyway
                continueWithTakeoff();
            });
        } else {
            continueWithTakeoff();
        }
    } catch (error) {
        console.error('Takeoff error:', error);
        showStatus('Take off aborted: ' + error.message);
    }
}

// Continue with takeoff after audio context is ready
function continueWithTakeoff() {
    if (!isFlying) {
        isFlying = true;
        
        // Reset flight start time
        flightStartTime = Date.now();
        // Reset announcement time
        lastAnnouncementTime = Date.now();
        // Reset pathStartTime
        pathStartTime = Date.now();
        
        // Disable takeoff button, enable land button
        takeoffButton.disabled = true;
        landButton.disabled = false;
        
        // Start flight visualization
        startFlightVisualization();
        
        // Fade in master volume over 1 second
        if (masterGainNode && audioContext) {
            masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            masterGainNode.gain.linearRampToValueAtTime(
                parseFloat(volumeControl.value),
                audioContext.currentTime + 1
            );
        }

        // Initialize or restart immersive audio features
        if (isEngineEnabled) {
            if (!engineOscillator) {
                setupEngineHum();
            } else if (engineGain && audioContext) {
                // Fade back in if already exists
                engineGain.gain.setValueAtTime(0, audioContext.currentTime);
                engineGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 1);
            }
        }
        if (isWindEnabled) {
            if (!windNoiseNode) {
                setupWindNoise();
            } else if (windNoiseGain && audioContext) {
                // Wind starts at 0 and increases with velocity
                windNoiseGain.gain.setValueAtTime(0, audioContext.currentTime);
            }
        }
        if (isCabinPressureEnabled) {
            if (!cabinPressureFilter) {
                setupCabinPressureFilter();
            } else if (audioContext) {
                // Reset filter to open when taking off
                cabinPressureFilter.frequency.setValueAtTime(22050, audioContext.currentTime);
            }
        }

        // To ensure the plane starts with enough momentum
        planeDirection.x = 0.02;
        planeDirection.y = 0.01;

        // Start flight log session
        startFlightLog();

        // Display initial announcement
        const announcementElement = document.getElementById('announcement');
        const announcementText = document.getElementById('announcementText');
        if (announcementElement && announcementText) {
            announcementText.textContent = `Welcome aboard our flight to ${currentDestinationName}, inspired by ${currentArtistName}. We're taking off into our ambient journey.`;
            announcementElement.style.display = 'block';
            announcementElement.style.opacity = '1';
            
            // Hide announcement after delay
            setTimeout(() => {
                fadeOutAnnouncement();
            }, 7000);
        }
        
        // Show takeoff message
        showStatus('Taking off into ambient soundscape...');
        
        // Start updating flight info
        startFlightTimer();
    }
}

// Land function - show destination selector
function land() {
    if (isFlying) {
        showLandingSelector();
    }
}

// Show landing destination selector
function showLandingSelector() {
    const landingOverlay = document.getElementById('landingOverlay');
    if (landingOverlay) {
        landingOverlay.classList.remove('hidden');
        showStatus('Choose your destination...');
    }
}

// Hide landing selector
function hideLandingSelector() {
    const landingOverlay = document.getElementById('landingOverlay');
    if (landingOverlay) {
        landingOverlay.classList.add('hidden');
    }
}

// Complete landing at selected destination
function completeLanding(spaceKey) {
    if (!isFlying) return;

    try {
        isFlying = false;
        isLanded = true;
        currentLandingSpace = spaceKey;

        const space = destinationSpaces[spaceKey];
        showStatus(`Landing at ${space.name}...`);

        // End flight log session
        endFlightLog(space.name);

        // Hide the selector
        hideLandingSelector();

        // Update button states
        takeoffButton.disabled = false;
        landButton.disabled = true;

        // Stop flight visualization
        stopFlightVisualization();

        // Stop flight timer
        stopFlightTimer();

        // Clear cities
        clearActiveCities();

        // Reset plane position to center
        planePosition = { x: 50, y: 50 };
        planeDirection = { x: 0, y: 0 };

        // Position plane in center
        if (plane && flightCanvas) {
            const planeCenterX = (flightCanvas.width / 2) - (plane.offsetWidth / 2);
            const planeCenterY = (flightCanvas.height / 2) - (plane.offsetHeight / 2);
            plane.style.left = `${planeCenterX}px`;
            plane.style.top = `${planeCenterY}px`;
            plane.style.transform = 'rotate(0deg)';
        }

        // Reset flight time
        const flightTimeEl = document.getElementById('flightTime');
        if (flightTimeEl) {
            flightTimeEl.textContent = '00:00:00';
        }

        // Apply landing space atmosphere
        applyLandingAtmosphere(spaceKey);

        // Fade out announcement if visible
        fadeOutAnnouncement();

        setTimeout(() => {
            showStatus(`Welcome to ${space.name}. Press Take Off to depart.`);
        }, 2000);

    } catch (error) {
        console.error('Landing error:', error);
        showStatus('Landing error: ' + error.message);
    }
}

// Apply landing atmosphere
function applyLandingAtmosphere(spaceKey) {
    const space = destinationSpaces[spaceKey];
    if (!space) return;

    // Get atmosphere settings
    const time = timeSettings[currentTime];
    const weather = weatherSettings[currentWeather];
    const season = seasonSettings[currentSeason];

    // Apply space colors to the scene
    if (landscapeCtx && landscapeCanvas) {
        landscapeCtx.clearRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);

        // Fill with space colors
        const gradient = landscapeCtx.createLinearGradient(0, 0, 0, landscapeCanvas.height);
        gradient.addColorStop(0, space.colors.ceiling);
        gradient.addColorStop(0.3, space.colors.walls);
        gradient.addColorStop(0.7, space.colors.walls);
        gradient.addColorStop(1, space.colors.floor);

        landscapeCtx.fillStyle = gradient;
        landscapeCtx.fillRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);

        // Add time-based lighting overlay
        landscapeCtx.fillStyle = time.lightColor;
        landscapeCtx.globalAlpha = 0.1 * time.lightIntensity;
        landscapeCtx.fillRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);
        landscapeCtx.globalAlpha = 1.0;

        // Add text overlay with space info
        landscapeCtx.fillStyle = space.colors.accent;
        landscapeCtx.font = '24px -apple-system, sans-serif';
        landscapeCtx.textAlign = 'center';
        landscapeCtx.fillText(space.name, landscapeCanvas.width / 2, landscapeCanvas.height / 2 - 40);

        landscapeCtx.font = '14px -apple-system, sans-serif';
        landscapeCtx.fillStyle = adjustOpacity(space.colors.accent, 0.7);
        landscapeCtx.fillText(space.description, landscapeCanvas.width / 2, landscapeCanvas.height / 2);

        landscapeCtx.fillText(`${time.name} | ${weather.name} | ${season.name}`,
            landscapeCanvas.width / 2, landscapeCanvas.height / 2 + 30);
    }

    // Apply audio settings
    if (audioContext && masterGainNode) {
        // Calculate combined tempo modifier
        const combinedTempo = space.tempoModifier * time.tempoModifier * weather.soundModifier * season.soundModifier;

        // Apply reverb setting
        if (reverbControl) {
            reverbControl.value = space.reverb;
            updateReverb();
        }

        // Adjust tempo
        if (tempoControl) {
            const currentTempo = parseFloat(tempoControl.value);
            const newTempo = Math.max(0.3, Math.min(2.0, currentTempo * combinedTempo));
            tempoControl.value = newTempo;
            updateTempo();
        }

        // Gently fade in audio with new settings
        masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
        masterGainNode.gain.linearRampToValueAtTime(
            parseFloat(volumeControl.value) * 0.6,
            audioContext.currentTime + 3
        );
    }

    // Clear trails and particles
    planeTrail = [];
    smoothedTrail = [];
    if (trailCtx) {
        trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
    }

    // Initialize landing particles based on season
    initializeLandingParticles(season.particleType, weather.particleCount);

    // Start landed animation loop
    animateLandedState();

    console.log(`Landed at ${space.name} - ${time.name}, ${weather.name}, ${season.name}`);
}

// ============================================
// FLIGHT LOG SYSTEM
// ============================================

// Start a new flight log session
function startFlightLog() {
    flightSessionActive = true;
    const now = new Date();

    flightLog = {
        flightNumber: `MA${String(logCounter).padStart(4, '0')}`,
        departureTime: now,
        arrivalTime: null,
        totalFlightTime: 0,
        events: [],
        destinations: [],
        artists: [],
        effectsUsed: [],
        notesPlayed: 0,
        citiesVisited: new Set(),
        altitudeRange: { min: 1.0, max: 1.0 },
        currentSegmentStart: now,
        currentDestination: currentDestinationName,
        currentArtistName: currentArtistName
    };

    logCounter++;

    // Log takeoff event
    addLogEvent('takeoff', `Departed on flight to ${currentDestinationName}, cabin music by ${currentArtistName}`);

    // Track initial destination and artist
    flightLog.destinations.push({
        name: currentDestinationName,
        startTime: now,
        duration: 0
    });

    flightLog.artists.push({
        name: currentArtistName,
        startTime: now,
        duration: 0
    });
}

// End the flight log session
function endFlightLog(landingLocation) {
    if (!flightSessionActive) return;

    const now = new Date();
    flightLog.arrivalTime = now;
    flightLog.totalFlightTime = Math.floor((now - flightLog.departureTime) / 1000);

    // Update last destination duration
    if (flightLog.destinations.length > 0) {
        const lastDest = flightLog.destinations[flightLog.destinations.length - 1];
        lastDest.duration = Math.floor((now - lastDest.startTime) / 1000);
    }

    // Update last artist duration
    if (flightLog.artists.length > 0) {
        const lastArtist = flightLog.artists[flightLog.artists.length - 1];
        lastArtist.duration = Math.floor((now - lastArtist.startTime) / 1000);
    }

    // Log landing event
    addLogEvent('landing', `Arrived at ${landingLocation || 'destination'}`);

    flightSessionActive = false;
}

// Add an event to the flight log
function addLogEvent(eventType, description, details = {}) {
    const now = new Date();
    const timestamp = flightSessionActive && flightLog.departureTime
        ? Math.floor((now - flightLog.departureTime) / 1000)
        : 0;

    flightLog.events.push({
        type: eventType,
        timestamp: timestamp,
        description: description,
        time: now,
        details: details
    });
}

// Track destination change
function trackDestinationChange(newDestination) {
    if (!flightSessionActive) return;

    const now = new Date();

    // Close out previous destination
    if (flightLog.destinations.length > 0) {
        const lastDest = flightLog.destinations[flightLog.destinations.length - 1];
        lastDest.duration = Math.floor((now - lastDest.startTime) / 1000);
    }

    // Add new destination
    flightLog.destinations.push({
        name: newDestination,
        startTime: now,
        duration: 0
    });

    flightLog.currentDestination = newDestination;
    addLogEvent('destination_change', `Route changed to ${newDestination}`);
}

// Track artist change
function trackArtistChange(newArtist) {
    if (!flightSessionActive) return;

    const now = new Date();

    // Close out previous artist
    if (flightLog.artists.length > 0) {
        const lastArtist = flightLog.artists[flightLog.artists.length - 1];
        lastArtist.duration = Math.floor((now - lastArtist.startTime) / 1000);
    }

    // Add new artist
    flightLog.artists.push({
        name: newArtist,
        startTime: now,
        duration: 0
    });

    flightLog.currentArtistName = newArtist;
    addLogEvent('artist_change', `Cabin music changed to ${newArtist}`);
}

// Track altitude changes
function trackAltitude(altitude) {
    if (!flightSessionActive) return;

    if (altitude < flightLog.altitudeRange.min) {
        flightLog.altitudeRange.min = altitude;
    }
    if (altitude > flightLog.altitudeRange.max) {
        flightLog.altitudeRange.max = altitude;
    }
}

// Track note play
function trackNotePlayed() {
    if (flightSessionActive) {
        flightLog.notesPlayed++;
    }
}

// Format duration in seconds to readable format
function formatDuration(seconds) {
    if (seconds < 60) {
        return `${seconds}s`;
    } else if (seconds < 3600) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}m ${secs}s`;
    } else {
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        return `${hours}h ${mins}m ${secs}s`;
    }
}

// Format timestamp for display
function formatTimestamp(date) {
    if (!date) return 'N/A';
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
}

// Format relative timestamp
function formatRelativeTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `+${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
}

// Generate the flight log HTML
function generateFlightLog() {
    const panel = document.getElementById('flightLogPanel');
    if (!panel) return;

    // Build the log HTML
    let html = `
        <div class="flight-log-header">
            <h2>‚úà FLIGHT LOG: ${flightLog.flightNumber || 'N/A'}</h2>
            <button onclick="hideFlightLog()" class="log-close-btn">‚úï</button>
        </div>

        <div class="log-content">
            <!-- Flight Summary -->
            <div class="log-section">
                <h3>FLIGHT SUMMARY</h3>
                <div class="log-info-grid">
                    <div class="log-info-item">
                        <span class="log-label">Departure Time:</span>
                        <span class="log-value">${formatTimestamp(flightLog.departureTime)}</span>
                    </div>
                    <div class="log-info-item">
                        <span class="log-label">Arrival Time:</span>
                        <span class="log-value">${formatTimestamp(flightLog.arrivalTime)}</span>
                    </div>
                    <div class="log-info-item">
                        <span class="log-label">Total Flight Time:</span>
                        <span class="log-value">${formatDuration(flightLog.totalFlightTime)}</span>
                    </div>
                    <div class="log-info-item">
                        <span class="log-label">Status:</span>
                        <span class="log-value">${flightSessionActive ? 'IN FLIGHT' : 'COMPLETED'}</span>
                    </div>
                </div>
            </div>

            <!-- Statistics -->
            <div class="log-section">
                <h3>FLIGHT STATISTICS</h3>
                <div class="log-stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">NOTES PLAYED</div>
                        <div class="stat-value">${flightLog.notesPlayed}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ROUTES FLOWN</div>
                        <div class="stat-value">${flightLog.destinations.length}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">CABIN ARTISTS</div>
                        <div class="stat-value">${flightLog.artists.length}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ALTITUDE RANGE</div>
                        <div class="stat-value">${flightLog.altitudeRange.min.toFixed(2)} - ${flightLog.altitudeRange.max.toFixed(2)}</div>
                    </div>
                </div>
            </div>

            <!-- Destinations -->
            <div class="log-section">
                <h3>FLIGHT ROUTES</h3>
    `;

    if (flightLog.destinations.length > 0) {
        flightLog.destinations.forEach((dest, index) => {
            html += `
                <div class="timeline-event">
                    <div class="event-marker">${index + 1}</div>
                    <div class="event-content">
                        <div class="event-title">${dest.name}</div>
                        <div class="event-detail">Duration: ${formatDuration(dest.duration)}</div>
                    </div>
                </div>
            `;
        });
    } else {
        html += `<div class="log-empty">No routes recorded</div>`;
    }

    html += `
            </div>

            <!-- Artists / Music -->
            <div class="log-section">
                <h3>CABIN MUSIC PROGRAM</h3>
    `;

    if (flightLog.artists.length > 0) {
        flightLog.artists.forEach((artist, index) => {
            html += `
                <div class="timeline-event">
                    <div class="event-marker">‚ô´</div>
                    <div class="event-content">
                        <div class="event-title">${artist.name}</div>
                        <div class="event-detail">Duration: ${formatDuration(artist.duration)}</div>
                    </div>
                </div>
            `;
        });
    } else {
        html += `<div class="log-empty">No music program recorded</div>`;
    }

    html += `
            </div>

            <!-- Events Timeline -->
            <div class="log-section">
                <h3>FLIGHT EVENTS</h3>
    `;

    if (flightLog.events.length > 0) {
        flightLog.events.forEach((event, index) => {
            const eventIcon = event.type === 'takeoff' ? 'üõ´' :
                            event.type === 'landing' ? 'üõ¨' :
                            event.type === 'destination_change' ? 'üó∫' :
                            event.type === 'artist_change' ? '‚ô´' : '‚Ä¢';

            html += `
                <div class="timeline-event">
                    <div class="event-time">${formatRelativeTime(event.timestamp)}</div>
                    <div class="event-marker">${eventIcon}</div>
                    <div class="event-content">
                        <div class="event-description">${event.description}</div>
                    </div>
                </div>
            `;
        });
    } else {
        html += `<div class="log-empty">No events recorded</div>`;
    }

    html += `
            </div>
        </div>

        <div class="log-actions">
            <button onclick="downloadFlightLog()" class="log-action-btn">Download Log</button>
            <button onclick="hideFlightLog()" class="log-action-btn">Close</button>
        </div>
    `;

    panel.innerHTML = html;
}

// Show the flight log overlay
function showFlightLog() {
    generateFlightLog();
    const overlay = document.getElementById('flightLogOverlay');
    if (overlay) {
        overlay.classList.remove('hidden');
    }
}

// Hide the flight log overlay
function hideFlightLog() {
    const overlay = document.getElementById('flightLogOverlay');
    if (overlay) {
        overlay.classList.add('hidden');
    }
}

// Download flight log as text file
function downloadFlightLog() {
    let logText = `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
    logText += `            MUSIC FOR AIRPLANES - FLIGHT LOG\n`;
    logText += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
    logText += `Flight Number: ${flightLog.flightNumber || 'N/A'}\n`;
    logText += `Departure Time: ${formatTimestamp(flightLog.departureTime)}\n`;
    logText += `Arrival Time: ${formatTimestamp(flightLog.arrivalTime)}\n`;
    logText += `Total Flight Time: ${formatDuration(flightLog.totalFlightTime)}\n`;
    logText += `Status: ${flightSessionActive ? 'IN FLIGHT' : 'COMPLETED'}\n\n`;

    logText += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    logText += `FLIGHT STATISTICS\n`;
    logText += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    logText += `Notes Played: ${flightLog.notesPlayed}\n`;
    logText += `Routes Flown: ${flightLog.destinations.length}\n`;
    logText += `Cabin Artists: ${flightLog.artists.length}\n`;
    logText += `Altitude Range: ${flightLog.altitudeRange.min.toFixed(2)} - ${flightLog.altitudeRange.max.toFixed(2)}\n\n`;

    logText += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    logText += `FLIGHT ROUTES\n`;
    logText += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    flightLog.destinations.forEach((dest, index) => {
        logText += `${index + 1}. ${dest.name} - Duration: ${formatDuration(dest.duration)}\n`;
    });
    logText += `\n`;

    logText += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    logText += `CABIN MUSIC PROGRAM\n`;
    logText += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    flightLog.artists.forEach((artist, index) => {
        logText += `${index + 1}. ${artist.name} - Duration: ${formatDuration(artist.duration)}\n`;
    });
    logText += `\n`;

    logText += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    logText += `FLIGHT EVENTS\n`;
    logText += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    flightLog.events.forEach((event) => {
        logText += `[${formatRelativeTime(event.timestamp)}] ${event.description}\n`;
    });
    logText += `\n`;

    logText += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
    logText += `End of Flight Log\n`;
    logText += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;

    // Create and download file
    const blob = new Blob([logText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `FlightLog_${flightLog.flightNumber}_${formatTimestamp(flightLog.departureTime).replace(/:/g, '-')}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showStatus('Flight log downloaded');
}

// Animation loop for landed state
function animateLandedState() {
    if (!isLanded) return;

    // Redraw the landing atmosphere
    drawLandscape();

    // Continue animation
    requestAnimationFrame(animateLandedState);
}

// Initialize landing particles
function initializeLandingParticles(particleType, count) {
    landingParticles = [];
    if (count === 0) return;

    for (let i = 0; i < count; i++) {
        landingParticles.push({
            x: Math.random() * (landscapeCanvas?.width || 800),
            y: Math.random() * (landscapeCanvas?.height || 600),
            vx: (Math.random() - 0.5) * 2,
            vy: Math.random() * 2 + 1,
            size: Math.random() * 3 + 1,
            opacity: Math.random() * 0.5 + 0.3,
            type: particleType
        });
    }
}

// Draw landing particles
function drawLandingParticles() {
    if (!isLanded || !landscapeCtx || !landscapeCanvas || landingParticles.length === 0) return;

    landingParticles.forEach(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Wrap particles
        if (particle.y > landscapeCanvas.height) particle.y = 0;
        if (particle.x < 0) particle.x = landscapeCanvas.width;
        if (particle.x > landscapeCanvas.width) particle.x = 0;

        // Draw based on type
        landscapeCtx.globalAlpha = particle.opacity;
        landscapeCtx.fillStyle = particle.type === 'snow' ? '#ffffff' :
            particle.type === 'rain' ? '#88aacc' :
            particle.type === 'leaf' ? '#d4a574' :
            particle.type === 'blossom' ? '#ffccdd' :
            '#e0e0e0';

        if (particle.type === 'rain') {
            landscapeCtx.fillRect(particle.x, particle.y, 1, particle.size * 3);
        } else {
            landscapeCtx.beginPath();
            landscapeCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            landscapeCtx.fill();
        }
    });
    landscapeCtx.globalAlpha = 1.0;
}

// Start flight visualization
function startFlightVisualization() {
    console.log('Starting flight visualization');

    // Reset landed state
    isLanded = false;
    currentLandingSpace = null;
    landingParticles = [];

    // Reset path variables
    pathStartTime = Date.now();
    currentPath = 0;
    pathProgress = 0;

    // Show plane and ensure it has dimensions
    plane.style.display = 'block';

    // Position plane initially at starting position (visible on screen)
    // Start at 20% from left, middle of screen for better visibility
    if (flightCanvas && flightCanvas.width > 0) {
        planePosition.x = 20; // Start 20% from left edge
        planePosition.y = 50; // Middle vertically
        const left = (planePosition.x / 100) * flightCanvas.width;
        const top = (planePosition.y / 100) * flightCanvas.height;
        plane.style.left = `${left - 70}px`; // 70 is half of plane width (140px)
        plane.style.top = `${top - 35}px`;   // 35 is half of plane height (70px)
        plane.style.transform = 'rotate(0deg)';
        console.log('Plane positioned at:', left, top, 'Canvas dimensions:', flightCanvas.width, flightCanvas.height);
    } else {
        console.warn('flightCanvas not ready, dimensions:', flightCanvas ? flightCanvas.width : 'null');
    }

    // Start plane animation
    requestAnimationFrame(animatePlane);

    // Create the initial landscape
    createInitialLandscape();

    // Draw landscape and stars
    drawLandscape();
    drawStars();

    // Set up sequencers
    sequencer1 = new AmbientSequencer(1);
    sequencer1.start();
    sequencer1.selectPattern();

    sequencer2 = new AmbientSequencer(2);
    setTimeout(() => {
        if (isFlying && sequencer2) {
            sequencer2.start();
            sequencer2.selectPattern();
        }
    }, 5000); // Start second sequencer after 5 seconds
}

// Stop flight visualization
function stopFlightVisualization() {
    console.log('Stopping flight visualization');
    
    // Stop any active oscillators
    if (activeOscillators && activeOscillators.length > 0) {
        activeOscillators.forEach(osc => {
            try {
                osc.stop();
            } catch (e) {
                console.warn('Error stopping oscillator:', e);
            }
        });
        activeOscillators = [];
    }
    
    // Stop any active sequencers
    if (sequencer1) {
        sequencer1.stop();
        sequencer1 = null;
    }
    
    if (sequencer2) {
        sequencer2.stop();
        sequencer2 = null;
    }
    
    // Stop LFO if it's active
    if (isLfoEnabled && lfoOscillator) {
        try {
            lfoOscillator.stop();
            lfoOscillator.disconnect();
            lfoOscillator = null;

            // Reset button state
            isLfoEnabled = false;
            lfoToggle.checked = false;
            lfoLed.classList.remove('active');
        } catch (error) {
            console.error('Error stopping LFO:', error);
        }
    }

    // Fade out immersive audio effects when landing
    if (audioContext) {
        if (engineGain) {
            engineGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
        }
        if (windNoiseGain) {
            windNoiseGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
        }
    }

    // Clean up immersive audio nodes (but keep them initialized for next takeoff)
    // They'll be restarted in startFlightVisualization if toggles are still on
    }
    
    // Clear visualizations
    if (noteCtx && noteCanvas) {
        noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
    }
    if (flightCtx && flightCanvas) {
        flightCtx.clearRect(0, 0, flightCanvas.width, flightCanvas.height);
    }
    
    // Hide filter indicator if active
    if (filterIndicator) {
        filterIndicator.classList.remove('active');
    }
}

// Flight timer variables
let flightTimerInterval = null;

// Start flight timer
function startFlightTimer() {
    if (flightTimerInterval) clearInterval(flightTimerInterval);
    
    flightTimerInterval = setInterval(() => {
        if (!flightStartTime) {
            flightStartTime = Date.now();
        }
        
        // Calculate elapsed time
        const elapsedMs = Date.now() - flightStartTime;
        const hours = Math.floor(elapsedMs / (1000 * 60 * 60));
        const minutes = Math.floor((elapsedMs % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((elapsedMs % (1000 * 60)) / 1000);
        const timeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update time display
        const flightTimeEl = document.getElementById('flightTime');
        if (flightTimeEl) {
            flightTimeEl.textContent = timeStr;
        }
        
        // Update time needle
        if (timeNeedle) {
            const hourProgress = (elapsedMs / (60 * 60 * 1000)) % 1; // Progress through an hour (0-1)
            const degrees = hourProgress * 360;
            timeNeedle.style.transform = `translateX(-50%) rotate(${degrees}deg)`;
        }
        
        // Update altitude based on control value
        if (altitudeControl) {
            const altitudeValue = parseFloat(altitudeControl.value);
            const altitudeFeet = Math.floor(altitudeValue * 25000); // Scale to reasonable flight altitude
            const flightAltitudeEl = document.getElementById('flightAltitude');
            if (flightAltitudeEl) {
                flightAltitudeEl.textContent = `${altitudeFeet.toLocaleString()} ft`;
            }
        }
    }, 1000);
}

// Stop flight timer
function stopFlightTimer() {
    if (flightTimerInterval) {
        clearInterval(flightTimerInterval);
        flightTimerInterval = null; 
    }
}

// Movie-style flight path animation
function animatePlane() {
    if (!isFlying) return;
    
    if (!pathStartTime) pathStartTime = Date.now();
    
    const path = movieFlightPaths[currentPath];
    const elapsedTime = Date.now() - pathStartTime;
    pathProgress = Math.min(elapsedTime / path.duration, 1);
    
    let targetX, targetY;
    
    if (path.next && pathProgress > 0.5) {
        // Handle curved path with midpoint
        const progressInSecondHalf = (pathProgress - 0.5) * 2;
        targetX = path.end.x + (path.next.x - path.end.x) * progressInSecondHalf;
        targetY = path.end.y + (path.next.y - path.end.y) * progressInSecondHalf;
    } else if (path.next) {
        // First half of curved path
        const progressInFirstHalf = pathProgress * 2;
        targetX = path.start.x + (path.end.x - path.start.x) * progressInFirstHalf;
        targetY = path.start.y + (path.end.y - path.start.y) * progressInFirstHalf;
    } else {
        // Simple linear path
        targetX = path.start.x + (path.end.x - path.start.x) * pathProgress;
        targetY = path.start.y + (path.end.y - path.start.y) * pathProgress;
    }
    
    // Set plane position (as percentage of screen)
    planePosition.x = targetX;
    planePosition.y = targetY;
    
    // Calculate direction for plane rotation
    if (pathProgress < 1) {
        const dx = path.next && pathProgress > 0.5 ? path.next.x - path.end.x : path.end.x - path.start.x;
        const dy = path.next && pathProgress > 0.5 ? path.next.y - path.end.y : path.end.y - path.start.y;
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        
        // Position the plane element
        if (plane && flightCanvas) {
            const left = (planePosition.x / 100) * flightCanvas.width;
            const top = (planePosition.y / 100) * flightCanvas.height;
            
            plane.style.left = `${left - (plane.offsetWidth / 2)}px`;
            plane.style.top = `${top - (plane.offsetHeight / 2)}px`;
            plane.style.transform = `rotate(${angle}deg)`;
        }
    }
    
    // Add point to trail
    if (trailCtx && flightCanvas) {
        const trailX = (planePosition.x / 100) * flightCanvas.width;
        const trailY = (planePosition.y / 100) * flightCanvas.height;
        
        planeTrail.push({ 
            x: trailX, 
            y: trailY,
            time: Date.now(),
            // Add frequency data for more reactive trail
            frequency: currentNoteData ? currentNoteData.frequency : 0
        });
        
        // Limit trail points
        if (planeTrail.length > MAX_TRAIL_POINTS) {
            planeTrail.shift();
        }
        
        // Draw the solid trail line instead of fading dots
        drawSolidTrail();
    }
    
    // Move cities in the opposite direction of the plane's movement
    // This creates a parallax effect as if the plane is moving over the terrain
    const virtualMovementX = planeDirection.x;
    const virtualMovementY = planeDirection.y;
    updateCityPositions(virtualMovementX, virtualMovementY, 0.5);
    
    // If we've reached the end of path, switch to next path
    if (pathProgress >= 1) {
        currentPath = (currentPath + 1) % movieFlightPaths.length;
        pathStartTime = Date.now();
        // Clear trail when switching paths
        planeTrail = [];
        trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
    }
    
    // Update immersive audio based on flight dynamics
    updateImmersiveAudio();

    // Update and draw new visual effects
    updateCloudParticles();
    updateContrailParticles();
    drawAtmosphericGlow();

    // Draw note visualization
    drawNoteVisualization();

    // Draw permanent trail (if enabled)
    if (trailPermaMode && smoothedTrail.length > 0) {
        drawPermanentTrail();
    }
    
    // Continue animation
    requestAnimationFrame(animatePlane);
}

// Create initial landscape
function createInitialLandscape() {
    // Clear existing elements
    mountains = [];
    clouds = [];
    flightPaths = [];
    stars = [];
    planeTrail = [];
    smoothedTrail = [];  // Clear smoothed trail
    
    // Make initial trail points that span the screen
    const screenWidth = landscapeCanvas.width;
    const screenHeight = landscapeCanvas.height;
    const centerY = screenHeight / 2;
    
    // Create initial trail that spans beyond screen edges
    for (let i = -100; i <= screenWidth + 100; i += 20) {
        const yVariation = Math.sin(i * 0.01) * 50;
        planeTrail.push({
            x: i,
            y: centerY + yVariation,
            frequency: 0
        });
    }
    
    // Create mountains - bigger
    for (let i = 0; i < 15; i++) {
        const size = 40 + Math.random() * 80; // Bigger initial mountains
        const mountain = {
            x: Math.random() * landscapeCanvas.width,
            y: landscapeCanvas.height - size / 2,
            width: size,
            height: size,
            color: colors.mountains[Math.floor(Math.random() * colors.mountains.length)],
            permanentElement: elementPersistence >= 0.5 // Link to persistence
        };
        mountains.push(mountain);
    }
    
    // Create clouds
    for (let i = 0; i < 20; i++) {
        createCloud();
    }
    
    // Create flight paths
    for (let i = 0; i < 5; i++) {
        const path = {
            x1: Math.random() * landscapeCanvas.width,
            y1: Math.random() * landscapeCanvas.height,
            x2: Math.random() * landscapeCanvas.width,
            y2: Math.random() * landscapeCanvas.height,
            width: 1 + Math.random() * 1.5,
            opacity: 0.08
        };
        flightPaths.push(path);
    }
    
    // Create stars
    for (let i = 0; i < 100; i++) {
        createStar();
    }
    
    // Create cities
    createCities();
    
    // Clear the trail canvas
    trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
}

// Create a cloud with more complex shape
function createCloud() {
    const size = 30 + Math.random() * 70;
    const cloudColor = colors.clouds[Math.floor(Math.random() * colors.clouds.length)];
    
    const cloud = {
        x: Math.random() * landscapeCanvas.width,
        y: Math.random() * (landscapeCanvas.height / 2),
        width: size,
        height: size / 2,
        opacity: 0.05 + Math.random() * 0.1,
        speed: 0.05 + Math.random() * 0.1,
        bubbles: 3 + Math.floor(Math.random() * 3),
        color: cloudColor,
        permanentElement: elementPersistence >= 0.7 // Link to persistence slider
    };
    clouds.push(cloud);
}

// Create a star
function createStar() {
    const size = 0.5 + Math.random() * 1.5;
    const opacity = 0.3 + Math.random() * 0.7;
    const twinkleSpeed = 0.001 + Math.random() * 0.005;
    
    const star = {
        x: Math.random() * starsCanvas.width,
        y: Math.random() * starsCanvas.height,
        size: size,
        opacity: opacity,
        color: colors.stars[Math.floor(Math.random() * colors.stars.length)],
        twinkleSpeed: twinkleSpeed,
        twinkleDir: Math.random() > 0.5 ? 1 : -1,
        permanentElement: true // Stars always stick around
    };
    stars.push(star);
}

// Create landscape element based on frequency
function createLandscapeElement(frequency) {
    const normalizedFreq = (frequency - 100) / 500;
    
    // Create mountain or building
    if (Math.random() < 0.6) {
        // MUCH larger sizes for buildings and mountains - increased by 2x
        const size = 40 + normalizedFreq * 160; // Previously 30 + normalizedFreq * 120
        
        // Determine if it's a mountain or a city building
        const isMountain = Math.random() < 0.7;
        const mountain = {
            x: Math.random() * landscapeCanvas.width,
            y: landscapeCanvas.height - size / 2,
            width: size,
            height: isMountain ? size : size * 2.5, // Taller buildings (previously 2.0)
            color: colors.mountains[Math.floor(Math.random() * colors.mountains.length)],
            opacity: 1,
            fadeRate: 0,
            isBuilding: !isMountain,
            // Link permanence directly to the persistence slider
            permanentElement: elementPersistence >= 0.5
        };
        mountains.push(mountain);
    } else {
        // Create a cloud
        createCloud();
    }
    
    // Occasionally create a star
    if (Math.random() < 0.3) {
        createStar();
    }
}

// Create cities with buffer from edges
function createCities() {
    // Define global city names and positions (relative to canvas)
    const cityData = [
        // North America
        { name: "New York", x: 0.20, y: 0.30, region: "na" },
        { name: "Chicago", x: 0.35, y: 0.25, region: "na" },
        { name: "Los Angeles", x: 0.45, y: 0.40, region: "na" },
        { name: "Miami", x: 0.30, y: 0.60, region: "na" },
        { name: "Mexico City", x: 0.40, y: 0.65, region: "na" },
        { name: "Toronto", x: 0.25, y: 0.22, region: "na" },
        { name: "Vancouver", x: 0.32, y: 0.15, region: "na" },
        { name: "Montreal", x: 0.27, y: 0.20, region: "na" },
        { name: "Denver", x: 0.38, y: 0.30, region: "na" },
        { name: "Seattle", x: 0.28, y: 0.18, region: "na" },
        
        // South America
        { name: "S√£o Paulo", x: 0.50, y: 0.80, region: "sa" },
        { name: "Buenos Aires", x: 0.55, y: 0.85, region: "sa" },
        { name: "Rio de Janeiro", x: 0.45, y: 0.78, region: "sa" },
        { name: "Lima", x: 0.44, y: 0.75, region: "sa" },
        { name: "Bogot√°", x: 0.42, y: 0.72, region: "sa" },
        
        // Europe
        { name: "London", x: 0.45, y: 0.18, region: "eu" },
        { name: "Paris", x: 0.48, y: 0.22, region: "eu" },
        { name: "Berlin", x: 0.52, y: 0.18, region: "eu" },
        { name: "Rome", x: 0.52, y: 0.28, region: "eu" },
        { name: "Madrid", x: 0.42, y: 0.26, region: "eu" },
        
        // Asia
        { name: "Tokyo", x: 0.70, y: 0.35, region: "as" },
        { name: "Beijing", x: 0.68, y: 0.28, region: "as" },
        { name: "Shanghai", x: 0.72, y: 0.35, region: "as" },
        { name: "Mumbai", x: 0.65, y: 0.45, region: "as" },
        { name: "Delhi", x: 0.68, y: 0.40, region: "as" },
        
        // Africa
        { name: "Cairo", x: 0.55, y: 0.40, region: "af" },
        { name: "Lagos", x: 0.45, y: 0.55, region: "af" },
        { name: "Johannesburg", x: 0.52, y: 0.75, region: "af" },
        { name: "Nairobi", x: 0.58, y: 0.60, region: "af" },
        { name: "Cape Town", x: 0.50, y: 0.80, region: "af" },
        
        // Oceania
        { name: "Sydney", x: 0.72, y: 0.75, region: "oc" },
        { name: "Melbourne", x: 0.68, y: 0.80, region: "oc" },
        { name: "Auckland", x: 0.78, y: 0.85, region: "oc" },
        { name: "Perth", x: 0.65, y: 0.70, region: "oc" },
        { name: "Brisbane", x: 0.74, y: 0.72, region: "oc" }
    ];
    
    const cityLabelsContainer = document.getElementById('cityLabels');
    cityLabelsContainer.innerHTML = ''; // Clear existing labels
    cities = []; // Reset cities array
    activeCities = []; // Reset active cities array
    
    const screenWidth = landscapeCanvas.width;
    const screenHeight = landscapeCanvas.height;
    
    const padding = 80; // Buffer from screen edges
    
    cityData.forEach(city => {
        // Add padding to keep cities away from edges
        const newX = padding + (city.x * (screenWidth - 2 * padding));
        const newY = padding + (city.y * (screenHeight - 2 * padding));
        
        // Create city object for our internal tracking
        const cityObj = {
            name: city.name,
            x: newX,
            y: newY,
            region: city.region,
            element: null,
            opacity: 0,
            active: false,
            permanentElement: elementPersistence >= 0.8
        };
        
        // Create DOM element for the city
        const cityLabel = document.createElement('div');
        cityLabel.className = `city-label region-${city.region || 'na'}`;
        cityLabel.textContent = city.name;
        cityLabel.style.left = `${newX}px`;
        cityLabel.style.top = `${newY}px`;
        cityLabel.style.opacity = "0"; // Start hidden
        
        // Store reference to the DOM element
        cityObj.element = cityLabel;
        cities.push(cityObj);
        
        // Add to the container
        cityLabelsContainer.appendChild(cityLabel);
    });
    
    console.log(`Created ${cities.length} cities`);
}

// Function to update city positions
function updateCityPositions(virtualMovementX, virtualMovementY, slowFactor) {
    cities.forEach(city => {
        // Skip movement for permanent elements when persistence is at max
        if (elementPersistence >= 0.7 && city.permanentElement) {
            // Don't move or fade cities at high persistence
            // Just ensure they remain visible if active
            if (city.active && city.element) {
                city.element.style.opacity = "1";
            }
        } else {
            // Normal movement for other cases
            city.x -= virtualMovementX * 2 * slowFactor * cityMovementSpeed;
            city.y -= virtualMovementY * 2 * slowFactor * cityMovementSpeed;
            
            // Keep cities on screen - wrapped when going out of bounds
            const screenWidth = landscapeCanvas.width;
            const screenHeight = landscapeCanvas.height;
            const padding = 80; // Same padding as when creating cities
            
            if (city.x < padding) {
                city.x = screenWidth - padding;
            } else if (city.x > screenWidth - padding) {
                city.x = padding;
            }
            
            if (city.y < padding) {
                city.y = screenHeight - padding;
            } else if (city.y > screenHeight - padding) {
                city.y = padding;
            }
            
            // Only adjust opacity for active cities
            if (city.active) {
                // If the city is near the edge, start fading it
                const isNearEdge = 
                    city.x < padding + 20 || 
                    city.x > screenWidth - (padding + 20) ||
                    city.y < padding + 20 || 
                    city.y > screenHeight - (padding + 20);
                    
                if (isNearEdge) {
                    city.opacity = Math.max(0, city.opacity - 0.01);
                    if (city.opacity <= 0) {
                        city.active = false;
                        // Remove from active cities
                        const index = activeCities.indexOf(city);
                        if (index > -1) {
                            activeCities.splice(index, 1);
                        }
                    }
                }
            }
        }
        
        // Update DOM element position and opacity
        if (city.element) {
            city.element.style.left = `${city.x}px`;
            city.element.style.top = `${city.y}px`;
            if (city.active) {
                city.element.style.opacity = city.opacity;
            }
        }
    });
}

// Function to clear all active cities
function clearActiveCities() {
    // Clear all active cities
    activeCities.forEach(city => {
        if (city.element) {
            city.active = false;
            city.element.style.opacity = "0";
        }
    });
    activeCities = [];
    noteCounter = 0;
}

// Show city with note
function showCityWithNote() {
    if (!cities || cities.length === 0) return;
    
    // Increment note counter
    noteCounter++;
    
    // Only show a city every X notes
    if (noteCounter % cityDisplayInterval !== 0) return;
    
    // Make sure we don't have too many active cities (max 5)
    if (activeCities.length >= 5) {
        // Hide the oldest active city
        const oldestCity = activeCities.shift();
        if (oldestCity && oldestCity.element) {
            oldestCity.active = false;
            oldestCity.element.style.opacity = "0";
        }
    }
    
    // Find cities that aren't currently active and are within screen bounds
    const inactiveCities = cities.filter(city => {
        // Only consider cities that are well within the screen bounds
        return !city.active && 
               city.x >= 50 && city.x <= landscapeCanvas.width - 50 && 
               city.y >= 50 && city.y <= landscapeCanvas.height - 50;
    });
    
    if (inactiveCities.length === 0) return;
    
    // Select a random inactive city
    const randomIndex = Math.floor(Math.random() * inactiveCities.length);
    const city = inactiveCities[randomIndex];
    
    if (city && city.element) {
        // Mark as active
        city.active = true;
        city.opacity = 1.0;
        activeCities.push(city);
        
        // Apply flash animation and make visible
        city.element.classList.remove('city-flash');
        // Use setTimeout to ensure the removal is processed before adding
        setTimeout(() => {
            city.element.classList.add('city-flash');
            city.element.style.opacity = "1";
        }, 10);
    }
}

// Show status message
function showStatus(message) {
    const statusMessage = document.getElementById('statusMessage');
    if (statusMessage) {
        // Add fade animation for better visual feedback
        statusMessage.classList.add('status-fade');
        statusMessage.innerHTML = message;

        setTimeout(() => {
            statusMessage.classList.remove('status-fade');
        }, 500);

        // Log to console as well for debugging
        console.log(`Status: ${message.replace(/<[^>]*>/g, '')}`);
    }
}

// Fade out announcement
function fadeOutAnnouncement() {
    const announcementElement = document.getElementById('announcement');
    if (announcementElement) {
        announcementElement.style.opacity = '0';
        setTimeout(() => {
            announcementElement.style.display = 'none';
            // Reset text color if it was changed
            const announcementText = document.getElementById('announcementText');
            if (announcementText) {
                announcementText.style.color = '';
            }
        }, 700); // Match the CSS transition time
    }
}

// Generate flight announcements based on music
function generateAnnouncement() {
    if (!lastNoteData.frequency || !currentNoteData.frequency) return;
    const announcementElement = document.getElementById('announcement');
    const announcementText = document.getElementById('announcementText');
    if (!announcementElement || !announcementText) return;
    
    // Calculate properties for announcement variables
    const freqDifference = Math.abs(currentNoteData.frequency - lastNoteData.frequency);
    const normalizedFreq = currentNoteData.frequency / 500;
    
    // Generate announcement components
    const altitude = Math.floor(currentNoteData.frequency * 20);
    const temperature = Math.floor(-20 + normalizedFreq * 40);
    
    // Turbulence intensity based on frequency difference
    let turbulence = "mild";
    if (freqDifference > 150) turbulence = "significant";
    if (freqDifference > 300) turbulence = "moderate";
    
    // Flight phase
    let phase = "cruising";
    if (normalizedFreq < 0.3) phase = "descent";
    if (normalizedFreq > 0.7) phase = "ascent";
    
    // Terrain type based on current visual elements
    const terrain = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
    
    // View description
    const view = viewTypes[Math.floor(Math.random() * viewTypes.length)];
    
    // Obstacle type
    const obstacle = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
    
    // Weather description
    const weather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
    
    // Progress description
    const progressTypes = ["progress", "headway", "speed", "altitude gain"];
    const progress = progressTypes[Math.floor(Math.random() * progressTypes.length)];
    
    // Time estimate
    const time = Math.floor(20 + Math.random() * 40);
    
    // Atmosphere description
    const atmosphere = atmosphereTypes[Math.floor(Math.random() * atmosphereTypes.length)];
    
    // Direction change based on frequency difference
    let change = "slight adjustment";
    if (freqDifference > 100) change = "minor course correction";
    if (freqDifference > 200) change = "significant course adjustment";
    
    // Get announcement templates based on artist
    let announcementTemplates = announcements;
    
    // Use artist-specific announcements if available
    if (artistAnnouncements[currentArtist] && Math.random() < 0.7) {
        announcementTemplates = artistAnnouncements[currentArtist];
    }
    
    // Select a random announcement template
    const template = announcementTemplates[Math.floor(Math.random() * announcementTemplates.length)];
    
    // Replace variables in template
    let announcement = template
        .replace("{altitude}", altitude)
        .replace("{temp}", temperature)
        .replace("{turbulence}", turbulence)
        .replace("{terrain}", terrain)
        .replace("{phase}", phase)
        .replace("{view}", view)
        .replace("{obstacle}", obstacle)
        .replace("{weather}", weather)
        .replace("{progress}", progress)
        .replace("{time}", time)
        .replace("{atmosphere}", atmosphere)
        .replace("{change}", change);
    
    // Display the announcement
    announcementText.textContent = announcement;
    announcementElement.style.display = 'block';
    announcementElement.style.opacity = '1';
    
    // Update the last announcement time
    lastAnnouncementTime = Date.now();
    
    // Clear previous timer if exists
    if (announcementTimer) clearTimeout(announcementTimer);
    
    // Hide announcement after a delay
    const fadeTime = 5000 + Math.random() * 2000;
    announcementTimer = setTimeout(() => {
        fadeOutAnnouncement();
    }, fadeTime);
}

// Draw stars
function drawStars() {
    starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);

    // Draw stars with twinkling effect
    stars.forEach(star => {
        // Update star twinkle
        star.opacity += star.twinkleSpeed * star.twinkleDir;

        // Reverse direction if reached min/max opacity
        if (star.opacity >= 1 || star.opacity <= 0.1) {
            star.twinkleDir *= -1;
        }

        // Draw the star
        starsCtx.fillStyle = adjustOpacity(star.color, star.opacity);
        starsCtx.beginPath();
        starsCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        starsCtx.fill();
    });

    // Randomly create shooting stars (1% chance per frame when flying at high altitude)
    const altitude = altitudeControl ? parseFloat(altitudeControl.value) : 1.0;
    if (isFlying && altitude > 0.7 && Math.random() < 0.01) {
        shootingStars.push({
            x: Math.random() * starsCanvas.width,
            y: Math.random() * (starsCanvas.height * 0.5), // Top half of screen
            length: 30 + Math.random() * 50,
            speed: 5 + Math.random() * 10,
            angle: Math.PI / 4 + Math.random() * Math.PI / 4, // Diagonal
            opacity: 1,
            brightness: 0.5 + Math.random() * 0.5
        });
    }

    // Update and draw shooting stars
    shootingStars = shootingStars.filter(star => {
        star.x += Math.cos(star.angle) * star.speed;
        star.y += Math.sin(star.angle) * star.speed;
        star.opacity -= 0.02;

        if (star.opacity > 0) {
            // Draw shooting star as a gradient line
            const gradient = starsCtx.createLinearGradient(
                star.x, star.y,
                star.x - Math.cos(star.angle) * star.length,
                star.y - Math.sin(star.angle) * star.length
            );
            gradient.addColorStop(0, `rgba(255, 255, 255, ${star.opacity * star.brightness})`);
            gradient.addColorStop(0.5, `rgba(200, 220, 255, ${star.opacity * star.brightness * 0.5})`);
            gradient.addColorStop(1, `rgba(150, 180, 255, 0)`);

            starsCtx.strokeStyle = gradient;
            starsCtx.lineWidth = 2;
            starsCtx.beginPath();
            starsCtx.moveTo(star.x, star.y);
            starsCtx.lineTo(
                star.x - Math.cos(star.angle) * star.length,
                star.y - Math.sin(star.angle) * star.length
            );
            starsCtx.stroke();
            return true;
        }
        return false;
    });
}

// Update and draw cloud particles
function updateCloudParticles() {
    if (!landscapeCtx || !landscapeCanvas) return;

    // Generate new cloud particles (slower rate than stars)
    if (isFlying && Math.random() < 0.02) {
        cloudParticles.push({
            x: -50,
            y: 50 + Math.random() * (landscapeCanvas.height * 0.4),
            size: 30 + Math.random() * 50,
            speed: 0.5 + Math.random() * 1.5,
            opacity: 0.1 + Math.random() * 0.2,
            color: `rgba(255, 255, 255, ${0.1 + Math.random() * 0.15})`
        });
    }

    // Update and draw cloud particles
    cloudParticles = cloudParticles.filter(cloud => {
        cloud.x += cloud.speed;

        if (cloud.x < landscapeCanvas.width + 100) {
            landscapeCtx.beginPath();
            landscapeCtx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
            landscapeCtx.fillStyle = cloud.color;
            landscapeCtx.fill();

            // Add some blur effect
            landscapeCtx.beginPath();
            landscapeCtx.arc(cloud.x, cloud.y, cloud.size * 0.7, 0, Math.PI * 2);
            landscapeCtx.fillStyle = `rgba(255, 255, 255, ${cloud.opacity * 0.5})`;
            landscapeCtx.fill();

            return true;
        }
        return false;
    });
}

// Update and draw contrail particles
function updateContrailParticles() {
    if (!landscapeCtx || !landscapeCanvas || !isFlying) return;

    // Get plane position in pixels
    const planeX = (planePosition.x / 100) * landscapeCanvas.width;
    const planeY = (planePosition.y / 100) * landscapeCanvas.height;

    // Generate contrail particles behind the plane
    if (Math.random() < 0.3) {
        contrailParticles.push({
            x: planeX,
            y: planeY,
            size: 2 + Math.random() * 4,
            opacity: 0.6,
            life: 1.0,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5
        });
    }

    // Update and draw contrail particles
    contrailParticles = contrailParticles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life -= 0.01;
        particle.opacity = particle.life * 0.6;
        particle.size *= 1.02; // Expand slightly

        if (particle.life > 0) {
            landscapeCtx.beginPath();
            landscapeCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            landscapeCtx.fillStyle = `rgba(200, 220, 255, ${particle.opacity})`;
            landscapeCtx.fill();
            return true;
        }
        return false;
    });
}

// Draw atmospheric glow around plane
function drawAtmosphericGlow() {
    if (!landscapeCtx || !landscapeCanvas || !isFlying) return;

    const altitude = parseFloat(altitudeControl.value);
    const velocity = Math.sqrt(planeDirection.x * planeDirection.x + planeDirection.y * planeDirection.y);

    // Glow increases at high altitude and high speed
    const targetOpacity = (altitude * 0.3 + velocity * 5) * 0.3;
    const targetRadius = 40 + altitude * 30 + velocity * 100;

    // Smooth transitions
    atmosphericGlow.opacity += (targetOpacity - atmosphericGlow.opacity) * 0.1;
    atmosphericGlow.radius += (targetRadius - atmosphericGlow.radius) * 0.1;

    if (atmosphericGlow.opacity > 0.05) {
        const planeX = (planePosition.x / 100) * landscapeCanvas.width;
        const planeY = (planePosition.y / 100) * landscapeCanvas.height;

        // Draw glow
        const gradient = landscapeCtx.createRadialGradient(
            planeX, planeY, 0,
            planeX, planeY, atmosphericGlow.radius
        );
        gradient.addColorStop(0, `rgba(150, 200, 255, ${atmosphericGlow.opacity})`);
        gradient.addColorStop(0.5, `rgba(100, 150, 255, ${atmosphericGlow.opacity * 0.5})`);
        gradient.addColorStop(1, 'rgba(50, 100, 200, 0)');

        landscapeCtx.fillStyle = gradient;
        landscapeCtx.fillRect(
            planeX - atmosphericGlow.radius,
            planeY - atmosphericGlow.radius,
            atmosphericGlow.radius * 2,
            atmosphericGlow.radius * 2
        );
    }
}

// Draw landscape
function drawLandscape() {
    landscapeCtx.clearRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);

    // Draw sky gradient
    const altitude = altitudeControl ? parseFloat(altitudeControl.value) : 1.0;
    const skyColors = {
        top: altitude < 1 ? '#1a2f38' : (altitude > 1.5 ? '#0a1525' : '#1a2f38'),
        bottom: altitude < 1 ? '#2c3e50' : (altitude > 1.5 ? '#162740' : '#2c3e50')
    };
    
    const gradient = landscapeCtx.createLinearGradient(0, 0, 0, landscapeCanvas.height);
    gradient.addColorStop(0, skyColors.top);
    gradient.addColorStop(1, skyColors.bottom);
    landscapeCtx.fillStyle = gradient;
    landscapeCtx.fillRect(0, 0, landscapeCanvas.width, landscapeCanvas.height);
    
    // Draw flight paths
    flightPaths.forEach(path => {
        landscapeCtx.beginPath();
        landscapeCtx.moveTo(path.x1, path.y1);
        landscapeCtx.lineTo(path.x2, path.y2);
        landscapeCtx.strokeStyle = path.opacity ? 
            `rgba(236, 240, 241, ${path.opacity})` : 
            colors.flightPaths;
        landscapeCtx.lineWidth = path.width;
        landscapeCtx.stroke();
    });
    
    // Draw mountains
    mountains = mountains.filter(mountain => {
        if (mountain.fadeRate && mountain.opacity <= 0) return false;
        
        if (mountain.isBuilding) {
            // Draw a building (rectangle)
            landscapeCtx.beginPath();
            
            // Apply opacity if fading
            if (mountain.fadeRate) {
                landscapeCtx.fillStyle = adjustOpacity(mountain.color, mountain.opacity);
                mountain.opacity -= mountain.fadeRate;
            } else {
                landscapeCtx.fillStyle = mountain.color;
            }
            
            // Draw a rectangle with small windows
            landscapeCtx.fillRect(
                mountain.x - mountain.width / 4, 
                mountain.y, 
                mountain.width / 2, 
                mountain.height
            );
            
            // Add windows
            const windowColor = 'rgba(255, 255, 200, 0.3)';
            const windowSize = mountain.width / 12;
            const buildingWidth = mountain.width / 2;
            const windowsPerFloor = Math.max(1, Math.floor(buildingWidth / windowSize) - 1);
            const floors = Math.max(2, Math.floor(mountain.height / windowSize) - 1);
            
            landscapeCtx.fillStyle = windowColor;
            
            for (let floor = 1; floor < floors; floor++) {
                for (let win = 0; win < windowsPerFloor; win++) {
                    // Only draw some windows (not all lights on)
                    if (Math.random() < 0.7) {
                        landscapeCtx.fillRect(
                            mountain.x - mountain.width / 4 + windowSize + win * (buildingWidth - windowSize) / windowsPerFloor,
                            mountain.y + floor * mountain.height / floors,
                            windowSize / 2,
                            windowSize / 2
                        );
                    }
                }
            }
        } else {
            // Triangle mountain
            landscapeCtx.beginPath();
            landscapeCtx.moveTo(mountain.x, mountain.y);
            landscapeCtx.lineTo(mountain.x - mountain.width / 2, mountain.y + mountain.height);
            landscapeCtx.lineTo(mountain.x + mountain.width / 2, mountain.y + mountain.height);
            landscapeCtx.closePath();
            
            // Apply opacity if fading
            if (mountain.fadeRate) {
                landscapeCtx.fillStyle = adjustOpacity(mountain.color, mountain.opacity);
                mountain.opacity -= mountain.fadeRate;
            } else {
                landscapeCtx.fillStyle = mountain.color;
            }
            
            landscapeCtx.fill();
        }
        
        return true;
    });
    
    // Draw clouds
    clouds = clouds.filter(cloud => {
        if (cloud.fadeRate && cloud.opacity <= 0) return false;
        
        // Move cloud
        cloud.x += cloud.speed;
        if (cloud.x > landscapeCanvas.width + cloud.width) {
            cloud.x = -cloud.width;
        }
        
        // Draw cloud (cluster of circles)
        const opacity = cloud.fadeRate ? cloud.opacity : cloud.opacity;
        landscapeCtx.fillStyle = typeof cloud.color === 'string' ? 
            adjustOpacity(cloud.color, opacity) : 
            adjustOpacity(colors.clouds[0], opacity);
        
        // Draw multiple circles to form cloud shape
        const bubbleCount = cloud.bubbles || 3;

        // Main circle
        landscapeCtx.beginPath();
        landscapeCtx.arc(cloud.x, cloud.y, cloud.width / 3, 0, Math.PI * 2);
        landscapeCtx.fill();
        
        // Additional circles to create cloud shape
        for (let i = 0; i < bubbleCount; i++) {
            const offsetX = (i - bubbleCount/2) * (cloud.width / bubbleCount);
            const offsetY = (Math.random() - 0.5) * (cloud.height / 3);
            const size = (0.5 + Math.random() * 0.5) * (cloud.width / 3);
            
            landscapeCtx.beginPath();
            landscapeCtx.arc(
                cloud.x + offsetX, 
                cloud.y + offsetY, 
                size, 
                0, 
                Math.PI * 2
            );
            landscapeCtx.fill();
        }
        
        // Apply fading if necessary
        if (cloud.fadeRate) {
            cloud.opacity -= cloud.fadeRate;
        }
        
        return true;
    });

    // Draw landing particles if landed
    if (isLanded) {
        drawLandingParticles();
    }
}

// Draw solid trail like in travel movies
function drawSolidTrail() {
    // Clear and redraw the entire trail each frame
    trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
    
    if (planeTrail.length > 1) {
        trailCtx.beginPath();
        trailCtx.moveTo(planeTrail[0].x, planeTrail[0].y);
        
        for (let i = 1; i < planeTrail.length; i++) {
            trailCtx.lineTo(planeTrail[i].x, planeTrail[i].y);
        }
        
        // Create a dash pattern for the classic "travel movie" look
        trailCtx.setLineDash([5, 5]);
        trailCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; // Classic red line
        trailCtx.lineWidth = 2;
        trailCtx.stroke();
        
        // Reset dash pattern
        trailCtx.setLineDash([]);
    }
}

// Draw permanent trail - Enhanced to be more reactive to music
function drawPermanentTrail() {
    // Skip if no trail or in hidden mode
    if (smoothedTrail.length < 2) return;
    
    // Get current intensity
    const intensity = parseFloat(trailIntensityControl.value);
    
    // First clear the canvas - only if not in permanent mode
    if (!trailPermaMode) {
        trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
    }
    
    // Create gradient for trail using artist color if available
    let trailColor = '#e74c3c'; // Default red
    if (artistStyles[currentArtist] && artistStyles[currentArtist].noteColor) {
        trailColor = artistStyles[currentArtist].noteColor;
    }
    
    // Draw the permanent trail
    trailCtx.lineJoin = 'round';
    trailCtx.lineCap = 'round';
    
    // For more music reactivity, use the current frequency to modulate the trail
    const currentFrequency = currentNoteData.frequency || 261.63; // Default to middle C if no note
    const frequencyFactor = Math.min(2, currentFrequency / 261.63); // Normalize around middle C with a cap
    
    // Start path
    trailCtx.beginPath();
    trailCtx.moveTo(smoothedTrail[0].x, smoothedTrail[0].y);
    
    // Draw smooth curve through points
    for (let i = 1; i < smoothedTrail.length; i++) {
        // Use frequency to modulate the trail
        const point = smoothedTrail[i];
        
        // Skip points with no frequency data in permanent trail
        if (!point.frequency) continue;
        
        // Calculate normalized frequency for this point
        const pointFreq = point.frequency || 261.63;
        const normalizedFreq = Math.min(1, (pointFreq - 100) / 800);
        
        // Adjust line width based on frequency, intensity, and current frequency factor
        // The frequencyFactor makes the trail "pulse" with the current note
        const width = 1 + (normalizedFreq * 10 * intensity * frequencyFactor);
        trailCtx.lineWidth = width;
        
        // Adjust opacity based on frequency, intensity, and current frequency factor
        const opacity = 0.2 + (normalizedFreq * 0.8 * intensity * (frequencyFactor * 0.5));
        trailCtx.strokeStyle = adjustOpacity(trailColor, opacity);
        
        // Connect to next point smoothly
        if (i < smoothedTrail.length - 1) {
            const xc = (point.x + smoothedTrail[i+1].x) / 2;
            const yc = (point.y + smoothedTrail[i+1].y) / 2;
            trailCtx.quadraticCurveTo(point.x, point.y, xc, yc);
        } else {
            trailCtx.lineTo(point.x, point.y);
        }
        
        // Complete current segment and start a new one to allow color changes
        trailCtx.stroke();
        trailCtx.beginPath();
        trailCtx.moveTo(point.x, point.y);
    }
}

// Enhanced drawNoteVisualization function for more vibrant visuals
function drawNoteVisualization() {
    noteCtx.clearRect(0, 0, noteCanvas.width, noteCanvas.height);
    
    // Draw expanding circles with enhanced styling
    noteCircles = noteCircles.filter(circle => {
        circle.radius += circle.growRate;
        circle.opacity -= 0.01;
        
        if (circle.radius > circle.maxRadius || circle.opacity <= 0) {
            return false;
        }
        
        // Add glow effect for more visual appeal
        const glow = 10 + (circle.radius / 5);
        noteCtx.shadowBlur = glow;
        noteCtx.shadowColor = circle.color;
        
        // Draw the circle
        noteCtx.beginPath();
        noteCtx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
        noteCtx.strokeStyle = adjustOpacity(circle.color, circle.opacity);
        noteCtx.lineWidth = 2;
        noteCtx.stroke();
        
        // Optional: Add a smaller filled circle for more emphasis
        if (circle.radius < 15) {
            noteCtx.beginPath();
            noteCtx.arc(circle.x, circle.y, circle.radius / 3, 0, Math.PI * 2);
            noteCtx.fillStyle = adjustOpacity(circle.color, circle.opacity * 0.7);
            noteCtx.fill();
        }
        
        // Reset shadow for next element
        noteCtx.shadowBlur = 0;
        
        return true;
    });
}

// Sequencer class for ambient note generation
class AmbientSequencer {
    constructor(id) {
        this.id = id;
        this.currentPattern = null;
        this.patternIndex = 0;
        this.lastFrequency = 0;
        this.noteInterval = (3000 + Math.random() * 2000); // Different base interval for each sequencer
        this.nextNoteTime = 0;
    }

    selectPattern() {
        // Randomly choose between harmonic and plane note sets based on current destination
        this.currentPattern = Math.random() < 0.6 ? 
            harmonicNotes[Math.floor(Math.random() * harmonicNotes.length)] :
            planeNotes[Math.floor(Math.random() * planeNotes.length)];
        this.patternIndex = 0;
        
        // Randomize the next note interval
        // Use artist-specific note interval if available
        if (artistStyles[currentArtist] && artistStyles[currentArtist].noteInterval) {
            this.noteInterval = artistStyles[currentArtist].noteInterval * (0.8 + Math.random() * 0.4); // Slight randomness
        } else {
            this.noteInterval = 2000 + Math.random() * 5000;
        }
    }
    
    randomizeNoteTimer() {
        // Use BPM for timing
        let bpm = tempoControl ? parseFloat(tempoControl.value) : 90;
        
        // Calculate beat duration in seconds (60 seconds / BPM)
        const beatDuration = 60 / bpm;
        
        // Different note values for different sequencers
        // Sequencer 1: quarter notes, eighth notes, half notes
        // Sequencer 2: triplets, dotted notes
        let noteDuration;
        
        if (this.id === 1) {
            // For sequencer 1, use standard note values
            const noteValues = [0.5, 1, 2]; // half note, quarter note, eighth note (relative to beat)
            noteDuration = beatDuration * noteValues[Math.floor(Math.random() * noteValues.length)];
        } else {
            // For sequencer 2, use more complex rhythms
            const noteValues = [0.75, 1.5, 0.33, 0.66]; // dotted notes and triplets
            noteDuration = beatDuration * noteValues[Math.floor(Math.random() * noteValues.length)];
        }
        
        // Add slight humanization (¬±10%)
        const humanization = 1 + ((Math.random() * 0.2) - 0.1);
        noteDuration *= humanization;
        
        // Set next note time
        this.nextNoteTime = audioContext.currentTime + noteDuration;
    }

    playNote() {
        if (!isFlying || !audioContext) {
            if (!isFlying) console.log('Sequencer', this.id, ': Not flying, skipping note');
            if (!audioContext) console.log('Sequencer', this.id, ': No audio context, skipping note');
            return;
        }
        if (!this.currentPattern) this.selectPattern();

        try {
            // Check if audio context is running
            if (audioContext.state !== 'running') {
                console.warn('Sequencer', this.id, ': AudioContext not running (state:', audioContext.state, '), trying to resume...');
                audioContext.resume().then(() => {
                    console.log('Sequencer', this.id, ': AudioContext resumed in playNote');
                    // Try again after resuming
                    setTimeout(() => this.playNote(), 100);
                }).catch(err => {
                    console.error('Sequencer', this.id, ': Failed to resume AudioContext in playNote:', err);
                });
                return;
            }
            
            // Get settings from controls
            const decayTime = parseFloat(decayControl.value);
            const volume = parseFloat(volumeControl.value) * (this.id === 2 ? 0.7 : 1.0); // Sequencer 2 slightly quieter
            const altitude = parseFloat(altitudeControl.value);

            // Select a note from the current pattern
            const baseFreq = 261.63 * altitude; // Middle C adjusted by altitude
            const noteIndex = Math.floor(Math.random() * this.currentPattern.length); // Pick random note from pattern
            const noteFreq = this.currentPattern[noteIndex];
            
            // Prevent ultra-high frequencies that cause warnings
            let frequency;
            if (typeof noteFreq === 'number') {
                const rawFreq = baseFreq * Math.pow(2, noteFreq / 12);
                // Clamp frequency to a reasonable range to avoid warnings
                frequency = Math.min(20000, Math.max(safeLowFreq, rawFreq)); // Use safeLowFreq as minimum
            } else {
                frequency = Math.min(20000, Math.max(safeLowFreq, noteFreq)); // Use safeLowFreq as minimum
            }
            
            this.lastFrequency = frequency;

            // Store note data for announcements
            lastNoteData = {...currentNoteData};
            currentNoteData = {
                frequency: frequency,
                time: audioContext.currentTime,
                sequencerId: this.id
            };
            
            // Create oscillator
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Use different waveforms for variation based on sequencer
            const waveforms = this.id === 1 ? ['sine', 'triangle'] : ['sine', 'triangle', 'sawtooth'];
            oscillator.type = waveforms[Math.floor(Math.random() * waveforms.length)];
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            // Soft attack and long decay for ambient feel
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.2 + Math.random() * 0.3);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + decayTime);

            // Connect nodes to master gain (all safety nodes are in the chain from there)
            oscillator.connect(gainNode);
            gainNode.connect(masterGainNode);

            // Start and stop oscillator
            oscillator.start();
            oscillator.stop(audioContext.currentTime + decayTime);

            // Store for potential future management
            activeOscillators.push(oscillator);

            // Track note in flight log
            trackNotePlayed();

            // Log successful note creation (only occasionally to avoid spam)
            if (Math.random() < 0.1) {
                console.log('Sequencer', this.id, ': Playing note at', frequency.toFixed(2), 'Hz, decay:', decayTime + 's');
            }

            // Increment pattern index and occasionally randomize
            this.patternIndex++;
            if (Math.random() < 0.15) this.selectPattern();

            // Visualize note and affect plane movement
            this.visualizeNote(frequency);
            this.affectPlaneMovement(frequency);
            
            // Create a landscape element
            if (Math.random() < 0.4) {
                createLandscapeElement(frequency);
            }
            
            // Generate announcements based on note interaction
            if (this.id === 1 && Math.random() < 0.03) { // Only first sequencer generates announcements
                generateAnnouncement();
            }
            
            // Show a city with notes at regular intervals
            if (this.id === 1) {
                showCityWithNote();
            }
            
            // Randomize next note time
            this.randomizeNoteTimer();
            
            // Schedule next note check
            setTimeout(() => this.checkAndPlayNote(), 100);
            
        } catch (error) {
            console.error('Error playing note:', error);
            showStatus('Error playing note: ' + error.message);
            
            // Try again later
            this.randomizeNoteTimer();
            setTimeout(() => this.checkAndPlayNote(), 1000);
        }
    }
    
    checkAndPlayNote() {
        if (!isFlying || !audioContext) return;
        
        // Check if it's time to play the next note
        if (audioContext.currentTime >= this.nextNoteTime) {
            this.playNote();
        } else {
            // Check again soon
            setTimeout(() => this.checkAndPlayNote(), 100);
        }
    }
    
    // Enhanced visualizeNote function to create more visual flair
    visualizeNote(frequency) {
        // Create expanding circle at plane position
        const normalizedFreq = (frequency - 100) / 500;
        
        // Use artist-specific note color if available
        let noteColor;
        if (artistStyles[currentArtist] && artistStyles[currentArtist].noteColor) {
            noteColor = artistStyles[currentArtist].noteColor;
        } else {
            const colorIndex = Math.floor(normalizedFreq * colors.notes.length) % colors.notes.length;
            noteColor = colors.notes[colorIndex] || colors.notes[0];
        }
        
        // Use the actual plane position
        const planePixelX = (planePosition.x * flightCanvas.width / 100);
        const planePixelY = (planePosition.y * flightCanvas.height / 100);
        
        // Create multiple circles with varying distances from the plane
        // More circles = more visual flair
        const circleCount = this.id === 1 ? 3 : 2; // More circles for primary sequencer
        
        for (let i = 0; i < circleCount; i++) {
            // Wider distribution of circles
            const distanceFactor = 20 + (i * 15); // Increasing distance for each circle
            const xOffset = (Math.random() * distanceFactor * 2) - distanceFactor;
            const yOffset = (Math.random() * distanceFactor * 2) - distanceFactor;
            
            // Only create circles that aren't directly on the plane
            if (Math.abs(xOffset) > 10 || Math.abs(yOffset) > 10) {
                const circle = {
                    x: planePixelX + xOffset,
                    y: planePixelY + yOffset,
                    radius: 3 + (Math.random() * 4), // Varying initial radius
                    maxRadius: 20 + Math.random() * 50, // Larger max radius for more visible effects
                    color: noteColor,
                    opacity: 0.7 + (Math.random() * 0.3), // Varying opacity
                    growRate: 0.4 + Math.random() * 0.6, // Varying growth rate
                    sequencerId: this.id
                };
                
                noteCircles.push(circle);
            }
        }
        
        // Add point to the permanent trail using the newest frequency
        // Higher probability = more trail points = more visual interest
        if (isFlying && trailPermaMode && Math.random() < 0.35) {
            smoothedTrail.push({
                x: planePixelX,
                y: planePixelY,
                frequency: frequency
            });
            
            // Limit trail points
            if (smoothedTrail.length > MAX_SMOOTHED_POINTS) {
                smoothedTrail.shift();
            }
        }
    }
    
    affectPlaneMovement(frequency) {
        // Change plane direction based on frequency
        const normalizedFreq = (frequency - 100) / 500;
        
        // Add a small random change to direction
        planeDirection.x += (Math.random() * 0.1 - 0.05) * normalizedFreq;
        planeDirection.y += (Math.random() * 0.1 - 0.05) * normalizedFreq;
        
        // Limit direction change
        planeDirection.x = Math.max(-0.1, Math.min(0.1, planeDirection.x));
        planeDirection.y = Math.max(-0.07, Math.min(0.07, planeDirection.y));
        
        // Normalize direction vector for consistent speed
        const magnitude = Math.sqrt(
            planeDirection.x * planeDirection.x + 
            planeDirection.y * planeDirection.y
        );
        
        if (magnitude > 0) {
            planeDirection.x /= magnitude;
            planeDirection.y /= magnitude;
            
            // Scale direction based on frequency and tempo
            const tempo = tempoControl ? parseFloat(tempoControl.value) : 90;
            const tempoFactor = tempo / 100; // Base speed at 100 BPM
            const speedFactor = (0.1 + (normalizedFreq * 0.15)) * tempoFactor * planeMovementSpeed;
            
            planeDirection.x *= speedFactor;
            planeDirection.y *= speedFactor;
        }
    }
    
    start() {
        if (!audioContext) return;
        this.randomizeNoteTimer();
        this.checkAndPlayNote();
    }
    
    stop() {
        // Nothing to do here, the checks in playNote will prevent further notes
    }
}

// Initialize the application when document is ready
document.addEventListener('DOMContentLoaded', init);

// Initialize even if DOMContentLoaded already fired (for some browsers)
if (document.readyState === 'interactive' || document.readyState === 'complete') {
    console.log('Document already loaded, initializing immediately');
    init();
}
</script>
    </body>
    </html>
